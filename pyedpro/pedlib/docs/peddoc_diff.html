<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>peddoc_diff API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>peddoc_diff</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

from __future__ import absolute_import, print_function

import os
import time
import string
import pickle
import re
import platform
import subprocess

import gi;  gi.require_version(&#34;Gtk&#34;, &#34;3.0&#34;)
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Pango

gi.require_version(&#39;PangoCairo&#39;, &#39;1.0&#39;)
from gi.repository import PangoCairo

import pedlib.pedconfig as pedconfig
import pedlib.peddraw as  peddraw
import pedlib.pedync   as  pedync
import pedlib.pedspell as  pedspell
import pedlib.pedcolor as  pedcolor
import pedlib.pedmenu  as  pedmenu
import pedlib.pedundo  as  pedundo
import pedlib.pedmisc  as  pedmisc

from pedlib.pedutil import *
from pedlib.keywords import *

(TARGET_ENTRY_TEXT, TARGET_ENTRY_PIXBUF) = range(2)
(COLUMN_TEXT, COLUMN_PIXBUF) = range(2)
DRAG_ACTION = Gdk.DragAction.COPY

VSCROLLGAP  = 2             # Gap between the page boundary and ver. scroll
HSCROLLGAP  = 4             # Gap between the page boundary and hor. scroll
PAGEUP      = 20            # One page worth of scroll

# Do not redefine this here, as it is determined by the gtk (pango) lib
#TABSTOP = 8                 # One tab stop worth of spaces

# On version 0.21 (and after) we force GTK to assume our idea of tabstop.
# Even though we do not draw the tabs with GTK it is cleaner (simpler)
# this way. (See mess on tabs before V21)
TABSTOP = 4                 # One tab stop worth of spaces

# Profile line, use it on bottlenecks Widget set_a
#got_clock = time.clock()
# profiled code here
#print(  &#34;Str&#34;, time.clock() - got_clock)

# Globals

last_scanned = None

# Colors for the text, configure the defaults here

FGCOLOR     = &#34;#000000&#34;
FGCOLORRO   = &#34;#222222&#34;
RFGCOLOR    = &#34;#fefefe&#34;
BGCOLOR     = &#34;#fefefe&#34;
RBGCOLOR    = &#34;#aaaaff&#34;
CBGCOLOR    = &#34;#ff8888&#34;
KWCOLOR     = &#34;#88aaff&#34;
CLCOLOR     = &#34;#880000&#34;
COCOLOR     = &#34;#4444ff&#34;
STCOLOR     = &#34;#ee44ee&#34;

CARCOLOR = &#34;#4455dd&#34;

# UI specific values:

DRAGTRESH = 3                   # This many pixels for drag highlight

# ------------------------------------------------------------------------
# We create a custom class for display, as we want a text editor that
# can take thousands of lines.

class pedDoc(Gtk.DrawingArea, peddraw.peddraw):

    def __init__(self, buff, mained, readonly = False):

        # Save params
        self.mained = mained
        self.readonly = readonly

        # Gather globals
        self.keyh = pedconfig.conf.keyh
        self.acth = pedconfig.conf.acth

        # Init vars
        self.xpos = 0; self.ypos = 0
        self.changed = False
        self.src_changed = False
        self.needscan = True
        self.record = False
        self.recarr = []                # Macros
        self.undoarr = []               # Undo
        self.redoarr = []               # Redo
        self.queue = []                 # Idle tasks
        self.colsel = False
        self.oldsearch = &#34;&#34;
        self.oldgoto = &#34;&#34;
        self.oldrep = &#34;&#34;
        self.xsel = -1; self.ysel = -1
        self.xsel2 = -1; self.ysel2 = -1
        self.mx = -1; self.my = -1
        self.caret = []; self.caret.append(0); self.caret.append(0)
        self.focus = False
        self.insert = True
        self.startxxx = -1;  self.startyyy = -1
        self.hex = False
        self.colflag = True
        self.acorr = False
        self.scol = False
        self.accum = []
        self.tokens = []
        self.ularr = []
        self.bigcaret = False
        self.stab = False
        self.oneshot = False
        self.initial_undo_size = 0
        self.initial_redo_size = 0
        self.spell = False
        self.spellmode = False
        self.start_time = time.time()
        self.shift = False
        # Init configurables
        self.vscgap = VSCROLLGAP
        self.hscgap = HSCROLLGAP
        self.pgup  = PAGEUP
        self.tabstop = TABSTOP
        # Process buffer into list
        self.text = buff
        self.maxlinelen = 0
        self.maxlines = 0
        self.fired = 0
        self.countup = 0
        self.nokey = False
        self.newword = False
        self.scrtab = False
        self.stat = None
        self.sep = &#34;\n&#34;
        self.tts = None
        self.lastcmd = &#34;&#34;
        self.caps = False
        self.scr = False
        self.lastevent = None
        self.hhh = self.www = 0
        self.diffmode = 0

        self.FGCOLOR    = FGCOLOR
        self.FGCOLORRO  = FGCOLORRO
        self.RFGCOLOR   = RFGCOLOR
        self.BGCOLOR    = BGCOLOR
        self.RBGCOLOR   = RBGCOLOR
        self.CBGCOLOR   = CBGCOLOR
        self.KWCOLOR    = KWCOLOR
        self.CLCOLOR    = CLCOLOR
        self.COCOLOR    = COCOLOR
        self.STCOLOR    = STCOLOR

        # Parent widget
        Gtk.DrawingArea.__init__(self)
        self.set_can_focus(True)
        peddraw.peddraw.__init__(self, self)

        # Our font
        fsize  =  pedconfig.conf.sql.get_int(&#34;fsize&#34;)
        fname  =  pedconfig.conf.sql.get_str(&#34;fname&#34;)
        if fsize == 0: fsize = 14
        if fname == &#34;&#34;: fname = &#34;Monospace&#34;

        self.setfont(fname, fsize)

        if self.readonly:
            self.set_tooltip_text(&#34;Read only buffer&#34;)

        # Create scroll items
        sm = len(self.text) + self.get_height() / self.cyy + 10
        self.hadj = Gtk.Adjustment(value=0, lower=0, upper=self.maxlinelen,
                            step_increment = 1, page_increment = 15, page_size = 25)
        self.vadj = Gtk.Adjustment(value=0, lower=0, upper=sm,
                            step_increment = 1, page_increment = 15, page_size = 25)

        self.vscroll = Gtk.VScrollbar(adjustment=self.vadj)
        self.hscroll = Gtk.HScrollbar(adjustment=self.hadj)

        # We connect scrollers after construction
        self.hadj.connect(&#34;value-changed&#34;, self.hscroll_cb)
        self.vadj.connect(&#34;value-changed&#34;, self.vscroll_cb)

        self.set_events(Gdk.EventMask.ALL_EVENTS_MASK)

        #self.colormap = Gtk.widget_get_default_colormap()
        self.setcol()

        # Set default background color
        if self.readonly:
            #color = self.colormap.alloc_color(&#34;#d8d8d8&#34;)
            #self.modify_bg(Gtk.STATE_NORMAL, color)
            pass

        #self.connect(&#34;expose-event&#34;, self.area_expose_cb)
        self.connect(&#34;draw&#34;, self.draw_event)
        self.connect(&#34;motion-notify-event&#34;, self.area_motion)
        self.connect(&#34;button-press-event&#34;, self.area_button)
        self.connect(&#34;button-release-event&#34;, self.area_button)
        self.connect(&#34;key-press-event&#34;, self.area_key)
        self.connect(&#34;key-release-event&#34;, self.area_key)
        self.connect(&#34;focus&#34;, self.area_focus)
        self.connect(&#34;configure_event&#34;, self.configure_event)
        #self.connect(&#34;size-request&#34;, self.)
        self.connect(&#34;size-allocate&#34;, self.size_alloc)
        self.connect(&#34;scroll-event&#34;, self.scroll_event)
        self.connect(&#34;focus-in-event&#34;, self.focus_in_cb)
        self.connect(&#34;focus-out-event&#34;, self.focus_out_cb)

        self.drag_dest_set(0, [], 0)
        self.connect(&#39;drag-motion&#39;, self.on_drag_motion)
        self.connect(&#39;drag-drop&#39;, self.on_drag_drop)
        self.connect(&#34;drag-data-received&#34;, self.on_drag_data_received)

    def on_drag_motion(self, widgt, context, c, y, time):
        Gdk.drag_status(context, Gdk.DragAction.COPY, time)
        return True

    def on_drag_drop(self, widget, context, x, y, time):
        widget.drag_get_data(context, context.list_targets()[-1], time)

    def on_drag_data_received(self, widget, drag_context, x, y, data, info, time):

        if info ==  TARGET_ENTRY_TEXT:
            text = data.get_text()
            #print(&#34;Received text: %s&#34; % text)
            pedconfig.conf.keyh.acth.add_str(self, text)

        elif info ==  TARGET_ENTRY_PIXBUF:
            pixbuf = data.get_pixbuf()
            width = pixbuf.get_width()
            height = pixbuf.get_height()

            print(&#34;Received pixbuf with width %spx and height %spx&#34; % (width, height))

    # Customize your colors here
    def setcol(self):
        ccc = pedconfig.conf.sql.get_str(&#34;fgcolor&#34;)
        if ccc == &#34;&#34;:
            self.fgcolor  = pedcolor.str2float(FGCOLOR)
        else:
            self.fgcolor  = pedcolor.str2float(ccc)
        #print( &#34;fgcol&#34;, self.fgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;rbgcolor&#34;)
        if ccc == &#34;&#34;:
            self.rbgcolor = pedcolor.str2float(RBGCOLOR)
        else:
            self.rbgcolor = pedcolor.str2float(ccc)
        #print( &#34;rgbcolor&#34;, self.rbgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;bgcolor&#34;)
        if ccc == &#34;&#34;:
            self.bgcolor = pedcolor.str2float(BGCOLOR)
        else:
            self.bgcolor = pedcolor.str2float(ccc)
        #print( &#34;bgcolor&#34;, self.bgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;cbgcolor&#34;)
        if ccc == &#34;&#34;:
            self.cbgcolor = pedcolor.str2float(CBGCOLOR)
        else:
            self.cbgcolor = pedcolor.str2float(ccc)
        #print( &#34;cbgcolor&#34;, self.cbgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;kwcolor&#34;)
        if ccc == &#34;&#34;:
            self.kwcolor = pedcolor.str2float(KWCOLOR)
        else:
            self.kwcolor = pedcolor.str2float(ccc)
        #print( &#34;load kwcolor&#34;, self.kwcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;clcolor&#34;)
        if ccc == &#34;&#34;:
            self.clcolor = pedcolor.str2float(CLCOLOR)
        else:
            self.clcolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;cocolor&#34;)
        if ccc == &#34;&#34;:
            self.cocolor = pedcolor.str2float(COCOLOR)
        else:
            self.cocolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;stcolor&#34;)
        if ccc == &#34;&#34;:
            self.stcolor = pedcolor.str2float(STCOLOR)
        else:
            self.stcolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;carcolor&#34;)
        if ccc == &#34;&#34;:
            self.carcolor = pedcolor.str2float(CARCOLOR)
        else:
            self.carcolor = pedcolor.str2float(ccc)

    def setfont(self, fam, size):

        self.fd = Pango.FontDescription()
        self.fd.set_family(fam)
        self.fd.set_size(size * Pango.SCALE)

        self.pangolayout = self.create_pango_layout(&#34;a&#34;)
        self.pangolayout.set_font_description(self.fd)

        # Get Pango steps
        self.cxx, self.cyy = self.pangolayout.get_pixel_size()

        # Get Pango tabs
        self.tabarr = Pango.TabArray(80, False)
        #for aa in range(self.tabarr.get_size()):
        #    self.tabarr.set_tab(aa, Pango.TAB_LEFT, aa * TABSTOP * self.cxx * Pango.SCALE)

        self.pangolayout.set_tabs(self.tabarr)
        ts = self.pangolayout.get_tabs()

        &#39;&#39;&#39;if ts != None:
            al, self.tabstop = ts.get_tab(1)
        self.tabstop /= self.cxx * Pango.SCALE&#39;&#39;&#39;

    def  set_maxlinelen(self, mlen = -1, ignore = True):
        if mlen == -1: self.calc_maxline()
        self.maxlinelen = mlen
        self.oneshot = ignore
        #value, lower, upper, step_increment, page_increment, page_size)
        #self.hadj.set_all(0, 0, self.maxlinelen * 2, 1, 15, 25)
        self.hadj.set_value(0)
        self.hadj.set_lower(0)
        self.hadj.set_upper(self.maxlinelen * 2)
        self.hadj.set_step_increment(1)
        self.hadj.set_page_increment(15)
        self.hadj.set_page_size(25)

    def  set_maxlines(self, lines = 0, ignore = True):
        self.maxlines = len(self.text) + self.get_height() / self.cyy + 25
        self.oneshot = ignore
        #self.vadj.set_all(0, 0, self.maxlines, 1, 15, 25)
        self.vadj.set_value(0)
        self.vadj.set_lower(0)
        self.vadj.set_upper(self.maxlines)
        self.vadj.set_step_increment(1)
        self.vadj.set_page_increment(15)
        self.vadj.set_page_size(25)

    # Do Tasks  when the system is idle
    def idle_callback(self):
        #print( &#34;Idle callback&#34;)
        GLib.source_remove(self.source_id)
        try:
            if self.changed:
                hhh = hash_name(self.fname) + &#34;.sav&#34;
                xfile = pedconfig.conf.data_dir + os.sep + hhh
                err = writefile(xfile, self.text, &#34;\n&#34;)
                if err[0]:
                    strx = &#34;Backed up file &#39;{0:s}&#39;&#34;.format(xfile)
                else:
                    strx = &#34;Cannot back up file &#39;{0:s}&#39; {1:s}&#34;.format(xfile, err[1])

                self.mained.update_statusbar(strx)
        except:
            print(&#34;Exception in idle handler&#34;, sys.exc_info())

    # Do Tasks2 when the system is idle
    def idle_callback2(self):
        #print( &#34;Idle callback2&#34;)
        GLib.source_remove(self.source_id2)
        try:
            run_async_time(self)
        except:
            print(&#34;Exception in async handler&#34;, sys.exc_info())

    def locate(self, xstr):
        #print( &#34;locate &#39;&#34; + xstr +&#34;&#39;&#34;)
        cnt = 0; cnt2 = 0; idx = 0; found = 0
        for line in self.text:
            if xstr == line:
                self.gotoxy(idx, cnt, len(xstr), True)
                found = 1
                break
            cnt += 1
        if not found:
            xstr2 = xstr.lstrip().replace(&#34;\t&#34;, &#34; &#34;)
            for line2 in self.text:
                idx2 = line2.find(xstr2)
                if idx2 &gt;= 0:
                    self.gotoxy(idx2, cnt2, len(xstr2), True)
                    break
                cnt2 += 1

    def focus_out_cb(self, widget, event):
        #print( &#34;focus_out_cb&#34;, widget, event)
        self.focus = False

    def focus_in_cb(self, widget, event):
        #print (&#34;focus_in_cb&#34;)
        self.focus = True

        try:
            os.chdir(os.path.dirname(self.fname))
            xstat = os.stat(self.fname)
            if not self.readonly:
                #print(self.fname, &#34;stat&#34;, self.stat.st_mtime, &#34;xstat&#34;, xstat.st_mtime)
                if self.stat.st_mtime !=  xstat.st_mtime:
                    rrr = pedync.yes_no_cancel(&#34;File changed outside PyEdPro&#34;,
                        &#34;&#39;%s&#39;\n&#34; \
                        &#34;changed outside PyEdPro.&#34; \
                        &#34;Reload?&#34; % self.fname, False)
                    if rrr == Gtk.ResponseType.YES:
                        print(&#34;Reloading&#34;)
                        self.savebackup()
                        self.loadfile(self.fname)

            # Update stat info
            self.stat = xstat
        except:
            #pedutil.put_exception(&#34;cmp mtime&#34;)
            pass

        self.update_bar2()
        self.needscan = True
        self.do_chores()

    def grab_focus_cb(self, widget):
        #print( &#34;grab_focus_cb&#34;, widget)
        pass

    def area_enter(self, widget, event):
        #print( &#34;area_enter&#34;)
        pass

    def area_leave(self, widget, event):
        #print( &#34;area_leave&#34;)
        pass

    def scroll_event(self, widget, event):
        #print( &#34;scroll_event&#34;, event, event.direction)
        xidx = self.xpos + self.caret[0]
        yidx = self.ypos + self.caret[1]
        if event.direction == Gdk.ScrollDirection.SMOOTH:
            flag, directx, directy = event.get_scroll_deltas()
            if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
                yidx += 10 * int(directy)
            elif event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                yidx += 5 * int(directy)
            else:
                yidx += int(directy)
        else:
            #print( &#34;type&#34;, type(event.type))
            #print(&#34;truth&#34;, isinstance(event.type, Gdk.EventType))
            if event.direction == Gdk.ScrollDirection.UP:
                yidx -= int(self.pgup / 2)
            else:
                yidx += int(self.pgup / 2)

        self.set_caret(xidx, yidx)
        self.invalidate()

    def hscroll_cb(self, widget):
        #print( &#34;hscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.honeshot:
            self.honeshot = False; return
        xidx = int(widget.get_value())

        #print( &#34;hscroll_cb ok&#34;, widget.get_value())
        self.set_caret(xidx, self.ypos + self.caret[1])
        self.invalidate()


        #print( &#34;vscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.oneshot:
            self.oneshot = False; return
        #print( &#34;vscroll_cb ok&#34;, widget.get_value())
        yidx = int(widget.get_value())
        self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
        self.invalidate()

    def vscroll_cb(self, widget):
        #print( &#34;vscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.oneshot:
            self.oneshot = False; return
        #print( &#34;vscroll_cb ok&#34;, widget.get_value())
        yidx = int(widget.get_value())
        self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
        self.invalidate()

    def size_request(self, widget, req):
        #print( &#34;size_request&#34;, req)
        pass

    def size_alloc(self, widget, req):
        #print( &#34;size_alloc&#34;, req)
        pass

    def configure_event(self, widget, event):
        #print( &#34;configure_event&#34;, event)
        #self.grab_focus()
        #self.width = 0; self.height = 0
        #self.invalidate()
        #print( self, event)
        pass

    def draw_event(self, pdoc, cr):

        self.hhh = self.get_height();  self.www = self.get_width()
        self.xlen = len(self.text)

        ctx = self.get_style_context()
        fg_color = ctx.get_color(Gtk.StateFlags.NORMAL)
        #bg_color = ctx.get_background_color(Gtk..NORMAL)

        # Paint white, ignore system BG
        #cr.set_source_rgba(255, 255, 255)
        # Paint prescribed color
        if self.readonly:
            # Slightly darker / lighter
            newcol =  list(self.bgcolor)
            for aa in range(len(newcol)):
                if newcol[aa] &gt; 0.5: newcol[aa] -= .1
                else: newcol[aa] += .2
            cr.set_source_rgba(*list(newcol))
        else:
            cr.set_source_rgba(*list(self.bgcolor))

        cr.rectangle( 0, 0, self.www, self.hhh)
        cr.fill()

        # Pre set for drawing
        #cr.set_source_rgba(*list(fg_color))
        # Paint prescribed color
        cr.set_source_rgba(*list(self.fgcolor))

        cr.move_to(0, 0)
        self.layout = PangoCairo.create_layout(cr)
        self.layout.set_font_description(self.fd)

        self.draw_maintext(cr)

        if not self.hex:
            # Do the text drawing in stages ...
            self.draw_selection(cr)
            self.draw_syntax(cr)
            self.draw_clsyntax(cr)
            self.draw_comments(cr)
            self.draw_spellerr(cr)

        if self.startxxx != -1:
            self.gotoxy(self.startxxx, self.startyyy)
            self.startxxx = -1; self.startyyy = -1

        self.draw_caret(cr)

    def idle_queue(func):
        self.queue.append(func)
        #print( queue)

    def area_button(self, area, event):

        self.lastevent = event

        if pedconfig.conf.pgdebug &gt; 5:
            print( &#34;Button press  &#34;, event.type, &#34; x=&#34;, event.x, &#34; y=&#34;, event.y)

        event.x = int(event.x)
        event.y = int(event.y)

        if  event.type == Gdk.EventType.BUTTON_PRESS:
            if event.button == 1:
                #print( &#34;Left Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
                self.mx = int(event.x); self.my = int(event.y)
                xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
                # Find current pos, gather tabs, adjust back
                try:
                    line = self.text[self.ypos + yyy]
                except:
                    line = &#34;&#34;
                offs = calc_tabs2(line, xxx)

                #print( &#34;offs, xxx&#34;, offs, xxx)
                self.set_caret(self.xpos + xxx - (offs - xxx),
                                     self.ypos + yyy )
                #rp = xxx + self.xpos
                #print( &#34;xpos&#34;, self.xpos, &#34;xxx&#34;, xxx, &#34;rp&#34;, rp)
                #print( line)
                #print( &#34;line part&#34;, &#34;&#39;&#34; + line[rp:rp+8] + &#34;&#39;&#34;)

                # Erase selection
                if self.xsel != -1:
                    self.clearsel()

                self.fired += 1
                GLib.timeout_add(300, self.keytime)

            if event.button == 3:
                #print( &#34;Right Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
                flag = False; xx = 0; yy = 0; zz = 0
                if self.spell:
                    yyy = int(self.ypos + self.get_height() / self.cyy)
                    for xaa, ybb, lcc in self.ularr:
                        # Look within visible range
                        if ybb &gt;= self.ypos and ybb &lt; yyy:
                            ybb -= self.ypos
                            xaa -= self.xpos; lcc -= self.xpos
                            xaa *= self.cxx ; ybb *= self.cyy
                            lcc *= self.cxx
                            yy2 = ybb + self.cyy

                            if self.intersect(xaa, ybb, lcc, yy2, event):
                                xx = int(xaa / self.cxx + self.xpos)
                                yy = int(ybb / self.cyy + self.ypos)
                                zz = int(lcc / self.cxx + self.xpos)
                                flag = True
                if flag:
                    line = self.text[yy]
                    #print( &#34;Spell delimit: &#39;&#34; + line[xx:zz] + &#34;&#39;&#34;)
                    self.xsel = xx;
                    self.xsel2 = zz

                    self.ysel = self.ysel2 = yy
                    self.spellstr = line[int(xx):int(zz)]
                    self.popspell(area, event, self.spellstr)
                else:
                    if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                        if self.xsel == -1:
                            yyy = int(event.y / self.cyy + self.ypos)
                            xxx = int(event.x / self.cxx + self.xpos)
                            line = self.text[yyy]
                            self.xsel, self.xsel2 = selasci2(line, xxx, &#34;_-&#34;)
                            self.ysel = self.ysel2 = yyy
                        else:
                            line = self.text[self.ysel]

                        strx = line[int(self.xsel):int(self.xsel2)]
                        #print(&#34;&#39;&#34; + strx + &#34;&#39;&#34;)
                        if strx:
                            self.poprclick2(area, event, strx)
                    else:
                        self.poprclick(area, event)

        elif  event.type == Gdk.EventType.BUTTON_RELEASE:
            #print( &#34;button release&#34;, event.button)
            self.mx = -1; self.my = -1
            self.scrtab = False
            ttt = &#34;Release&#34;
            xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;
            offs = calc_tabs2(line, xxx)
            self.set_caret(self.xpos + xxx - (offs - xxx),
                                     self.ypos + yyy )

        elif  event.type == Gdk.EventType._2BUTTON_PRESS:

            if pedconfig.conf.pgdebug &gt; 2:
                print (&#34;Double click %.2f %.2f&#34; % (event.x, event.y))

            self.mx = int(event.x); self.my = int(event.y)
            xxx = int(event.x / self.cxx)
            yyy = int(event.y / self.cyy)

            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;

            # Find current pos on tabbed line
            offs = calc_tabs2(line, xxx)
            self.set_caret(self.xpos + xxx - (offs - xxx), self.ypos + yyy )
            #self.set_caret(len(xxx2), yyy)

            # Erase selection
            if self.xsel != -1:
                self.clearsel()

            # Select word
            if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
                pedconfig.conf.keyh.acth.ctrl_b(self)
            else:
                pedconfig.conf.keyh.acth.alt_v(self)
            # Copy to clip

            if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                pedconfig.conf.keyh.acth.ctrl_c(self)

        else:
            print(&#34;Unexpected mouse op.&#34;)

        self.grab_focus()
        return True

    # See if point in rect
    def intersect(self, xx, yy, xx2, yy2, event):
        # Does X intersect?
        if event.x &gt; xx and event.x &lt; xx2:
            #print( &#34;x inter&#34;, xaa, lcc)
            # Does Y intersect?
            if event.y &gt; yy and event.y &lt; yy2:
                return True
        return False

    # Normalize
    def normsel(self):
        xssel = min(self.xsel, self.xsel2)
        xesel = max(self.xsel, self.xsel2)
        yssel = min(self.ysel, self.ysel2)
        yesel = max(self.ysel, self.ysel2)

        self.xsel  = xssel;  self.ysel  = yssel
        self.xsel2 = xesel;  self.ysel2 = yesel

    def pix2xpos(self, xx):
        return int(self.xpos + xx / self.cxx)

    def pix2ypos(self, yy):
        return int(self.ypos + yy / self.cyy)

    def pix2pos(self, xx, yy):
        return int(self.xpos + xx / self.cxx), int(self.ypos + yy / self.cyy)

    def area_motion(self, area, event):
        #print (&#34;motion event&#34;, event.state, event.x, event.y)
        if event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
            #print( &#34;motion event butt 1&#34;, event.state, event.x, event.y)
            if self.xsel == -1 and self.scrtab != True:
                begsel = False
                # Horiz drag - regular sel
                if abs(event.x - self.mx) &gt; DRAGTRESH:
                    self.colsel = False; begsel = True

                if begsel:
                    self.xsel = self.xsel2 = self.xpos + self.caret[0]
                    self.ysel = self.ysel2 = self.ypos + self.caret[1]
                    #print( &#34;colsel xsel, ysel&#34;, self.colsel, self.xsel, self.ysel)
                if self.scrtab == False:
                    # Vert drag - colsel
                    if abs(event.y - self.my) &gt; DRAGTRESH:
                        self.scrtab  = True
                        self.colsel = True

            if self.scrtab  == True:
                self.xsel = self.xsel2 = self.xpos + self.caret[0]
                self.ysel = self.ysel2 = self.ypos + self.caret[1]
                xidx = self.xpos + self.caret[0]
                yidx = self.ypos + self.caret[1]
                if  event.y &gt;  self.my:
                    yidx += 1
                if  event.y &gt;  self.my:
                    yidx -= 1
                self.set_caret(xidx, yidx)
                self.my = event.y

            if self.xsel != -1:
                # Already selected, mark
                self.ysel2 = self.pix2ypos(event.y)
                if self.ysel2 &lt; self.ysel:
                    self.xsel    = self.pix2xpos(event.x)
                else:
                    self.xsel2 = self.pix2xpos(event.x)

            self.invalidate()

        if event.state &amp; Gdk.ModifierType.SHIFT_MASK and \
            event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
            #print( &#34;Shift Drag&#34;, event.x, event.y)
            pass
        pass

    def gotoxy(self, xx, yy, sel = None, mid = False):

        #print (&#34;gotoxy&#34;, xx, yy)

        # Contain
        ylen = len(self.text)
        xx2 = max(xx, 0);  yy2 = max(yy, 0)
        xx2 = min(xx, self.maxlinelen);  yy2 = min(yy, ylen)

        if sel:
            self.xsel = xx2; self.xsel2 = xx2 + sel
            self.ysel = yy2; self.ysel2 = yy2
            self.invalidate()

        if mid:
            self.set_caret_middle(xx, yy)
        else:
            self.set_caret(xx, yy)

        self.invalidate()

    # --------------------------------------------------------------------
    # Goto position, and place it to upper half / quarter

    def set_caret_middle(self, xx, yy, sel = None, quart = 2):

        xx = int(xx); yy = int(yy)

        # Needs scroll?
        #xxx, yyy = self.get_size()
        xlen = len(self.text)

        # Put it back in view:
        off = (self.get_height() / self.cyy) / quart
        if yy &gt; off:
            self.ypos = int(yy - off)
        else:
            self.ypos = 0

        self.set_caret(xx, yy)
        self.invalidate()

    # Dimenswions in character cell
    def get_height_char(self):
        return self.get_height()  / self.cyy

    def get_width_char(self):
        return self.get_width() / self.cxx

    # --------------------------------------------------------------------
    # Goto position, put caret (cursor) back to view, [vh]scrap
    # distance from ends. This function was a difficult to write. :-{
    # Note the trick with comparing old cursor pos for a hint on scroll
    # direction.
    # xx, yy - absolute position in the text buffer

    def set_caret(self, xx, yy):

        #print( &#34;set_caret&#34;, xx, yy)
        xx = int(xx); yy = int(yy)

        # Needs scroll?
        need_inval = False
        cww = self.get_width_char()
        chh = self.get_height_char()
        xlen = len(self.text)

        # ----------------------------------------------------------------
        # Put it back in view yyy:

        off = chh - self.vscgap
        if yy - self.ypos &gt; off:
            #print( &#34;Scroll from caret down&#34;)
            if yy &gt; self.ypos + self.caret[1]:
                #print( &#34;move d&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
                self.ypos = int(yy - off)
                need_inval = True
                # Force new spell check
                self.fired += 1
                #goject.timeout_add(
                GLib.timeout_add(300, self.keytime)

        if yy - self.ypos &lt; self.vscgap and self.ypos:
            #print( &#34;Scroll from caret up&#34;)
            if yy &lt; self.ypos + self.caret[1]:
                #print( &#34;move u&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
                self.ypos = int(yy - self.vscgap)
                self.ypos = int(max(self.ypos, 0))
                need_inval = True
                # Force new spell check
                self.fired += 1
                GLib.timeout_add(300, self.keytime)

        yy -= self.ypos
        if self.ypos &lt; 0: self.ypos = 0

        # ----------------------------------------------------------------
        # Put it back in view xxx:

        xoff = cww - self.hscgap
        if  xx - self.xpos  &gt; xoff:
            #print( &#34;Scroll from caret right&#34;, &#34;xx&#34;, xx, &#34;xpos&#34;, self.xpos)
            if self.xpos + self.caret[0] &lt; xx:
                #print( &#34;moved r&#34;,  xx, self.caret[0], self.xpos)
                self.xpos =  int(xx - xoff)
                self.xpos = int(max(self.xpos, 0))
                need_inval = True

        if  xx - self.xpos &lt;  self.hscgap:
            #print( &#34;Scroll from caret left &#34;, xx, self.xpos)
            if self.xpos + self.caret[0] &gt; xx:
                #print( &#34;moved l&#34;, &#34;xx&#34;, xx, &#34;caret&#34;, self.caret[0], &#34;xpos&#34;, self.xpos)
                self.xpos = int(xx - self.hscgap)
                self.xpos = int(max(self.xpos, 0))
                need_inval = True

        xx -= self.xpos
        if self.xpos &lt; 0: self.xpos = 0

        oldx = self.caret[0] * self.cxx
        oldy = self.caret[1] * self.cyy

        # Cheat - invalidate all if tab is involved at old line
        try:
            line = self.text[oldy]
        except:
            line = &#34;&#34;; need_inval = True
        if line.find(&#34;\t&#34;) &gt;= 0:
            need_inval = True

        self.caret[0] = xx; self.caret[1] = yy

        # Low limit
        if self.caret[0] &lt; 0: self.caret[0] = 0
        if self.caret[1] &lt; 0: self.caret[1] = 0

        wxx = self.caret[0] * self.cxx
        wyy = self.caret[1] * self.cyy

        # Cheat - invalidate all if tab is involoved
        try:
            line = self.text[self.ypos + self.caret[1]]
        except:
            line = &#34;&#34;; need_inval = True
        if line.find(&#34;\t&#34;) &gt;= 0:
            need_inval = True

        # Optimize cursor movement invalidation
        &#39;&#39;&#39;if  not need_inval :
            rect = Gdk.Rectangle(wxx, wyy, self.cxx * self.cxx /2, self.cyy + 1)
            self.invalidate(rect)

            rect = Gdk.Rectangle(oldx, oldy, self.cxx + self.cxx /2 , self.cyy + 1)
            self.invalidate(rect)
        &#39;&#39;&#39;
        self.invalidate(None)

        # Update scroll bars, prevent them from sending scroll message:
        self.oneshot = True; self.vscroll.set_value(self.ypos)
        self.honeshot = True; self.hscroll.set_value(self.xpos)

        self.update_bar2()

        if  need_inval or self.bigcaret:
            self.invalidate()

    def update_bar2(self):
        clip = pedconfig.conf.keyh.acth.currclip
        self.mained.update_statusbar2(self.caret[0] + self.xpos, \
                self.caret[1] + self.ypos, self.insert, len(self.text), clip, self.caps, self.scr)

    def clearsel(self):
        old = self.xsel
        self.xsel  =  self.ysel = -1
        self.xsel2 =  self.ysel2 = -1
        if old != -1:
            self.invalidate()

    def keytime(self):
        #print( &#34;keytime raw&#34;, time.time(), self.fired)
        if self.fired ==  1:
            #print( &#34;keytime&#34;, time.time(), self.fired)
            pedspell.spell(self, self.spellmode)
            self.walk_func()
        self.fired -= 1

        # Track this buffer
        if self.diffmode == 2:
            self.mained.diffpane.area.xpos = self.xpos
            self.mained.diffpane.area.ypos = self.ypos
            self.mained.diffpane.area.set_caret(self.xpos + self.caret[0],
                                                        self.ypos + self.caret[1])

    def walk_func(self):
        #print( &#34;walk func&#34;)
        # ts2 ---------------------------------------------------
        sumw2 = []
        if self.text:
            sline = self.caret[1] + int(self.ypos)
            sline = max(sline, 0); sline = min(sline, len(self.text))
            #print( &#34;Start point&#34;, sline, self.text[sline])
            # Walk back to last function
            if &#34;.c&#34; in self.fname or &#34;.h&#34; in self.fname or &#34;.php&#34; in self.fname:
                try:
                    aa = 0; bb = 0
                    regex = re.compile(ckeywords)
                    for aa in range(sline - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break
                    if aa &gt; 0:
                        for bb in range(aa + 1, len(self.text)):
                            line = self.text[bb]
                            res = regex.search(line)
                            if res:
                                #print( &#34;end&#34;, line, res.start(), res.end())
                                break

                        regex2 = re.compile(localkwords)
                        for cc in range(aa + 1, bb - 1):
                            line = self.text[cc]
                            res = regex2.search(line)
                            if res:
                                #print( &#34;match&#34;, line, res.start(), res.end())
                                sumw2.append(line)

                except:
                    print(&#34;Exception in c func handler&#34;, sys.exc_info())
                    pass
            if &#34;.bas&#34; in self.fname.lower():
                try:
                    regex = re.compile(basekeywords)
                    for line in win.text:
                        res = regex.search(line)
                        if res:
                            #print( res, res.start(), res.end())
                            sumw.append(line)
                except:
                    print(&#34;Exception in bas func extraction handler&#34;, sys.exc_info())
                    pass
            if &#34;.py&#34; in self.fname.lower():
                try:
                    aa = 0; bb = 0
                    regex = re.compile(&#34;class&#34;)
                    for aa in range(int(sline) - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break

                    regex = re.compile(pykeywords2)
                    for aa in range(int(sline) - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break

                    if aa &gt; 0:
                        for bb in range(aa + 1, len(self.text)):
                            line = self.text[bb]
                            res = regex.search(line)
                            if res:
                                #print( &#34;end&#34;, line, res.start(), res.end())
                                break

                        regex2 = re.compile(localpywords)
                        for cc in range(aa + 1, bb - 1):
                            line = self.text[cc]
                            res = regex2.search(line)
                            if res:
                                #print( &#34;match&#34;, line, res.start(), res.end())
                                sumw2.append(line)

                except:
                    print(&#34;Exception in py func handler&#34;, sys.exc_info())
                    raise
                    pass
            else:
                pass

            # Always show todo
            got_todo = 0
            for line in self.text:
                if &#34;TODO&#34; in line:
                    if not got_todo:
                        got_todo = 1
                        sumw2.append(&#34;----------- TODO List ----------&#34;)
                    sumw2.append(line)

        try:
            self.mained.update_treestore2(sumw2)
        except:
            # This is normal, ignore it
            print(&#34;walk2&#34;, sys.exc_info())
            pass

    # Call key handler
    def area_key(self, area, event):

        #print (&#34;area_key&#34;, event)
        # Restart timer ticks
        pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
        pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

        # Maintain a count of events, only fire only fire on the last one
        self.fired += 1
        GLib.timeout_add(300, self.keytime)
        # The actual key handler
        self.keyh.handle_key(self, area, event)

        #if event.type == Gdk.KEY_RELEASE:
        #    self.source_id = GObject.idle_add(self.idle_callback)

        # We handled it
        return True

     # Invalidate current line
    def inval_line(self):
        rect = Gdk.Rectangle()
        xx = self.caret[0] * self.cxx
        yy = self.caret[1] * self.cyy
        ww = self.get_width()
        hh = self.cyy
        #self.invalidate(rect)
        xx = 0
        self.queue_draw_area(xx, yy, ww, hh)

    def invalidate(self, rect = None):
        #print( &#34;Invalidate:&#34;, rect)
        if rect == None:
            self.queue_draw()
        else:
            self.queue_draw_area(rect.x, rect.y,
                            rect.width, rect.height)

    def area_focus(self, area, event):
        #print( &#34;ped doc area focus&#34;, event)
        return False

    # Add to user dictionary:
    def addict(self, widget, string, arg):
        #print( &#34;addict&#34;, arg)
        if not pedspell.append_user_dict(self, arg):
            self.mained.update_statusbar(&#34;Cannot append to user dict&#34;)
        else:
            self.mained.update_statusbar(&#34;Added &#39;%s&#39; to user dict&#34; % arg)
            self.newword = True

        # Force new spell check
        self.fired += 1
        GLib.timeout_add(300, self.keytime)

    def popspell(self, widget, event, xstr):
        # Create a new menu-item with a name...
        self.menu2 = Gtk.Menu()
        self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % xstr, None))
        self.menu2.append(self.create_menuitem(&#34;Add to Dict&#34;, self.addict, xstr))

        mi = self.create_menuitem(&#34;-------------&#34;, None)
        mi.set_sensitive(False)
        self.menu2.append(mi)

        strs = &#34;Creating suggestion list for &#39;{0:s}&#39;&#34;.format(self.spellstr)
        self.mained.update_statusbar(strs)
        arr = pedspell.suggest(self, xstr)

        if len(arr) == 0:
            self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
        else:
            for aa, bb in arr:
                self.menu2.append(self.create_menuitem(bb, self.menuitem_response))

        self.menu2.popup(None, None, None, None, event.button, event.time)
        #self.mained.update_statusbar(&#34;Done menu popup.&#34;)

    def set_diffs(self, arg1, arg2, arg3):
        # reset all
        if arg3 == 0:
            nn = self.notebook.get_n_pages(); cnt = 0
            while True:
                if cnt &gt;= nn: break
                ppp = self.notebook.get_nth_page(cnt)
                ppp.area.diffmode = 0
                ppp.area.set_tablabel()
                cnt += 1
            www = self.mained.get_width()
            self.mained.hpaned3.set_position(www - 10)

        else:
            self.diffmode = arg3
            self.set_tablabel()

            got_src = 0; got_targ = 0; action_page = 0;
            src = &#34;&#34;; targ = &#34;&#34;
            srctxt = [] ;  targtxt = []
            action_tab = None

            # See if diff complete, put it in motion
            nn = self.notebook.get_n_pages(); cnt = 0
            while True:
                if cnt &gt;= nn: break
                ppp = self.notebook.get_nth_page(cnt)
                #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
                if ppp.area.diffmode == 1:
                    got_src = True
                    src = os.path.basename(ppp.area.fname)
                    srctxt = ppp.area.text

                if ppp.area.diffmode == 2:
                    got_targ = True
                    targ = os.path.basename(ppp.area.fname)
                    targtxt = ppp.area.text
                    action_page = cnt
                    action_tab = ppp

                if ppp.area.diffmode == 1:
                    got_src = True
                cnt += 1

            if got_src and got_targ:
                www = self.mained.get_width()
                if self.mained.hpaned3.get_position() &gt; www - 20:
                    self.mained.hpaned3.set_position(www - www / 3)

                self.mained.update_statusbar(    \
                            &#34;Diff started.  Source: &#39;%s&#39; Target: &#39;%s&#39;&#34; % (src, targ))

                self.notebook.set_current_page(action_page)
                action_tab.area.diffx(srctxt, targtxt)

    def diffx(self, srctxt, targtxt):

        #self.mained.diffpane.area.text.append(&#34;Diff started.&#34;)

        for aa in range(len(targtxt)):
            if srctxt[aa] == targtxt[aa]:
                self.mained.diffpane.area.text.append(targtxt[aa])
            else:
                self.mained.diffpane.area.text.append(&#34; --- &#34;)

        self.mained.diffpane.area.xpos = self.xpos
        self.mained.diffpane.area.ypos = self.ypos
        self.mained.diffpane.area.gotoxy(
                         self.xpos + self.caret[0], self.ypos + self.caret[1])
        self.mained.diffpane.area.invalidate()


    def iterdocs(self, callb, arg):
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            callb(ppp.area, arg)
            cnt += 1

    def builddoc(self, ppp):
        if ppp.area.diffmode == 1:
            got_src = True
        if ppp.area.diffmode == 2:
            got_targ = True

    def poprclick3(self, event):
        #print (&#34;Making shift rclick3&#34;)
        got_src = 0; got_targ = 0

        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
            if ppp.area.diffmode == 2:
                got_targ = True
            cnt += 1

        # Check if there is any:
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
            if ppp.area.diffmode == 2:
                got_targ = True
            cnt += 1

        self.menu3 = Gtk.Menu()
        if not got_src:
            self.menu3.append(self.create_menuitem(&#34;Set as Diff Source&#34;, self.set_diffs, 1))
        if not got_targ:
            self.menu3.append(self.create_menuitem(&#34;Set as Diff Target&#34;, self.set_diffs, 2))

        self.menu3.append(self.create_menuitem(&#34;Unset (stop) Diff&#34;,  self.set_diffs, 0))
        self.menu3.popup(None, None, None, None, event.button, event.time)

    def poprclick2(self, widget, event, strx):
        #print (&#34;Making shift rclick2&#34;)
        self.menu2 = Gtk.Menu()
        self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % strx, None))
        mi = self.create_menuitem(&#34;-------------&#34;, None)
        mi.set_sensitive(False)
        self.menu2.append(mi)
        strs = &#34;Creating class list for &#39;{0:s}&#39;&#34;.format(strx)
        self.mained.update_statusbar(strs)
        arr = pedstruct.suggest(self, strx)
        if len(arr) == 0:
            self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
        else:
            for bb in arr:
                self.menu2.append(self.create_menuitem(bb, self.menuitem_response2))

        self.menu2.popup(None, None, None, None, event.button, event.time)

    def poprclick(self, widget, event):
        #print (&#34;Making rclick&#34;)
        self.build_menu(self, pedmenu.rclick_menu)
        if event:
            self.menu.popup(None, None, None, None, event.button, event.time)
        else:
            event = Gdk.EventButton()
            self.menu.popup(None, None, None, None, event.button, event.time)

    def menuitem_response2(self, widget, stringx, arg):
        #print( &#34;menuitem response2 &#39;%s&#39;&#34; % stringx)
        #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)
        disp2 = Gdk.Display()
        disp = disp2.get_default()
        clip = Gtk.Clipboard.get_default(disp)
        stringx = stringx.strip()
        clip.set_text(stringx, len(stringx))
        strs = &#34;Copied to clipboard &#39;{0:s}&#39;&#34;.format(stringx)
        self.mained.update_statusbar(strs)

    def menuitem_response(self, widget, stringx, arg):
        #print( &#34;menuitem response &#39;%s&#39;&#34; % stringx)
        #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)

        # See if Capitalized or UPPERCASE :
        if self.spellstr[0] in string.ascii_uppercase:
            stringx = stringx.capitalize()

        if self.spellstr.isupper():
            stringx = stringx.upper()

        pedconfig.conf.keyh.acth.clip_cb(None, stringx, self, False)

        self.fired += 1
        GLib.timeout_add(300, self.keytime)

    def activate_action(self, action):
        dialog = Gtk.MessageDialog(self, Gtk.DIALOG_DESTROY_WITH_PARENT,
            Gtk.ButtonsType.INFO, Gtk.ButtonsType.CLOSE,
            &#39;You activated action: &#34;%s&#34; of type &#34;%s&#34;&#39; % (action.get_name(), type(action)))
        # Close dialog on user response
        dialog.connect (&#34;response&#34;, lambda d, r: d.destroy())
        dialog.show()

    def rclick_action(self, action, sss, ttt):
        #print( &#34;rclck_action&#34;, sss, ttt)
        if ttt == 1:
            self.mained.newfile()
        elif ttt == 3:
            self.mained.open()
        elif ttt == 4:
            self.mained.save()
        elif ttt == 5:
            self.mained.save(True)
        elif ttt == 7:
            self.mained.copy()
        elif ttt == 8:
            self.mained.cut()
        elif ttt == 9:
            self.mained.paste()
        elif ttt == 11:
            self.toggle_ro()
        elif ttt == 13:
            self.mained.activate_exit()
        elif ttt == 14:
            self.start_term()
        elif ttt == 15:
            self.start_edit()
        elif ttt == 16:
            self.mained.tts()
        elif ttt == 17:
            pedmisc.exec_test(self, &#34;rc&#34;)
        elif ttt == 18:
            self.start_external([&#34;libreoffice&#34;, &#34;--writer&#34;],
                                        [&#34;libreoffice&#34;, &#34;--writer&#34;])
        else:
            print(&#34;peddoc: Invalid menu item selected&#34;)

    def toggle_ro(self):
        self.readonly = not self.readonly
        self.set_tablabel()
        arrx = [&#34;OFF&#34;, &#34;ON&#34;]
        self.mained.update_statusbar(&#34;Toggled read only to %s&#34; % arrx[self.readonly])

    def start_term(self):
        #print(&#34;Terminal Here&#34;)
        try:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                ret = subprocess.Popen([&#34;putty&#34;])
                #if not ret.returncode:
                #    raise OSError
                #print(&#34;No terminal on windows. (TODO)&#34;)
            else:
                # Stumble until terminal found
                ret = subprocess.Popen([&#34;xfce4-terminal&#34;])
                if ret.returncode:
                    ret = subprocess.Popen([&#34;gnome-terminal&#34;])
                    if ret.returncode:
                        raise OSError
        except:
            print(&#34;Cannot launch terminal&#34;, sys.exc_info())
            pedync.message(&#34;\n   Cannot launch terminal executable \n\n&#34;
                       &#34;              (Please install)&#34;)


    # Pass in two lists, one for linux and one for windows
    def start_external(self, linprog, winprog):

        try:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                ret = subprocess.Popen(winprog)
                #if not ret.returncode:
                #    raise OSError
            else:
                ret = subprocess.Popen(linprog)
                #if not ret.returncode:
                #    raise OSError
        except:
            print(&#34;Cannot launch %s&#34; % str(linprog), sys.exc_info())
            pedync.message(&#34;\n   Cannot launch %s \n\n&#34;  % str(linprog) +
                       &#34;              (Please install)&#34;)

    def start_edit(self):

        old = os.getcwd()
        fdir = os.path.dirname(os.path.realpath(__file__))
        #print(&#34;fdir:&#34;, fdir)
        mydir = os.path.dirname(os.path.join(fdir, &#34;../&#34;))
        #print(&#34;mydir:&#34;, mydir)
        os.chdir(mydir)
        myscript = os.path.realpath(os.path.join(mydir, &#39;pyedpro.py&#39;))
        #print(&#34;myscript:&#34;, myscript)

        ret = 0
        try:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                print(&#34;No exe function on windows. (TODO)&#34;)
            else:
                # Stumble until editor found
                ret = subprocess.Popen([&#34;python3&#34;, myscript])
                if ret.returncode:
                    ret = subprocess.Popen([&#34;python&#34;, myscript])
                    if not ret.returncode:
                        raise OSError
        except:
            print(&#34;Cannot launch editor instance&#34;, sys.exc_info())
            pedync.message(&#34;\n   Cannot launch new editor instance \n\n&#34;)

        # Back to original dir
        os.chdir(os.path.dirname(old))

    def create_menuitem(self, string, action, arg = None):
        rclick_menu = Gtk.MenuItem(string)
        if action:
            rclick_menu.connect(&#34;activate&#34;, action, string, arg)
        rclick_menu.show()
        return rclick_menu

        # Create the menubar and toolbar
        action_group = Gtk.ActionGroup(&#34;DocWindowActions&#34;)
        action_group.add_actions(entries)
        return action_group

    def build_menu(self, window, items):

        self.menu =  Gtk.Menu()
        for aa, bb, cc, dd, ee  in items:
            #print (&#34;menu item&#34;, aa)
            if ee:
                menu_item = Gtk.MenuItem.new_with_mnemonic(
                            &#34;----------------------------&#34;)
                menu_item.set_sensitive(False)
                menu_item.set_size_request(-1, 10)
                pass
            else:
                ttt = str(bb).replace(&#34;&lt;control&gt;&#34;, &#34;CTRL+&#34;)
                ttt = str(ttt).replace(&#34;&lt;alt&gt;&#34;,     &#34;ALT+&#34;)
                ttt = str(ttt).replace(&#34;&lt;shift&gt;&#34;,   &#34;SHIFT+&#34;)
                fff = &#34; &#34; * (15 - len(aa))
                sss = aa + &#34;%s\t%s&#34; % (fff, ttt)
                menu_item = Gtk.MenuItem.new_with_mnemonic(sss)
                menu_item.connect(&#34;activate&#34;, self.rclick_action, aa, dd )

            self.menu.append(menu_item)
        self.menu.show_all()
        return self.menu

    def get_size(self):
        rect = self.get_allocation()
        return rect.width, rect.height

    def get_height(self):
        rect = self.get_allocation()
        return rect.height

    def get_width(self):
        rect = self.get_allocation()
        return rect.width

    def save(self):

        #print (&#34;Saving&#34;, self.fname)
        # Always save params
        self.saveparms()
        strx = &#34;&#34;
        if not self.changed:
            strx = &#34;File is not modified.&#34;
            #self.mained.update_statusbar(strx)
            return

        # Is this file named &#39;untitled&#39;?
        base, ext =  os.path.splitext(pedconfig.conf.UNTITLED)
        base1 = os.path.basename(self.fname)
        base2, ext2 =  os.path.splitext(base1)
        if base2[:len(base)] == base:
            self.file_dlg(Gtk.ResponseType.YES)
        else:
            bn = os.path.basename(self.fname)
            err = self.writeout()
            if  err[0]:
                strx = &#34;Saved &#39;{0:s}&#39;&#34;.format(self.fname)
            else:
                #strx = &#34;Not Saved &#39;{0:s}&#39; {1:s}&#34;.format(bn, err[1])
                strx = &#34;Not Saved &#34;

        if pedconfig.conf.verbose:
            print(strx)
        self.mained.update_statusbar(strx)

    def saveas(self):
        self.file_dlg(Gtk.ResponseType.YES)

    def coloring(self, flag):
        self.colflag = flag
        self.invalidate()

    def showcol(self, flag):
        self.scol = flag
        self.invalidate()

    def hexview(self, flag):
        self.hex = flag
        self.invalidate()

    def flash(self, flag):
        self.bigcaret = flag
        self.invalidate()

    def showtab(self, flag):
        self.stab = flag
        self.scol = flag
        self.invalidate()

    def closedoc(self, noprompt = False):
        strx = &#34;Closing &#39;{0:s}&#39;&#34;.format(self.fname)
        if pedconfig.conf.verbose:
            print(&#34;Closing doc:&#34;, strx)
        self.mained.update_statusbar(strx)
        self.saveparms()

        # Clear treestore(s)
        self.mained.update_treestore([])
        self.mained.update_treestore2([])

        # Add to accounting:
        logentry(&#34;Closed File&#34;, self.start_time, self.fname)

        return self.prompt_save(noprompt)

    # --------------------------------------------------------------------
    # Load file into this buffer, return False on failure

    def loadfile(self, filename, create = False):
        self.fname = filename
        try:
            self.stat = os.stat(self.fname)
        except:
            pass

        #pedync.message(&#34;\n   open / read file:  \n\n&#34;
        #                      &#34;      %s&#34; % self.fname)

        #print(&#34;stat&#34;, self.stat.st_mtime)
        self.start_time = time.time()
        if self.fname == &#34;&#34;:
            strx = &#34;Must specify file name.&#34;
            print(strx)
            self.mained.update_statusbar(strx)
            return False
        try:
            self.text = readfile(self.fname)
        except:
            errr = &#34;Cannot read file &#39;&#34; + self.fname + &#34;&#39;&#34; #, sys.exc_info()
            if pedconfig.conf.verbose:
                print(errr, sys.exc_info())

            #pedync.message(&#34;\n   Cannot open / read file:  \n\n&#34;
            #                  &#34;      %s&#34; % self.fname)

            self.mained.update_statusbar(errr)
            usleep(10)
            return False

        #self.ularr.append((10 ,10, 20))
        mlen = self.calc_maxline()

        # Set up scroll bars
        self.set_maxlinelen(mlen, False)
        self.set_maxlines(len(self.text), False)

        self.loadundo()
        self.saveorg()
        self.savebackup()
        self.loadparms()

        # Add to accounting:
        logentry(&#34;Opened File&#34;, self.start_time, self.fname)

        # Propagate main wndow ref
        pedmenu.mained = self.mained

        self.set_nocol()

        try:
            os.chdir(os.path.dirname(self.fname))
        except:
            print(&#34;Cannot change dir to file&#39;s cwd&#34;, sys.exc_info())

        # Let the system breed
        self.invalidate()
        usleep(10)

        # Color ON?
        self.set_nocol()

        return True

    def calc_maxline(self):
        mlen = 0
        for aa in self.text:
            xlen = len(aa)
            if mlen &lt; xlen:
                mlen = xlen
        #self.maxlinelen = mlen
        return mlen

    # Load per file parms (cursor etc)
    def loadparms(self):
        hhh = hash_name(self.fname)

        self.startxxx  =  pedconfig.conf.sql.get_int(hhh + &#34;/xx&#34;)
        self.startyyy  =  pedconfig.conf.sql.get_int(hhh + &#34;/yy&#34;)
        #print(&#34;got cursor pos:&#34;, self.fname, self.startxxx, self.startyyy)
        # Note: we set cursor on first focus

    # Save per file parms (cursor, fname, etc)
    def  saveparms(self):
        hhh = hash_name(self.fname)
        pedconfig.conf.sql.put(hhh + &#34;/xx&#34;, self.xpos + self.caret[0])
        pedconfig.conf.sql.put(hhh + &#34;/yy&#34;, self.ypos + self.caret[1])
        pedconfig.conf.sql.put(hhh + &#34;/fname&#34;, self.fname)

        if self.tts:
            self.tts.haltspeak = True

        #print  &#34;saveparm&#34;, time.clock() - got_clock

    # Create org backup
    def saveorg(self):
        hhh = hash_name(self.fname) + &#34;.org&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        if not os.path.isfile(xfile):
            err =  writefile(xfile, self.text, &#34;\n&#34;)
            if not err[0]:
                print(&#34;Cannot create (org) backup file&#34;, xfile, sys.exc_info())

   # Create backup
    def savebackup(self):
        hhh = hash_name(self.fname) + &#34;.bak&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            writefile(xfile, self.text, &#34;\n&#34;)
        except:
            sss = &#34;Cannot create backup file&#34; + xfile + sys.exc_info()
            print(sss)

    def prompt_save(self, askname = True):

        # Always save params
        self.saveparms()

        if not self.changed:
            #print &#34;not changed&#34;, self.fname
            return False

        msg = &#34;\nWould you like to save:\n\n  \&#34;%s\&#34; \n&#34; % self.fname
        rp = pedync.yes_no_cancel(&#34;pyedpro: Save File ?&#34;, msg)

        if rp == Gtk.ResponseType.YES:
            if askname:
                self.file_dlg(rp)
            else:
                self.save()
        elif rp == Gtk.ResponseType.NO:
            pass
        elif  rp == Gtk.ResponseType.CANCEL:
            return True
        else:
            print(&#34;warning: invalid response from dialog&#34;)

    def file_dlg(self, resp):
        #print &#34;File dialog&#34;
        if resp == Gtk.ResponseType.YES:
            but =   &#34;Cancel&#34;, Gtk.ResponseType.CANCEL,   \
                            &#34;Save File&#34;, Gtk.ResponseType.OK
            fc = Gtk.FileChooserDialog(&#34;Save file as ... &#34;, None,
                    Gtk.FileChooserAction.SAVE, but)
            #fc.set_do_overwrite_confirmation(True)

            fc.set_current_name(os.path.basename(self.fname))
            fc.set_current_folder(os.path.dirname(self.fname))
            fc.set_default_response(Gtk.ResponseType.OK)
            fc.connect(&#34;response&#34;, self.done_fc)
            fc.run()

    # --------------------------------------------------------------------

    def writeout(self):

        if pedconfig.conf.verbose:
            print(&#34;Saving &#39;&#34;+ self.fname + &#34;&#39;&#34;)

        wasfile = os.access(self.fname, os.R_OK)
        err = writefile(self.fname, self.text, &#34;\n&#34;)
        if err[0]:
            self.set_changed(False)

        if not wasfile:
            # Change access/ownership to group write
            try:
                ostat = os.stat(self.fname)
                os.chmod(self.fname, ostat.st_mode | stat.S_IWGRP)
            except:
                print(&#34;Cannot change group write on &#39;%s&#39;&#34; % self.fname,  sys.exc_info())

        self.saveundo();  self.saveparms(); self.set_tablabel()

        # Add to accounting:
        logentry(&#34;Wrote File&#34;, self.start_time, self.fname)

        # Update stat info
        self.stat = os.stat(self.fname)

        return err

    def delundo(self):
        self.undoarr = []; self.redoarr = []
        # Remove file
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        fh = open(xfile, &#34;w&#34;)
        fh.close()
        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        fh = open(xfile, &#34;w&#34;)
        fh.close()

    def saveundo(self):
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;wb&#34;)
            pickle.dump(self.undoarr, fh)
            fh.close()
        except:
            print(&#34;Cannot save undo file&#34;, sys.exc_info())
            pedutil.put_exception(&#34;undo&#34;)


        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;wb&#34;)
            pickle.dump(self.redoarr, fh)
            fh.close()
        except:
            print(&#34;Cannot save redo file&#34;, sys.exc_info())

    def loadundo(self):
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;rb&#34;)
            try:
                self.undoarr = pickle.load(fh)
            except:
                pass
            fh.close()
        except:
            pass
            # Ignore it, not all files will have undo
            #print( &#34;Cannot load undo file&#34;, xfile)
        self.initial_undo_size = len(self.undoarr)

        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;rb&#34;)
            try:
                self.redoarr = pickle.load(fh)
            except:
                pass
            fh.close()
        except:
            pass
            # Ignore it, not all files will have redo
            #print( &#34;Cannot load redo file&#34;, xfile)
        self.initial_redo_size = len(self.redoarr)

    def done_fc(self, win, resp):
        #print( &#34;done_fc&#34;, win, resp)
        if resp == Gtk.ResponseType.OK:
            fname = win.get_filename()
            if not fname:
                print(&#34;Must have filename&#34;)
            else:
                if os.path.isfile(fname):
                    dialog = Gtk.MessageDialog(None, Gtk.DIALOG_DESTROY_WITH_PARENT,
                    Gtk.MESSAGE_QUESTION, Gtk.ButtonsType.YES_NO,
                    &#34;\nWould you like overwrite file:\n\n  \&#34;%s\&#34; \n&#34; % fname)
                    dialog.set_title(&#34;Overwrite file ?&#34;)
                    dialog.set_default_response(Gtk.ResponseType.YES)
                    dialog.connect(&#34;response&#34;, self.overwrite_done, fname, win)
                    dialog.run()
                else:
                    win.destroy()
                    self.fname = fname
                    self.writeout()

    def overwrite_done(self, win, resp, fname, win2):
        #print( &#34;overwrite done&#34;, resp)
        if resp == Gtk.ResponseType.YES:
            self.fname = fname
            self.writeout()
            self.set_nocol()
            win2.destroy()
        win.destroy()

    # --------------------------------------------------------------------
    # Turn off coloring if not python / c / sh / perl / header(s)

    def set_nocol(self):
        colflag = False
        ext = os.path.splitext(self.fname)[1].lower()
        for aa in pedconfig.conf.color_on:
            if ext == aa:
                colflag = True
                break
        self.colflag = colflag


    def do_chores(self):

        #print( &#34;do_chores&#34;)

        if  not self.needscan:
            return

        self.needscan = False

        # Scan left pane
        pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
        pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

    def set_changed(self, flag):
        old = self.changed
        self.changed = flag
        # Exec actions:
        if old != self.changed:
            #print( &#34;Setting changed on &#34;, self.fname)
            self.set_tablabel()

    def set_tablabel(self):
        # Find me in tabs
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            if ppp.area == self:
                self._setlabel(ppp)
                break
            cnt += 1

    # Gdk.EventButton
    def doclabel_callb(self, widg, event):
        #print(&#34;doclabel_callb&#34;, event.button, event.type)
        if event.button == 3:
            #print(&#34;Right click&#34;, self.fname)
            self.poprclick3(event)

    def _setlabel(self, ppp):
        # Set label to tab
        ss = shortenstr(os.path.basename(self.fname), 24)
        if  self.changed:
            str2 = &#34;* &#34; + ss + &#34;  &#34;
        else:
            str2 = &#34;&#34; + ss + &#34;  &#34;

        if  self.readonly:
            str3 = &#34;ro &#34; + str2
        else:
            str3 = &#34;&#34; + str2

        if  self.diffmode == 1:
            str4 = &#34;Diff/Src &#34; + str3
        elif  self.diffmode == 2:
            str4 = &#34;Diff/Tar &#34; + str3
        else:
            str4 = &#34;&#34; + str3

        label = Gtk.Label.new(str4)
        label.set_tooltip_text(self.fname)
        label.set_single_line_mode(True)

        eb = Gtk.EventBox(); eb.add(label)
        eb.connect_after(&#34;button-press-event&#34;, self.doclabel_callb)
        eb.set_above_child(True)

        image = Gtk.Image()
        image.set_from_stock(Gtk.STOCK_CLOSE, Gtk.IconSize.MENU)
        butt = Gtk.Button();  butt.add(image)
        butt.set_focus_on_click(False)
        butt.set_relief( Gtk.ReliefStyle.NONE)
        rc = butt.get_modifier_style()
        #rc.xthickness = 1; rc.ythickness = 1
        #butt.modify_style(rc)

        butt.connect(&#34;clicked&#34;, self.close_button)
        butt.set_tooltip_text(&#34;Close &#39;%s&#39;&#34; % os.path.basename(self.fname))
        hbox = Gtk.HBox()

        hbox.pack_start(eb, 0, 0, 0)
        hbox.pack_start(butt, 0, 0, 0)
        hbox.show_all()
        self.notebook.set_tab_label(ppp, hbox)

    def close_button(self, arg1):
        #print( &#34;close_button&#34;, arg1)
        # Select me first
        self.mained.closedoc(self)

    # --------------------------------------------------------------------
    def savemacro(self):
        #print( &#34;Savemacro&#34;)

        fname = &#34;untitled.mac&#34;
        xfile = pedconfig.conf.config_dir + &#34;/macros/&#34; + fname
        old = os.getcwd()
        try:
            os.chdir(os.path.dirname(xfile))
        except:
            print(&#34;No macros directory&#34;, sys.exc_info())

        but =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Save Macro&#34;, Gtk.ButtonsType.OK
        fc = Gtk.FileChooserDialog(&#34;Save Macro&#34;, None, Gtk.FileChooserAction.SAVE, \
            but)

        fc.set_current_folder(xfile)
        fc.set_current_name(os.path.basename(xfile))
        fc.set_default_response(Gtk.ButtonsType.OK)
        fc.connect(&#34;response&#34;, self.done_mac_fc, old)
        fc.run()

    def done_mac_fc(self, win, resp, old):
        #print(  &#34;done_mac_fc&#34;, resp)
        # Back to original dir
        os.chdir(os.path.dirname(old))
        if resp == Gtk.ButtonsType.OK:
            try:
                fname = win.get_filename()
                if not fname:
                    print(&#34;Must have filename&#34;)
                else:
                    fh = open(fname, &#34;wb&#34;)
                    pickle.dump(self.recarr, fh)
                    fh.close()
            except:
                print(&#34;Cannot save macro file&#34;, sys.exc_info())

        win.destroy()

    def loadmacro(self):
        #print( &#34;Loadmacro&#34;)

        xfile = pedconfig.conf.config_dir + &#34;/macros/&#34;
        old = os.getcwd()
        try:
            os.chdir(os.path.dirname(xfile))
        except:
            print(&#34;No macros directory&#34;, sys.exc_info())

        but =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Load Macro&#34;, Gtk.ButtonsType.OK
        fc = Gtk.FileChooserDialog(&#34;Load Macro&#34;, None, Gtk.FileChooserAction.OPEN, \
            but)

        fc.set_current_folder(xfile)
        #fc.set_current_folder(old)
        fc.set_default_response(Gtk.ButtonsType.OK)
        fc.connect(&#34;response&#34;, self.done_mac_open_fc, old)
        fc.run()

    def done_mac_open_fc(self, win, resp, old):
        #print(  &#34;done_mac_fc&#34;, resp)

        # Back to original dir
        os.chdir(os.path.dirname(old))
        if resp == Gtk.ButtonsType.OK:
            try:
                fname = win.get_filename()
                if not fname:
                    print(&#34;Must have filename&#34;)
                else:
                    fh = open(fname, &#34;rb&#34;)
                    self.recarr = pickle.load(fh)
                    fh.close()
            except:
                print(&#34;Cannot load macro file&#34;, sys.exc_info())

        win.destroy()

    # Refresh current search buffer
    def search_again(self):
        if len(self.accum) == 0:
            return

        if self.src_changed:
            self.search(self.srctxt, self.regex, self.boolcase, self.boolregex)

    # --------------------------------------------------------------------
    def search(self, srctxt, regex, boolcase, boolregex):

        # Remember old settings:
        self.srctxt = srctxt;       self.regex = regex
        self.boolcase = boolcase;   self.boolregex = boolregex
        self.src_changed = False

        self.accum = []

        curr = self.caret[1] + self.ypos
        was = -1; cnt = 0; cnt2 = 0

        for line in self.text:
            # Search one line for multiple matches
            mmm = src_line(line, cnt, srctxt, regex, boolcase, boolregex)

            if cnt &gt; curr and was == -1:
                was = cnt2
            if  mmm:
                cnt2 += 1
                for sss in mmm:
                    self.accum.append(sss)
            if cnt % 100 == 0:
                self.mained.update_statusbar(&#34;Searching at %d&#34; % cnt)
                usleep(1)
            cnt += 1
        return was, cnt2


# ------------------------------------------------------------------------
# Run this on an idle callback so the user can work while this is going

def run_async_time(win):

    global last_scanned

    #print( &#34;run_async_time enter&#34;)

    if  last_scanned == win:
        return

    last_scanned = win
    win.mained.start_tree()

    #print( &#34;run_sync_time&#34;, time.time())

    sumw = [] ; lname = win.fname.lower()
    if not win.text:
        return

    # Added flex and yacc
    if &#34;.c&#34; in lname or &#34;.h&#34; in lname or &#34;.y&#34; in lname or &#34;.f&#34; in lname or \
        &#34;.php&#34; in lname:
        try:
            regex = re.compile(ckeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in c func handler&#34;, sys.exc_info())
            pass

    elif &#34;.py&#34; in lname:
        try:
            regex = re.compile(pykeywords2)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in py func handler&#34;, sys.exc_info())
            pass
    elif &#34;.bas&#34; in lname:
        try:
            regex = re.compile(basekeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in func extraction handler&#34;, sys.exc_info())
            pass
    elif &#34;.s&#34; in lname:
        try:
            regex = re.compile(Skeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in func extraction handler&#34;, sys.exc_info())
            pass
    elif &#34;.txt&#34; in lname:
        pass
    else:
        try:
            for kw in sumkeywords:
                for line in win.text:
                    if line.find(kw) &gt;= 0:
                        sumw.append(line)
        except:
            pass

    try:
        win.mained.update_treestore(sumw)
    except:
        # This is &#39;normal&#39;, ignore it
        print(&#34;run_async_time&#34;, sys.exc_info())
        pass


# EOF</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="peddoc_diff.run_async_time"><code class="name flex">
<span>def <span class="ident">run_async_time</span></span>(<span>win)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_async_time(win):

    global last_scanned

    #print( &#34;run_async_time enter&#34;)

    if  last_scanned == win:
        return

    last_scanned = win
    win.mained.start_tree()

    #print( &#34;run_sync_time&#34;, time.time())

    sumw = [] ; lname = win.fname.lower()
    if not win.text:
        return

    # Added flex and yacc
    if &#34;.c&#34; in lname or &#34;.h&#34; in lname or &#34;.y&#34; in lname or &#34;.f&#34; in lname or \
        &#34;.php&#34; in lname:
        try:
            regex = re.compile(ckeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in c func handler&#34;, sys.exc_info())
            pass

    elif &#34;.py&#34; in lname:
        try:
            regex = re.compile(pykeywords2)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in py func handler&#34;, sys.exc_info())
            pass
    elif &#34;.bas&#34; in lname:
        try:
            regex = re.compile(basekeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in func extraction handler&#34;, sys.exc_info())
            pass
    elif &#34;.s&#34; in lname:
        try:
            regex = re.compile(Skeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in func extraction handler&#34;, sys.exc_info())
            pass
    elif &#34;.txt&#34; in lname:
        pass
    else:
        try:
            for kw in sumkeywords:
                for line in win.text:
                    if line.find(kw) &gt;= 0:
                        sumw.append(line)
        except:
            pass

    try:
        win.mained.update_treestore(sumw)
    except:
        # This is &#39;normal&#39;, ignore it
        print(&#34;run_async_time&#34;, sys.exc_info())
        pass</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="peddoc_diff.pedDoc"><code class="flex name class">
<span>class <span class="ident">pedDoc</span></span>
<span>(</span><span>buff, mained, readonly=False)</span>
</code></dt>
<dd>
<div class="desc"><p>:Constructors:</p>
<p>::</p>
<pre><code>DrawingArea(**properties)
new() -&gt; Gtk.Widget
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pedDoc(Gtk.DrawingArea, peddraw.peddraw):

    def __init__(self, buff, mained, readonly = False):

        # Save params
        self.mained = mained
        self.readonly = readonly

        # Gather globals
        self.keyh = pedconfig.conf.keyh
        self.acth = pedconfig.conf.acth

        # Init vars
        self.xpos = 0; self.ypos = 0
        self.changed = False
        self.src_changed = False
        self.needscan = True
        self.record = False
        self.recarr = []                # Macros
        self.undoarr = []               # Undo
        self.redoarr = []               # Redo
        self.queue = []                 # Idle tasks
        self.colsel = False
        self.oldsearch = &#34;&#34;
        self.oldgoto = &#34;&#34;
        self.oldrep = &#34;&#34;
        self.xsel = -1; self.ysel = -1
        self.xsel2 = -1; self.ysel2 = -1
        self.mx = -1; self.my = -1
        self.caret = []; self.caret.append(0); self.caret.append(0)
        self.focus = False
        self.insert = True
        self.startxxx = -1;  self.startyyy = -1
        self.hex = False
        self.colflag = True
        self.acorr = False
        self.scol = False
        self.accum = []
        self.tokens = []
        self.ularr = []
        self.bigcaret = False
        self.stab = False
        self.oneshot = False
        self.initial_undo_size = 0
        self.initial_redo_size = 0
        self.spell = False
        self.spellmode = False
        self.start_time = time.time()
        self.shift = False
        # Init configurables
        self.vscgap = VSCROLLGAP
        self.hscgap = HSCROLLGAP
        self.pgup  = PAGEUP
        self.tabstop = TABSTOP
        # Process buffer into list
        self.text = buff
        self.maxlinelen = 0
        self.maxlines = 0
        self.fired = 0
        self.countup = 0
        self.nokey = False
        self.newword = False
        self.scrtab = False
        self.stat = None
        self.sep = &#34;\n&#34;
        self.tts = None
        self.lastcmd = &#34;&#34;
        self.caps = False
        self.scr = False
        self.lastevent = None
        self.hhh = self.www = 0
        self.diffmode = 0

        self.FGCOLOR    = FGCOLOR
        self.FGCOLORRO  = FGCOLORRO
        self.RFGCOLOR   = RFGCOLOR
        self.BGCOLOR    = BGCOLOR
        self.RBGCOLOR   = RBGCOLOR
        self.CBGCOLOR   = CBGCOLOR
        self.KWCOLOR    = KWCOLOR
        self.CLCOLOR    = CLCOLOR
        self.COCOLOR    = COCOLOR
        self.STCOLOR    = STCOLOR

        # Parent widget
        Gtk.DrawingArea.__init__(self)
        self.set_can_focus(True)
        peddraw.peddraw.__init__(self, self)

        # Our font
        fsize  =  pedconfig.conf.sql.get_int(&#34;fsize&#34;)
        fname  =  pedconfig.conf.sql.get_str(&#34;fname&#34;)
        if fsize == 0: fsize = 14
        if fname == &#34;&#34;: fname = &#34;Monospace&#34;

        self.setfont(fname, fsize)

        if self.readonly:
            self.set_tooltip_text(&#34;Read only buffer&#34;)

        # Create scroll items
        sm = len(self.text) + self.get_height() / self.cyy + 10
        self.hadj = Gtk.Adjustment(value=0, lower=0, upper=self.maxlinelen,
                            step_increment = 1, page_increment = 15, page_size = 25)
        self.vadj = Gtk.Adjustment(value=0, lower=0, upper=sm,
                            step_increment = 1, page_increment = 15, page_size = 25)

        self.vscroll = Gtk.VScrollbar(adjustment=self.vadj)
        self.hscroll = Gtk.HScrollbar(adjustment=self.hadj)

        # We connect scrollers after construction
        self.hadj.connect(&#34;value-changed&#34;, self.hscroll_cb)
        self.vadj.connect(&#34;value-changed&#34;, self.vscroll_cb)

        self.set_events(Gdk.EventMask.ALL_EVENTS_MASK)

        #self.colormap = Gtk.widget_get_default_colormap()
        self.setcol()

        # Set default background color
        if self.readonly:
            #color = self.colormap.alloc_color(&#34;#d8d8d8&#34;)
            #self.modify_bg(Gtk.STATE_NORMAL, color)
            pass

        #self.connect(&#34;expose-event&#34;, self.area_expose_cb)
        self.connect(&#34;draw&#34;, self.draw_event)
        self.connect(&#34;motion-notify-event&#34;, self.area_motion)
        self.connect(&#34;button-press-event&#34;, self.area_button)
        self.connect(&#34;button-release-event&#34;, self.area_button)
        self.connect(&#34;key-press-event&#34;, self.area_key)
        self.connect(&#34;key-release-event&#34;, self.area_key)
        self.connect(&#34;focus&#34;, self.area_focus)
        self.connect(&#34;configure_event&#34;, self.configure_event)
        #self.connect(&#34;size-request&#34;, self.)
        self.connect(&#34;size-allocate&#34;, self.size_alloc)
        self.connect(&#34;scroll-event&#34;, self.scroll_event)
        self.connect(&#34;focus-in-event&#34;, self.focus_in_cb)
        self.connect(&#34;focus-out-event&#34;, self.focus_out_cb)

        self.drag_dest_set(0, [], 0)
        self.connect(&#39;drag-motion&#39;, self.on_drag_motion)
        self.connect(&#39;drag-drop&#39;, self.on_drag_drop)
        self.connect(&#34;drag-data-received&#34;, self.on_drag_data_received)

    def on_drag_motion(self, widgt, context, c, y, time):
        Gdk.drag_status(context, Gdk.DragAction.COPY, time)
        return True

    def on_drag_drop(self, widget, context, x, y, time):
        widget.drag_get_data(context, context.list_targets()[-1], time)

    def on_drag_data_received(self, widget, drag_context, x, y, data, info, time):

        if info ==  TARGET_ENTRY_TEXT:
            text = data.get_text()
            #print(&#34;Received text: %s&#34; % text)
            pedconfig.conf.keyh.acth.add_str(self, text)

        elif info ==  TARGET_ENTRY_PIXBUF:
            pixbuf = data.get_pixbuf()
            width = pixbuf.get_width()
            height = pixbuf.get_height()

            print(&#34;Received pixbuf with width %spx and height %spx&#34; % (width, height))

    # Customize your colors here
    def setcol(self):
        ccc = pedconfig.conf.sql.get_str(&#34;fgcolor&#34;)
        if ccc == &#34;&#34;:
            self.fgcolor  = pedcolor.str2float(FGCOLOR)
        else:
            self.fgcolor  = pedcolor.str2float(ccc)
        #print( &#34;fgcol&#34;, self.fgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;rbgcolor&#34;)
        if ccc == &#34;&#34;:
            self.rbgcolor = pedcolor.str2float(RBGCOLOR)
        else:
            self.rbgcolor = pedcolor.str2float(ccc)
        #print( &#34;rgbcolor&#34;, self.rbgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;bgcolor&#34;)
        if ccc == &#34;&#34;:
            self.bgcolor = pedcolor.str2float(BGCOLOR)
        else:
            self.bgcolor = pedcolor.str2float(ccc)
        #print( &#34;bgcolor&#34;, self.bgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;cbgcolor&#34;)
        if ccc == &#34;&#34;:
            self.cbgcolor = pedcolor.str2float(CBGCOLOR)
        else:
            self.cbgcolor = pedcolor.str2float(ccc)
        #print( &#34;cbgcolor&#34;, self.cbgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;kwcolor&#34;)
        if ccc == &#34;&#34;:
            self.kwcolor = pedcolor.str2float(KWCOLOR)
        else:
            self.kwcolor = pedcolor.str2float(ccc)
        #print( &#34;load kwcolor&#34;, self.kwcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;clcolor&#34;)
        if ccc == &#34;&#34;:
            self.clcolor = pedcolor.str2float(CLCOLOR)
        else:
            self.clcolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;cocolor&#34;)
        if ccc == &#34;&#34;:
            self.cocolor = pedcolor.str2float(COCOLOR)
        else:
            self.cocolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;stcolor&#34;)
        if ccc == &#34;&#34;:
            self.stcolor = pedcolor.str2float(STCOLOR)
        else:
            self.stcolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;carcolor&#34;)
        if ccc == &#34;&#34;:
            self.carcolor = pedcolor.str2float(CARCOLOR)
        else:
            self.carcolor = pedcolor.str2float(ccc)

    def setfont(self, fam, size):

        self.fd = Pango.FontDescription()
        self.fd.set_family(fam)
        self.fd.set_size(size * Pango.SCALE)

        self.pangolayout = self.create_pango_layout(&#34;a&#34;)
        self.pangolayout.set_font_description(self.fd)

        # Get Pango steps
        self.cxx, self.cyy = self.pangolayout.get_pixel_size()

        # Get Pango tabs
        self.tabarr = Pango.TabArray(80, False)
        #for aa in range(self.tabarr.get_size()):
        #    self.tabarr.set_tab(aa, Pango.TAB_LEFT, aa * TABSTOP * self.cxx * Pango.SCALE)

        self.pangolayout.set_tabs(self.tabarr)
        ts = self.pangolayout.get_tabs()

        &#39;&#39;&#39;if ts != None:
            al, self.tabstop = ts.get_tab(1)
        self.tabstop /= self.cxx * Pango.SCALE&#39;&#39;&#39;

    def  set_maxlinelen(self, mlen = -1, ignore = True):
        if mlen == -1: self.calc_maxline()
        self.maxlinelen = mlen
        self.oneshot = ignore
        #value, lower, upper, step_increment, page_increment, page_size)
        #self.hadj.set_all(0, 0, self.maxlinelen * 2, 1, 15, 25)
        self.hadj.set_value(0)
        self.hadj.set_lower(0)
        self.hadj.set_upper(self.maxlinelen * 2)
        self.hadj.set_step_increment(1)
        self.hadj.set_page_increment(15)
        self.hadj.set_page_size(25)

    def  set_maxlines(self, lines = 0, ignore = True):
        self.maxlines = len(self.text) + self.get_height() / self.cyy + 25
        self.oneshot = ignore
        #self.vadj.set_all(0, 0, self.maxlines, 1, 15, 25)
        self.vadj.set_value(0)
        self.vadj.set_lower(0)
        self.vadj.set_upper(self.maxlines)
        self.vadj.set_step_increment(1)
        self.vadj.set_page_increment(15)
        self.vadj.set_page_size(25)

    # Do Tasks  when the system is idle
    def idle_callback(self):
        #print( &#34;Idle callback&#34;)
        GLib.source_remove(self.source_id)
        try:
            if self.changed:
                hhh = hash_name(self.fname) + &#34;.sav&#34;
                xfile = pedconfig.conf.data_dir + os.sep + hhh
                err = writefile(xfile, self.text, &#34;\n&#34;)
                if err[0]:
                    strx = &#34;Backed up file &#39;{0:s}&#39;&#34;.format(xfile)
                else:
                    strx = &#34;Cannot back up file &#39;{0:s}&#39; {1:s}&#34;.format(xfile, err[1])

                self.mained.update_statusbar(strx)
        except:
            print(&#34;Exception in idle handler&#34;, sys.exc_info())

    # Do Tasks2 when the system is idle
    def idle_callback2(self):
        #print( &#34;Idle callback2&#34;)
        GLib.source_remove(self.source_id2)
        try:
            run_async_time(self)
        except:
            print(&#34;Exception in async handler&#34;, sys.exc_info())

    def locate(self, xstr):
        #print( &#34;locate &#39;&#34; + xstr +&#34;&#39;&#34;)
        cnt = 0; cnt2 = 0; idx = 0; found = 0
        for line in self.text:
            if xstr == line:
                self.gotoxy(idx, cnt, len(xstr), True)
                found = 1
                break
            cnt += 1
        if not found:
            xstr2 = xstr.lstrip().replace(&#34;\t&#34;, &#34; &#34;)
            for line2 in self.text:
                idx2 = line2.find(xstr2)
                if idx2 &gt;= 0:
                    self.gotoxy(idx2, cnt2, len(xstr2), True)
                    break
                cnt2 += 1

    def focus_out_cb(self, widget, event):
        #print( &#34;focus_out_cb&#34;, widget, event)
        self.focus = False

    def focus_in_cb(self, widget, event):
        #print (&#34;focus_in_cb&#34;)
        self.focus = True

        try:
            os.chdir(os.path.dirname(self.fname))
            xstat = os.stat(self.fname)
            if not self.readonly:
                #print(self.fname, &#34;stat&#34;, self.stat.st_mtime, &#34;xstat&#34;, xstat.st_mtime)
                if self.stat.st_mtime !=  xstat.st_mtime:
                    rrr = pedync.yes_no_cancel(&#34;File changed outside PyEdPro&#34;,
                        &#34;&#39;%s&#39;\n&#34; \
                        &#34;changed outside PyEdPro.&#34; \
                        &#34;Reload?&#34; % self.fname, False)
                    if rrr == Gtk.ResponseType.YES:
                        print(&#34;Reloading&#34;)
                        self.savebackup()
                        self.loadfile(self.fname)

            # Update stat info
            self.stat = xstat
        except:
            #pedutil.put_exception(&#34;cmp mtime&#34;)
            pass

        self.update_bar2()
        self.needscan = True
        self.do_chores()

    def grab_focus_cb(self, widget):
        #print( &#34;grab_focus_cb&#34;, widget)
        pass

    def area_enter(self, widget, event):
        #print( &#34;area_enter&#34;)
        pass

    def area_leave(self, widget, event):
        #print( &#34;area_leave&#34;)
        pass

    def scroll_event(self, widget, event):
        #print( &#34;scroll_event&#34;, event, event.direction)
        xidx = self.xpos + self.caret[0]
        yidx = self.ypos + self.caret[1]
        if event.direction == Gdk.ScrollDirection.SMOOTH:
            flag, directx, directy = event.get_scroll_deltas()
            if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
                yidx += 10 * int(directy)
            elif event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                yidx += 5 * int(directy)
            else:
                yidx += int(directy)
        else:
            #print( &#34;type&#34;, type(event.type))
            #print(&#34;truth&#34;, isinstance(event.type, Gdk.EventType))
            if event.direction == Gdk.ScrollDirection.UP:
                yidx -= int(self.pgup / 2)
            else:
                yidx += int(self.pgup / 2)

        self.set_caret(xidx, yidx)
        self.invalidate()

    def hscroll_cb(self, widget):
        #print( &#34;hscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.honeshot:
            self.honeshot = False; return
        xidx = int(widget.get_value())

        #print( &#34;hscroll_cb ok&#34;, widget.get_value())
        self.set_caret(xidx, self.ypos + self.caret[1])
        self.invalidate()


        #print( &#34;vscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.oneshot:
            self.oneshot = False; return
        #print( &#34;vscroll_cb ok&#34;, widget.get_value())
        yidx = int(widget.get_value())
        self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
        self.invalidate()

    def vscroll_cb(self, widget):
        #print( &#34;vscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.oneshot:
            self.oneshot = False; return
        #print( &#34;vscroll_cb ok&#34;, widget.get_value())
        yidx = int(widget.get_value())
        self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
        self.invalidate()

    def size_request(self, widget, req):
        #print( &#34;size_request&#34;, req)
        pass

    def size_alloc(self, widget, req):
        #print( &#34;size_alloc&#34;, req)
        pass

    def configure_event(self, widget, event):
        #print( &#34;configure_event&#34;, event)
        #self.grab_focus()
        #self.width = 0; self.height = 0
        #self.invalidate()
        #print( self, event)
        pass

    def draw_event(self, pdoc, cr):

        self.hhh = self.get_height();  self.www = self.get_width()
        self.xlen = len(self.text)

        ctx = self.get_style_context()
        fg_color = ctx.get_color(Gtk.StateFlags.NORMAL)
        #bg_color = ctx.get_background_color(Gtk..NORMAL)

        # Paint white, ignore system BG
        #cr.set_source_rgba(255, 255, 255)
        # Paint prescribed color
        if self.readonly:
            # Slightly darker / lighter
            newcol =  list(self.bgcolor)
            for aa in range(len(newcol)):
                if newcol[aa] &gt; 0.5: newcol[aa] -= .1
                else: newcol[aa] += .2
            cr.set_source_rgba(*list(newcol))
        else:
            cr.set_source_rgba(*list(self.bgcolor))

        cr.rectangle( 0, 0, self.www, self.hhh)
        cr.fill()

        # Pre set for drawing
        #cr.set_source_rgba(*list(fg_color))
        # Paint prescribed color
        cr.set_source_rgba(*list(self.fgcolor))

        cr.move_to(0, 0)
        self.layout = PangoCairo.create_layout(cr)
        self.layout.set_font_description(self.fd)

        self.draw_maintext(cr)

        if not self.hex:
            # Do the text drawing in stages ...
            self.draw_selection(cr)
            self.draw_syntax(cr)
            self.draw_clsyntax(cr)
            self.draw_comments(cr)
            self.draw_spellerr(cr)

        if self.startxxx != -1:
            self.gotoxy(self.startxxx, self.startyyy)
            self.startxxx = -1; self.startyyy = -1

        self.draw_caret(cr)

    def idle_queue(func):
        self.queue.append(func)
        #print( queue)

    def area_button(self, area, event):

        self.lastevent = event

        if pedconfig.conf.pgdebug &gt; 5:
            print( &#34;Button press  &#34;, event.type, &#34; x=&#34;, event.x, &#34; y=&#34;, event.y)

        event.x = int(event.x)
        event.y = int(event.y)

        if  event.type == Gdk.EventType.BUTTON_PRESS:
            if event.button == 1:
                #print( &#34;Left Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
                self.mx = int(event.x); self.my = int(event.y)
                xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
                # Find current pos, gather tabs, adjust back
                try:
                    line = self.text[self.ypos + yyy]
                except:
                    line = &#34;&#34;
                offs = calc_tabs2(line, xxx)

                #print( &#34;offs, xxx&#34;, offs, xxx)
                self.set_caret(self.xpos + xxx - (offs - xxx),
                                     self.ypos + yyy )
                #rp = xxx + self.xpos
                #print( &#34;xpos&#34;, self.xpos, &#34;xxx&#34;, xxx, &#34;rp&#34;, rp)
                #print( line)
                #print( &#34;line part&#34;, &#34;&#39;&#34; + line[rp:rp+8] + &#34;&#39;&#34;)

                # Erase selection
                if self.xsel != -1:
                    self.clearsel()

                self.fired += 1
                GLib.timeout_add(300, self.keytime)

            if event.button == 3:
                #print( &#34;Right Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
                flag = False; xx = 0; yy = 0; zz = 0
                if self.spell:
                    yyy = int(self.ypos + self.get_height() / self.cyy)
                    for xaa, ybb, lcc in self.ularr:
                        # Look within visible range
                        if ybb &gt;= self.ypos and ybb &lt; yyy:
                            ybb -= self.ypos
                            xaa -= self.xpos; lcc -= self.xpos
                            xaa *= self.cxx ; ybb *= self.cyy
                            lcc *= self.cxx
                            yy2 = ybb + self.cyy

                            if self.intersect(xaa, ybb, lcc, yy2, event):
                                xx = int(xaa / self.cxx + self.xpos)
                                yy = int(ybb / self.cyy + self.ypos)
                                zz = int(lcc / self.cxx + self.xpos)
                                flag = True
                if flag:
                    line = self.text[yy]
                    #print( &#34;Spell delimit: &#39;&#34; + line[xx:zz] + &#34;&#39;&#34;)
                    self.xsel = xx;
                    self.xsel2 = zz

                    self.ysel = self.ysel2 = yy
                    self.spellstr = line[int(xx):int(zz)]
                    self.popspell(area, event, self.spellstr)
                else:
                    if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                        if self.xsel == -1:
                            yyy = int(event.y / self.cyy + self.ypos)
                            xxx = int(event.x / self.cxx + self.xpos)
                            line = self.text[yyy]
                            self.xsel, self.xsel2 = selasci2(line, xxx, &#34;_-&#34;)
                            self.ysel = self.ysel2 = yyy
                        else:
                            line = self.text[self.ysel]

                        strx = line[int(self.xsel):int(self.xsel2)]
                        #print(&#34;&#39;&#34; + strx + &#34;&#39;&#34;)
                        if strx:
                            self.poprclick2(area, event, strx)
                    else:
                        self.poprclick(area, event)

        elif  event.type == Gdk.EventType.BUTTON_RELEASE:
            #print( &#34;button release&#34;, event.button)
            self.mx = -1; self.my = -1
            self.scrtab = False
            ttt = &#34;Release&#34;
            xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;
            offs = calc_tabs2(line, xxx)
            self.set_caret(self.xpos + xxx - (offs - xxx),
                                     self.ypos + yyy )

        elif  event.type == Gdk.EventType._2BUTTON_PRESS:

            if pedconfig.conf.pgdebug &gt; 2:
                print (&#34;Double click %.2f %.2f&#34; % (event.x, event.y))

            self.mx = int(event.x); self.my = int(event.y)
            xxx = int(event.x / self.cxx)
            yyy = int(event.y / self.cyy)

            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;

            # Find current pos on tabbed line
            offs = calc_tabs2(line, xxx)
            self.set_caret(self.xpos + xxx - (offs - xxx), self.ypos + yyy )
            #self.set_caret(len(xxx2), yyy)

            # Erase selection
            if self.xsel != -1:
                self.clearsel()

            # Select word
            if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
                pedconfig.conf.keyh.acth.ctrl_b(self)
            else:
                pedconfig.conf.keyh.acth.alt_v(self)
            # Copy to clip

            if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                pedconfig.conf.keyh.acth.ctrl_c(self)

        else:
            print(&#34;Unexpected mouse op.&#34;)

        self.grab_focus()
        return True

    # See if point in rect
    def intersect(self, xx, yy, xx2, yy2, event):
        # Does X intersect?
        if event.x &gt; xx and event.x &lt; xx2:
            #print( &#34;x inter&#34;, xaa, lcc)
            # Does Y intersect?
            if event.y &gt; yy and event.y &lt; yy2:
                return True
        return False

    # Normalize
    def normsel(self):
        xssel = min(self.xsel, self.xsel2)
        xesel = max(self.xsel, self.xsel2)
        yssel = min(self.ysel, self.ysel2)
        yesel = max(self.ysel, self.ysel2)

        self.xsel  = xssel;  self.ysel  = yssel
        self.xsel2 = xesel;  self.ysel2 = yesel

    def pix2xpos(self, xx):
        return int(self.xpos + xx / self.cxx)

    def pix2ypos(self, yy):
        return int(self.ypos + yy / self.cyy)

    def pix2pos(self, xx, yy):
        return int(self.xpos + xx / self.cxx), int(self.ypos + yy / self.cyy)

    def area_motion(self, area, event):
        #print (&#34;motion event&#34;, event.state, event.x, event.y)
        if event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
            #print( &#34;motion event butt 1&#34;, event.state, event.x, event.y)
            if self.xsel == -1 and self.scrtab != True:
                begsel = False
                # Horiz drag - regular sel
                if abs(event.x - self.mx) &gt; DRAGTRESH:
                    self.colsel = False; begsel = True

                if begsel:
                    self.xsel = self.xsel2 = self.xpos + self.caret[0]
                    self.ysel = self.ysel2 = self.ypos + self.caret[1]
                    #print( &#34;colsel xsel, ysel&#34;, self.colsel, self.xsel, self.ysel)
                if self.scrtab == False:
                    # Vert drag - colsel
                    if abs(event.y - self.my) &gt; DRAGTRESH:
                        self.scrtab  = True
                        self.colsel = True

            if self.scrtab  == True:
                self.xsel = self.xsel2 = self.xpos + self.caret[0]
                self.ysel = self.ysel2 = self.ypos + self.caret[1]
                xidx = self.xpos + self.caret[0]
                yidx = self.ypos + self.caret[1]
                if  event.y &gt;  self.my:
                    yidx += 1
                if  event.y &gt;  self.my:
                    yidx -= 1
                self.set_caret(xidx, yidx)
                self.my = event.y

            if self.xsel != -1:
                # Already selected, mark
                self.ysel2 = self.pix2ypos(event.y)
                if self.ysel2 &lt; self.ysel:
                    self.xsel    = self.pix2xpos(event.x)
                else:
                    self.xsel2 = self.pix2xpos(event.x)

            self.invalidate()

        if event.state &amp; Gdk.ModifierType.SHIFT_MASK and \
            event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
            #print( &#34;Shift Drag&#34;, event.x, event.y)
            pass
        pass

    def gotoxy(self, xx, yy, sel = None, mid = False):

        #print (&#34;gotoxy&#34;, xx, yy)

        # Contain
        ylen = len(self.text)
        xx2 = max(xx, 0);  yy2 = max(yy, 0)
        xx2 = min(xx, self.maxlinelen);  yy2 = min(yy, ylen)

        if sel:
            self.xsel = xx2; self.xsel2 = xx2 + sel
            self.ysel = yy2; self.ysel2 = yy2
            self.invalidate()

        if mid:
            self.set_caret_middle(xx, yy)
        else:
            self.set_caret(xx, yy)

        self.invalidate()

    # --------------------------------------------------------------------
    # Goto position, and place it to upper half / quarter

    def set_caret_middle(self, xx, yy, sel = None, quart = 2):

        xx = int(xx); yy = int(yy)

        # Needs scroll?
        #xxx, yyy = self.get_size()
        xlen = len(self.text)

        # Put it back in view:
        off = (self.get_height() / self.cyy) / quart
        if yy &gt; off:
            self.ypos = int(yy - off)
        else:
            self.ypos = 0

        self.set_caret(xx, yy)
        self.invalidate()

    # Dimenswions in character cell
    def get_height_char(self):
        return self.get_height()  / self.cyy

    def get_width_char(self):
        return self.get_width() / self.cxx

    # --------------------------------------------------------------------
    # Goto position, put caret (cursor) back to view, [vh]scrap
    # distance from ends. This function was a difficult to write. :-{
    # Note the trick with comparing old cursor pos for a hint on scroll
    # direction.
    # xx, yy - absolute position in the text buffer

    def set_caret(self, xx, yy):

        #print( &#34;set_caret&#34;, xx, yy)
        xx = int(xx); yy = int(yy)

        # Needs scroll?
        need_inval = False
        cww = self.get_width_char()
        chh = self.get_height_char()
        xlen = len(self.text)

        # ----------------------------------------------------------------
        # Put it back in view yyy:

        off = chh - self.vscgap
        if yy - self.ypos &gt; off:
            #print( &#34;Scroll from caret down&#34;)
            if yy &gt; self.ypos + self.caret[1]:
                #print( &#34;move d&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
                self.ypos = int(yy - off)
                need_inval = True
                # Force new spell check
                self.fired += 1
                #goject.timeout_add(
                GLib.timeout_add(300, self.keytime)

        if yy - self.ypos &lt; self.vscgap and self.ypos:
            #print( &#34;Scroll from caret up&#34;)
            if yy &lt; self.ypos + self.caret[1]:
                #print( &#34;move u&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
                self.ypos = int(yy - self.vscgap)
                self.ypos = int(max(self.ypos, 0))
                need_inval = True
                # Force new spell check
                self.fired += 1
                GLib.timeout_add(300, self.keytime)

        yy -= self.ypos
        if self.ypos &lt; 0: self.ypos = 0

        # ----------------------------------------------------------------
        # Put it back in view xxx:

        xoff = cww - self.hscgap
        if  xx - self.xpos  &gt; xoff:
            #print( &#34;Scroll from caret right&#34;, &#34;xx&#34;, xx, &#34;xpos&#34;, self.xpos)
            if self.xpos + self.caret[0] &lt; xx:
                #print( &#34;moved r&#34;,  xx, self.caret[0], self.xpos)
                self.xpos =  int(xx - xoff)
                self.xpos = int(max(self.xpos, 0))
                need_inval = True

        if  xx - self.xpos &lt;  self.hscgap:
            #print( &#34;Scroll from caret left &#34;, xx, self.xpos)
            if self.xpos + self.caret[0] &gt; xx:
                #print( &#34;moved l&#34;, &#34;xx&#34;, xx, &#34;caret&#34;, self.caret[0], &#34;xpos&#34;, self.xpos)
                self.xpos = int(xx - self.hscgap)
                self.xpos = int(max(self.xpos, 0))
                need_inval = True

        xx -= self.xpos
        if self.xpos &lt; 0: self.xpos = 0

        oldx = self.caret[0] * self.cxx
        oldy = self.caret[1] * self.cyy

        # Cheat - invalidate all if tab is involved at old line
        try:
            line = self.text[oldy]
        except:
            line = &#34;&#34;; need_inval = True
        if line.find(&#34;\t&#34;) &gt;= 0:
            need_inval = True

        self.caret[0] = xx; self.caret[1] = yy

        # Low limit
        if self.caret[0] &lt; 0: self.caret[0] = 0
        if self.caret[1] &lt; 0: self.caret[1] = 0

        wxx = self.caret[0] * self.cxx
        wyy = self.caret[1] * self.cyy

        # Cheat - invalidate all if tab is involoved
        try:
            line = self.text[self.ypos + self.caret[1]]
        except:
            line = &#34;&#34;; need_inval = True
        if line.find(&#34;\t&#34;) &gt;= 0:
            need_inval = True

        # Optimize cursor movement invalidation
        &#39;&#39;&#39;if  not need_inval :
            rect = Gdk.Rectangle(wxx, wyy, self.cxx * self.cxx /2, self.cyy + 1)
            self.invalidate(rect)

            rect = Gdk.Rectangle(oldx, oldy, self.cxx + self.cxx /2 , self.cyy + 1)
            self.invalidate(rect)
        &#39;&#39;&#39;
        self.invalidate(None)

        # Update scroll bars, prevent them from sending scroll message:
        self.oneshot = True; self.vscroll.set_value(self.ypos)
        self.honeshot = True; self.hscroll.set_value(self.xpos)

        self.update_bar2()

        if  need_inval or self.bigcaret:
            self.invalidate()

    def update_bar2(self):
        clip = pedconfig.conf.keyh.acth.currclip
        self.mained.update_statusbar2(self.caret[0] + self.xpos, \
                self.caret[1] + self.ypos, self.insert, len(self.text), clip, self.caps, self.scr)

    def clearsel(self):
        old = self.xsel
        self.xsel  =  self.ysel = -1
        self.xsel2 =  self.ysel2 = -1
        if old != -1:
            self.invalidate()

    def keytime(self):
        #print( &#34;keytime raw&#34;, time.time(), self.fired)
        if self.fired ==  1:
            #print( &#34;keytime&#34;, time.time(), self.fired)
            pedspell.spell(self, self.spellmode)
            self.walk_func()
        self.fired -= 1

        # Track this buffer
        if self.diffmode == 2:
            self.mained.diffpane.area.xpos = self.xpos
            self.mained.diffpane.area.ypos = self.ypos
            self.mained.diffpane.area.set_caret(self.xpos + self.caret[0],
                                                        self.ypos + self.caret[1])

    def walk_func(self):
        #print( &#34;walk func&#34;)
        # ts2 ---------------------------------------------------
        sumw2 = []
        if self.text:
            sline = self.caret[1] + int(self.ypos)
            sline = max(sline, 0); sline = min(sline, len(self.text))
            #print( &#34;Start point&#34;, sline, self.text[sline])
            # Walk back to last function
            if &#34;.c&#34; in self.fname or &#34;.h&#34; in self.fname or &#34;.php&#34; in self.fname:
                try:
                    aa = 0; bb = 0
                    regex = re.compile(ckeywords)
                    for aa in range(sline - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break
                    if aa &gt; 0:
                        for bb in range(aa + 1, len(self.text)):
                            line = self.text[bb]
                            res = regex.search(line)
                            if res:
                                #print( &#34;end&#34;, line, res.start(), res.end())
                                break

                        regex2 = re.compile(localkwords)
                        for cc in range(aa + 1, bb - 1):
                            line = self.text[cc]
                            res = regex2.search(line)
                            if res:
                                #print( &#34;match&#34;, line, res.start(), res.end())
                                sumw2.append(line)

                except:
                    print(&#34;Exception in c func handler&#34;, sys.exc_info())
                    pass
            if &#34;.bas&#34; in self.fname.lower():
                try:
                    regex = re.compile(basekeywords)
                    for line in win.text:
                        res = regex.search(line)
                        if res:
                            #print( res, res.start(), res.end())
                            sumw.append(line)
                except:
                    print(&#34;Exception in bas func extraction handler&#34;, sys.exc_info())
                    pass
            if &#34;.py&#34; in self.fname.lower():
                try:
                    aa = 0; bb = 0
                    regex = re.compile(&#34;class&#34;)
                    for aa in range(int(sline) - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break

                    regex = re.compile(pykeywords2)
                    for aa in range(int(sline) - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break

                    if aa &gt; 0:
                        for bb in range(aa + 1, len(self.text)):
                            line = self.text[bb]
                            res = regex.search(line)
                            if res:
                                #print( &#34;end&#34;, line, res.start(), res.end())
                                break

                        regex2 = re.compile(localpywords)
                        for cc in range(aa + 1, bb - 1):
                            line = self.text[cc]
                            res = regex2.search(line)
                            if res:
                                #print( &#34;match&#34;, line, res.start(), res.end())
                                sumw2.append(line)

                except:
                    print(&#34;Exception in py func handler&#34;, sys.exc_info())
                    raise
                    pass
            else:
                pass

            # Always show todo
            got_todo = 0
            for line in self.text:
                if &#34;TODO&#34; in line:
                    if not got_todo:
                        got_todo = 1
                        sumw2.append(&#34;----------- TODO List ----------&#34;)
                    sumw2.append(line)

        try:
            self.mained.update_treestore2(sumw2)
        except:
            # This is normal, ignore it
            print(&#34;walk2&#34;, sys.exc_info())
            pass

    # Call key handler
    def area_key(self, area, event):

        #print (&#34;area_key&#34;, event)
        # Restart timer ticks
        pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
        pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

        # Maintain a count of events, only fire only fire on the last one
        self.fired += 1
        GLib.timeout_add(300, self.keytime)
        # The actual key handler
        self.keyh.handle_key(self, area, event)

        #if event.type == Gdk.KEY_RELEASE:
        #    self.source_id = GObject.idle_add(self.idle_callback)

        # We handled it
        return True

     # Invalidate current line
    def inval_line(self):
        rect = Gdk.Rectangle()
        xx = self.caret[0] * self.cxx
        yy = self.caret[1] * self.cyy
        ww = self.get_width()
        hh = self.cyy
        #self.invalidate(rect)
        xx = 0
        self.queue_draw_area(xx, yy, ww, hh)

    def invalidate(self, rect = None):
        #print( &#34;Invalidate:&#34;, rect)
        if rect == None:
            self.queue_draw()
        else:
            self.queue_draw_area(rect.x, rect.y,
                            rect.width, rect.height)

    def area_focus(self, area, event):
        #print( &#34;ped doc area focus&#34;, event)
        return False

    # Add to user dictionary:
    def addict(self, widget, string, arg):
        #print( &#34;addict&#34;, arg)
        if not pedspell.append_user_dict(self, arg):
            self.mained.update_statusbar(&#34;Cannot append to user dict&#34;)
        else:
            self.mained.update_statusbar(&#34;Added &#39;%s&#39; to user dict&#34; % arg)
            self.newword = True

        # Force new spell check
        self.fired += 1
        GLib.timeout_add(300, self.keytime)

    def popspell(self, widget, event, xstr):
        # Create a new menu-item with a name...
        self.menu2 = Gtk.Menu()
        self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % xstr, None))
        self.menu2.append(self.create_menuitem(&#34;Add to Dict&#34;, self.addict, xstr))

        mi = self.create_menuitem(&#34;-------------&#34;, None)
        mi.set_sensitive(False)
        self.menu2.append(mi)

        strs = &#34;Creating suggestion list for &#39;{0:s}&#39;&#34;.format(self.spellstr)
        self.mained.update_statusbar(strs)
        arr = pedspell.suggest(self, xstr)

        if len(arr) == 0:
            self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
        else:
            for aa, bb in arr:
                self.menu2.append(self.create_menuitem(bb, self.menuitem_response))

        self.menu2.popup(None, None, None, None, event.button, event.time)
        #self.mained.update_statusbar(&#34;Done menu popup.&#34;)

    def set_diffs(self, arg1, arg2, arg3):
        # reset all
        if arg3 == 0:
            nn = self.notebook.get_n_pages(); cnt = 0
            while True:
                if cnt &gt;= nn: break
                ppp = self.notebook.get_nth_page(cnt)
                ppp.area.diffmode = 0
                ppp.area.set_tablabel()
                cnt += 1
            www = self.mained.get_width()
            self.mained.hpaned3.set_position(www - 10)

        else:
            self.diffmode = arg3
            self.set_tablabel()

            got_src = 0; got_targ = 0; action_page = 0;
            src = &#34;&#34;; targ = &#34;&#34;
            srctxt = [] ;  targtxt = []
            action_tab = None

            # See if diff complete, put it in motion
            nn = self.notebook.get_n_pages(); cnt = 0
            while True:
                if cnt &gt;= nn: break
                ppp = self.notebook.get_nth_page(cnt)
                #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
                if ppp.area.diffmode == 1:
                    got_src = True
                    src = os.path.basename(ppp.area.fname)
                    srctxt = ppp.area.text

                if ppp.area.diffmode == 2:
                    got_targ = True
                    targ = os.path.basename(ppp.area.fname)
                    targtxt = ppp.area.text
                    action_page = cnt
                    action_tab = ppp

                if ppp.area.diffmode == 1:
                    got_src = True
                cnt += 1

            if got_src and got_targ:
                www = self.mained.get_width()
                if self.mained.hpaned3.get_position() &gt; www - 20:
                    self.mained.hpaned3.set_position(www - www / 3)

                self.mained.update_statusbar(    \
                            &#34;Diff started.  Source: &#39;%s&#39; Target: &#39;%s&#39;&#34; % (src, targ))

                self.notebook.set_current_page(action_page)
                action_tab.area.diffx(srctxt, targtxt)

    def diffx(self, srctxt, targtxt):

        #self.mained.diffpane.area.text.append(&#34;Diff started.&#34;)

        for aa in range(len(targtxt)):
            if srctxt[aa] == targtxt[aa]:
                self.mained.diffpane.area.text.append(targtxt[aa])
            else:
                self.mained.diffpane.area.text.append(&#34; --- &#34;)

        self.mained.diffpane.area.xpos = self.xpos
        self.mained.diffpane.area.ypos = self.ypos
        self.mained.diffpane.area.gotoxy(
                         self.xpos + self.caret[0], self.ypos + self.caret[1])
        self.mained.diffpane.area.invalidate()


    def iterdocs(self, callb, arg):
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            callb(ppp.area, arg)
            cnt += 1

    def builddoc(self, ppp):
        if ppp.area.diffmode == 1:
            got_src = True
        if ppp.area.diffmode == 2:
            got_targ = True

    def poprclick3(self, event):
        #print (&#34;Making shift rclick3&#34;)
        got_src = 0; got_targ = 0

        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
            if ppp.area.diffmode == 2:
                got_targ = True
            cnt += 1

        # Check if there is any:
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
            if ppp.area.diffmode == 2:
                got_targ = True
            cnt += 1

        self.menu3 = Gtk.Menu()
        if not got_src:
            self.menu3.append(self.create_menuitem(&#34;Set as Diff Source&#34;, self.set_diffs, 1))
        if not got_targ:
            self.menu3.append(self.create_menuitem(&#34;Set as Diff Target&#34;, self.set_diffs, 2))

        self.menu3.append(self.create_menuitem(&#34;Unset (stop) Diff&#34;,  self.set_diffs, 0))
        self.menu3.popup(None, None, None, None, event.button, event.time)

    def poprclick2(self, widget, event, strx):
        #print (&#34;Making shift rclick2&#34;)
        self.menu2 = Gtk.Menu()
        self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % strx, None))
        mi = self.create_menuitem(&#34;-------------&#34;, None)
        mi.set_sensitive(False)
        self.menu2.append(mi)
        strs = &#34;Creating class list for &#39;{0:s}&#39;&#34;.format(strx)
        self.mained.update_statusbar(strs)
        arr = pedstruct.suggest(self, strx)
        if len(arr) == 0:
            self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
        else:
            for bb in arr:
                self.menu2.append(self.create_menuitem(bb, self.menuitem_response2))

        self.menu2.popup(None, None, None, None, event.button, event.time)

    def poprclick(self, widget, event):
        #print (&#34;Making rclick&#34;)
        self.build_menu(self, pedmenu.rclick_menu)
        if event:
            self.menu.popup(None, None, None, None, event.button, event.time)
        else:
            event = Gdk.EventButton()
            self.menu.popup(None, None, None, None, event.button, event.time)

    def menuitem_response2(self, widget, stringx, arg):
        #print( &#34;menuitem response2 &#39;%s&#39;&#34; % stringx)
        #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)
        disp2 = Gdk.Display()
        disp = disp2.get_default()
        clip = Gtk.Clipboard.get_default(disp)
        stringx = stringx.strip()
        clip.set_text(stringx, len(stringx))
        strs = &#34;Copied to clipboard &#39;{0:s}&#39;&#34;.format(stringx)
        self.mained.update_statusbar(strs)

    def menuitem_response(self, widget, stringx, arg):
        #print( &#34;menuitem response &#39;%s&#39;&#34; % stringx)
        #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)

        # See if Capitalized or UPPERCASE :
        if self.spellstr[0] in string.ascii_uppercase:
            stringx = stringx.capitalize()

        if self.spellstr.isupper():
            stringx = stringx.upper()

        pedconfig.conf.keyh.acth.clip_cb(None, stringx, self, False)

        self.fired += 1
        GLib.timeout_add(300, self.keytime)

    def activate_action(self, action):
        dialog = Gtk.MessageDialog(self, Gtk.DIALOG_DESTROY_WITH_PARENT,
            Gtk.ButtonsType.INFO, Gtk.ButtonsType.CLOSE,
            &#39;You activated action: &#34;%s&#34; of type &#34;%s&#34;&#39; % (action.get_name(), type(action)))
        # Close dialog on user response
        dialog.connect (&#34;response&#34;, lambda d, r: d.destroy())
        dialog.show()

    def rclick_action(self, action, sss, ttt):
        #print( &#34;rclck_action&#34;, sss, ttt)
        if ttt == 1:
            self.mained.newfile()
        elif ttt == 3:
            self.mained.open()
        elif ttt == 4:
            self.mained.save()
        elif ttt == 5:
            self.mained.save(True)
        elif ttt == 7:
            self.mained.copy()
        elif ttt == 8:
            self.mained.cut()
        elif ttt == 9:
            self.mained.paste()
        elif ttt == 11:
            self.toggle_ro()
        elif ttt == 13:
            self.mained.activate_exit()
        elif ttt == 14:
            self.start_term()
        elif ttt == 15:
            self.start_edit()
        elif ttt == 16:
            self.mained.tts()
        elif ttt == 17:
            pedmisc.exec_test(self, &#34;rc&#34;)
        elif ttt == 18:
            self.start_external([&#34;libreoffice&#34;, &#34;--writer&#34;],
                                        [&#34;libreoffice&#34;, &#34;--writer&#34;])
        else:
            print(&#34;peddoc: Invalid menu item selected&#34;)

    def toggle_ro(self):
        self.readonly = not self.readonly
        self.set_tablabel()
        arrx = [&#34;OFF&#34;, &#34;ON&#34;]
        self.mained.update_statusbar(&#34;Toggled read only to %s&#34; % arrx[self.readonly])

    def start_term(self):
        #print(&#34;Terminal Here&#34;)
        try:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                ret = subprocess.Popen([&#34;putty&#34;])
                #if not ret.returncode:
                #    raise OSError
                #print(&#34;No terminal on windows. (TODO)&#34;)
            else:
                # Stumble until terminal found
                ret = subprocess.Popen([&#34;xfce4-terminal&#34;])
                if ret.returncode:
                    ret = subprocess.Popen([&#34;gnome-terminal&#34;])
                    if ret.returncode:
                        raise OSError
        except:
            print(&#34;Cannot launch terminal&#34;, sys.exc_info())
            pedync.message(&#34;\n   Cannot launch terminal executable \n\n&#34;
                       &#34;              (Please install)&#34;)


    # Pass in two lists, one for linux and one for windows
    def start_external(self, linprog, winprog):

        try:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                ret = subprocess.Popen(winprog)
                #if not ret.returncode:
                #    raise OSError
            else:
                ret = subprocess.Popen(linprog)
                #if not ret.returncode:
                #    raise OSError
        except:
            print(&#34;Cannot launch %s&#34; % str(linprog), sys.exc_info())
            pedync.message(&#34;\n   Cannot launch %s \n\n&#34;  % str(linprog) +
                       &#34;              (Please install)&#34;)

    def start_edit(self):

        old = os.getcwd()
        fdir = os.path.dirname(os.path.realpath(__file__))
        #print(&#34;fdir:&#34;, fdir)
        mydir = os.path.dirname(os.path.join(fdir, &#34;../&#34;))
        #print(&#34;mydir:&#34;, mydir)
        os.chdir(mydir)
        myscript = os.path.realpath(os.path.join(mydir, &#39;pyedpro.py&#39;))
        #print(&#34;myscript:&#34;, myscript)

        ret = 0
        try:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                print(&#34;No exe function on windows. (TODO)&#34;)
            else:
                # Stumble until editor found
                ret = subprocess.Popen([&#34;python3&#34;, myscript])
                if ret.returncode:
                    ret = subprocess.Popen([&#34;python&#34;, myscript])
                    if not ret.returncode:
                        raise OSError
        except:
            print(&#34;Cannot launch editor instance&#34;, sys.exc_info())
            pedync.message(&#34;\n   Cannot launch new editor instance \n\n&#34;)

        # Back to original dir
        os.chdir(os.path.dirname(old))

    def create_menuitem(self, string, action, arg = None):
        rclick_menu = Gtk.MenuItem(string)
        if action:
            rclick_menu.connect(&#34;activate&#34;, action, string, arg)
        rclick_menu.show()
        return rclick_menu

        # Create the menubar and toolbar
        action_group = Gtk.ActionGroup(&#34;DocWindowActions&#34;)
        action_group.add_actions(entries)
        return action_group

    def build_menu(self, window, items):

        self.menu =  Gtk.Menu()
        for aa, bb, cc, dd, ee  in items:
            #print (&#34;menu item&#34;, aa)
            if ee:
                menu_item = Gtk.MenuItem.new_with_mnemonic(
                            &#34;----------------------------&#34;)
                menu_item.set_sensitive(False)
                menu_item.set_size_request(-1, 10)
                pass
            else:
                ttt = str(bb).replace(&#34;&lt;control&gt;&#34;, &#34;CTRL+&#34;)
                ttt = str(ttt).replace(&#34;&lt;alt&gt;&#34;,     &#34;ALT+&#34;)
                ttt = str(ttt).replace(&#34;&lt;shift&gt;&#34;,   &#34;SHIFT+&#34;)
                fff = &#34; &#34; * (15 - len(aa))
                sss = aa + &#34;%s\t%s&#34; % (fff, ttt)
                menu_item = Gtk.MenuItem.new_with_mnemonic(sss)
                menu_item.connect(&#34;activate&#34;, self.rclick_action, aa, dd )

            self.menu.append(menu_item)
        self.menu.show_all()
        return self.menu

    def get_size(self):
        rect = self.get_allocation()
        return rect.width, rect.height

    def get_height(self):
        rect = self.get_allocation()
        return rect.height

    def get_width(self):
        rect = self.get_allocation()
        return rect.width

    def save(self):

        #print (&#34;Saving&#34;, self.fname)
        # Always save params
        self.saveparms()
        strx = &#34;&#34;
        if not self.changed:
            strx = &#34;File is not modified.&#34;
            #self.mained.update_statusbar(strx)
            return

        # Is this file named &#39;untitled&#39;?
        base, ext =  os.path.splitext(pedconfig.conf.UNTITLED)
        base1 = os.path.basename(self.fname)
        base2, ext2 =  os.path.splitext(base1)
        if base2[:len(base)] == base:
            self.file_dlg(Gtk.ResponseType.YES)
        else:
            bn = os.path.basename(self.fname)
            err = self.writeout()
            if  err[0]:
                strx = &#34;Saved &#39;{0:s}&#39;&#34;.format(self.fname)
            else:
                #strx = &#34;Not Saved &#39;{0:s}&#39; {1:s}&#34;.format(bn, err[1])
                strx = &#34;Not Saved &#34;

        if pedconfig.conf.verbose:
            print(strx)
        self.mained.update_statusbar(strx)

    def saveas(self):
        self.file_dlg(Gtk.ResponseType.YES)

    def coloring(self, flag):
        self.colflag = flag
        self.invalidate()

    def showcol(self, flag):
        self.scol = flag
        self.invalidate()

    def hexview(self, flag):
        self.hex = flag
        self.invalidate()

    def flash(self, flag):
        self.bigcaret = flag
        self.invalidate()

    def showtab(self, flag):
        self.stab = flag
        self.scol = flag
        self.invalidate()

    def closedoc(self, noprompt = False):
        strx = &#34;Closing &#39;{0:s}&#39;&#34;.format(self.fname)
        if pedconfig.conf.verbose:
            print(&#34;Closing doc:&#34;, strx)
        self.mained.update_statusbar(strx)
        self.saveparms()

        # Clear treestore(s)
        self.mained.update_treestore([])
        self.mained.update_treestore2([])

        # Add to accounting:
        logentry(&#34;Closed File&#34;, self.start_time, self.fname)

        return self.prompt_save(noprompt)

    # --------------------------------------------------------------------
    # Load file into this buffer, return False on failure

    def loadfile(self, filename, create = False):
        self.fname = filename
        try:
            self.stat = os.stat(self.fname)
        except:
            pass

        #pedync.message(&#34;\n   open / read file:  \n\n&#34;
        #                      &#34;      %s&#34; % self.fname)

        #print(&#34;stat&#34;, self.stat.st_mtime)
        self.start_time = time.time()
        if self.fname == &#34;&#34;:
            strx = &#34;Must specify file name.&#34;
            print(strx)
            self.mained.update_statusbar(strx)
            return False
        try:
            self.text = readfile(self.fname)
        except:
            errr = &#34;Cannot read file &#39;&#34; + self.fname + &#34;&#39;&#34; #, sys.exc_info()
            if pedconfig.conf.verbose:
                print(errr, sys.exc_info())

            #pedync.message(&#34;\n   Cannot open / read file:  \n\n&#34;
            #                  &#34;      %s&#34; % self.fname)

            self.mained.update_statusbar(errr)
            usleep(10)
            return False

        #self.ularr.append((10 ,10, 20))
        mlen = self.calc_maxline()

        # Set up scroll bars
        self.set_maxlinelen(mlen, False)
        self.set_maxlines(len(self.text), False)

        self.loadundo()
        self.saveorg()
        self.savebackup()
        self.loadparms()

        # Add to accounting:
        logentry(&#34;Opened File&#34;, self.start_time, self.fname)

        # Propagate main wndow ref
        pedmenu.mained = self.mained

        self.set_nocol()

        try:
            os.chdir(os.path.dirname(self.fname))
        except:
            print(&#34;Cannot change dir to file&#39;s cwd&#34;, sys.exc_info())

        # Let the system breed
        self.invalidate()
        usleep(10)

        # Color ON?
        self.set_nocol()

        return True

    def calc_maxline(self):
        mlen = 0
        for aa in self.text:
            xlen = len(aa)
            if mlen &lt; xlen:
                mlen = xlen
        #self.maxlinelen = mlen
        return mlen

    # Load per file parms (cursor etc)
    def loadparms(self):
        hhh = hash_name(self.fname)

        self.startxxx  =  pedconfig.conf.sql.get_int(hhh + &#34;/xx&#34;)
        self.startyyy  =  pedconfig.conf.sql.get_int(hhh + &#34;/yy&#34;)
        #print(&#34;got cursor pos:&#34;, self.fname, self.startxxx, self.startyyy)
        # Note: we set cursor on first focus

    # Save per file parms (cursor, fname, etc)
    def  saveparms(self):
        hhh = hash_name(self.fname)
        pedconfig.conf.sql.put(hhh + &#34;/xx&#34;, self.xpos + self.caret[0])
        pedconfig.conf.sql.put(hhh + &#34;/yy&#34;, self.ypos + self.caret[1])
        pedconfig.conf.sql.put(hhh + &#34;/fname&#34;, self.fname)

        if self.tts:
            self.tts.haltspeak = True

        #print  &#34;saveparm&#34;, time.clock() - got_clock

    # Create org backup
    def saveorg(self):
        hhh = hash_name(self.fname) + &#34;.org&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        if not os.path.isfile(xfile):
            err =  writefile(xfile, self.text, &#34;\n&#34;)
            if not err[0]:
                print(&#34;Cannot create (org) backup file&#34;, xfile, sys.exc_info())

   # Create backup
    def savebackup(self):
        hhh = hash_name(self.fname) + &#34;.bak&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            writefile(xfile, self.text, &#34;\n&#34;)
        except:
            sss = &#34;Cannot create backup file&#34; + xfile + sys.exc_info()
            print(sss)

    def prompt_save(self, askname = True):

        # Always save params
        self.saveparms()

        if not self.changed:
            #print &#34;not changed&#34;, self.fname
            return False

        msg = &#34;\nWould you like to save:\n\n  \&#34;%s\&#34; \n&#34; % self.fname
        rp = pedync.yes_no_cancel(&#34;pyedpro: Save File ?&#34;, msg)

        if rp == Gtk.ResponseType.YES:
            if askname:
                self.file_dlg(rp)
            else:
                self.save()
        elif rp == Gtk.ResponseType.NO:
            pass
        elif  rp == Gtk.ResponseType.CANCEL:
            return True
        else:
            print(&#34;warning: invalid response from dialog&#34;)

    def file_dlg(self, resp):
        #print &#34;File dialog&#34;
        if resp == Gtk.ResponseType.YES:
            but =   &#34;Cancel&#34;, Gtk.ResponseType.CANCEL,   \
                            &#34;Save File&#34;, Gtk.ResponseType.OK
            fc = Gtk.FileChooserDialog(&#34;Save file as ... &#34;, None,
                    Gtk.FileChooserAction.SAVE, but)
            #fc.set_do_overwrite_confirmation(True)

            fc.set_current_name(os.path.basename(self.fname))
            fc.set_current_folder(os.path.dirname(self.fname))
            fc.set_default_response(Gtk.ResponseType.OK)
            fc.connect(&#34;response&#34;, self.done_fc)
            fc.run()

    # --------------------------------------------------------------------

    def writeout(self):

        if pedconfig.conf.verbose:
            print(&#34;Saving &#39;&#34;+ self.fname + &#34;&#39;&#34;)

        wasfile = os.access(self.fname, os.R_OK)
        err = writefile(self.fname, self.text, &#34;\n&#34;)
        if err[0]:
            self.set_changed(False)

        if not wasfile:
            # Change access/ownership to group write
            try:
                ostat = os.stat(self.fname)
                os.chmod(self.fname, ostat.st_mode | stat.S_IWGRP)
            except:
                print(&#34;Cannot change group write on &#39;%s&#39;&#34; % self.fname,  sys.exc_info())

        self.saveundo();  self.saveparms(); self.set_tablabel()

        # Add to accounting:
        logentry(&#34;Wrote File&#34;, self.start_time, self.fname)

        # Update stat info
        self.stat = os.stat(self.fname)

        return err

    def delundo(self):
        self.undoarr = []; self.redoarr = []
        # Remove file
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        fh = open(xfile, &#34;w&#34;)
        fh.close()
        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        fh = open(xfile, &#34;w&#34;)
        fh.close()

    def saveundo(self):
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;wb&#34;)
            pickle.dump(self.undoarr, fh)
            fh.close()
        except:
            print(&#34;Cannot save undo file&#34;, sys.exc_info())
            pedutil.put_exception(&#34;undo&#34;)


        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;wb&#34;)
            pickle.dump(self.redoarr, fh)
            fh.close()
        except:
            print(&#34;Cannot save redo file&#34;, sys.exc_info())

    def loadundo(self):
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;rb&#34;)
            try:
                self.undoarr = pickle.load(fh)
            except:
                pass
            fh.close()
        except:
            pass
            # Ignore it, not all files will have undo
            #print( &#34;Cannot load undo file&#34;, xfile)
        self.initial_undo_size = len(self.undoarr)

        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;rb&#34;)
            try:
                self.redoarr = pickle.load(fh)
            except:
                pass
            fh.close()
        except:
            pass
            # Ignore it, not all files will have redo
            #print( &#34;Cannot load redo file&#34;, xfile)
        self.initial_redo_size = len(self.redoarr)

    def done_fc(self, win, resp):
        #print( &#34;done_fc&#34;, win, resp)
        if resp == Gtk.ResponseType.OK:
            fname = win.get_filename()
            if not fname:
                print(&#34;Must have filename&#34;)
            else:
                if os.path.isfile(fname):
                    dialog = Gtk.MessageDialog(None, Gtk.DIALOG_DESTROY_WITH_PARENT,
                    Gtk.MESSAGE_QUESTION, Gtk.ButtonsType.YES_NO,
                    &#34;\nWould you like overwrite file:\n\n  \&#34;%s\&#34; \n&#34; % fname)
                    dialog.set_title(&#34;Overwrite file ?&#34;)
                    dialog.set_default_response(Gtk.ResponseType.YES)
                    dialog.connect(&#34;response&#34;, self.overwrite_done, fname, win)
                    dialog.run()
                else:
                    win.destroy()
                    self.fname = fname
                    self.writeout()

    def overwrite_done(self, win, resp, fname, win2):
        #print( &#34;overwrite done&#34;, resp)
        if resp == Gtk.ResponseType.YES:
            self.fname = fname
            self.writeout()
            self.set_nocol()
            win2.destroy()
        win.destroy()

    # --------------------------------------------------------------------
    # Turn off coloring if not python / c / sh / perl / header(s)

    def set_nocol(self):
        colflag = False
        ext = os.path.splitext(self.fname)[1].lower()
        for aa in pedconfig.conf.color_on:
            if ext == aa:
                colflag = True
                break
        self.colflag = colflag


    def do_chores(self):

        #print( &#34;do_chores&#34;)

        if  not self.needscan:
            return

        self.needscan = False

        # Scan left pane
        pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
        pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

    def set_changed(self, flag):
        old = self.changed
        self.changed = flag
        # Exec actions:
        if old != self.changed:
            #print( &#34;Setting changed on &#34;, self.fname)
            self.set_tablabel()

    def set_tablabel(self):
        # Find me in tabs
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            if ppp.area == self:
                self._setlabel(ppp)
                break
            cnt += 1

    # Gdk.EventButton
    def doclabel_callb(self, widg, event):
        #print(&#34;doclabel_callb&#34;, event.button, event.type)
        if event.button == 3:
            #print(&#34;Right click&#34;, self.fname)
            self.poprclick3(event)

    def _setlabel(self, ppp):
        # Set label to tab
        ss = shortenstr(os.path.basename(self.fname), 24)
        if  self.changed:
            str2 = &#34;* &#34; + ss + &#34;  &#34;
        else:
            str2 = &#34;&#34; + ss + &#34;  &#34;

        if  self.readonly:
            str3 = &#34;ro &#34; + str2
        else:
            str3 = &#34;&#34; + str2

        if  self.diffmode == 1:
            str4 = &#34;Diff/Src &#34; + str3
        elif  self.diffmode == 2:
            str4 = &#34;Diff/Tar &#34; + str3
        else:
            str4 = &#34;&#34; + str3

        label = Gtk.Label.new(str4)
        label.set_tooltip_text(self.fname)
        label.set_single_line_mode(True)

        eb = Gtk.EventBox(); eb.add(label)
        eb.connect_after(&#34;button-press-event&#34;, self.doclabel_callb)
        eb.set_above_child(True)

        image = Gtk.Image()
        image.set_from_stock(Gtk.STOCK_CLOSE, Gtk.IconSize.MENU)
        butt = Gtk.Button();  butt.add(image)
        butt.set_focus_on_click(False)
        butt.set_relief( Gtk.ReliefStyle.NONE)
        rc = butt.get_modifier_style()
        #rc.xthickness = 1; rc.ythickness = 1
        #butt.modify_style(rc)

        butt.connect(&#34;clicked&#34;, self.close_button)
        butt.set_tooltip_text(&#34;Close &#39;%s&#39;&#34; % os.path.basename(self.fname))
        hbox = Gtk.HBox()

        hbox.pack_start(eb, 0, 0, 0)
        hbox.pack_start(butt, 0, 0, 0)
        hbox.show_all()
        self.notebook.set_tab_label(ppp, hbox)

    def close_button(self, arg1):
        #print( &#34;close_button&#34;, arg1)
        # Select me first
        self.mained.closedoc(self)

    # --------------------------------------------------------------------
    def savemacro(self):
        #print( &#34;Savemacro&#34;)

        fname = &#34;untitled.mac&#34;
        xfile = pedconfig.conf.config_dir + &#34;/macros/&#34; + fname
        old = os.getcwd()
        try:
            os.chdir(os.path.dirname(xfile))
        except:
            print(&#34;No macros directory&#34;, sys.exc_info())

        but =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Save Macro&#34;, Gtk.ButtonsType.OK
        fc = Gtk.FileChooserDialog(&#34;Save Macro&#34;, None, Gtk.FileChooserAction.SAVE, \
            but)

        fc.set_current_folder(xfile)
        fc.set_current_name(os.path.basename(xfile))
        fc.set_default_response(Gtk.ButtonsType.OK)
        fc.connect(&#34;response&#34;, self.done_mac_fc, old)
        fc.run()

    def done_mac_fc(self, win, resp, old):
        #print(  &#34;done_mac_fc&#34;, resp)
        # Back to original dir
        os.chdir(os.path.dirname(old))
        if resp == Gtk.ButtonsType.OK:
            try:
                fname = win.get_filename()
                if not fname:
                    print(&#34;Must have filename&#34;)
                else:
                    fh = open(fname, &#34;wb&#34;)
                    pickle.dump(self.recarr, fh)
                    fh.close()
            except:
                print(&#34;Cannot save macro file&#34;, sys.exc_info())

        win.destroy()

    def loadmacro(self):
        #print( &#34;Loadmacro&#34;)

        xfile = pedconfig.conf.config_dir + &#34;/macros/&#34;
        old = os.getcwd()
        try:
            os.chdir(os.path.dirname(xfile))
        except:
            print(&#34;No macros directory&#34;, sys.exc_info())

        but =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Load Macro&#34;, Gtk.ButtonsType.OK
        fc = Gtk.FileChooserDialog(&#34;Load Macro&#34;, None, Gtk.FileChooserAction.OPEN, \
            but)

        fc.set_current_folder(xfile)
        #fc.set_current_folder(old)
        fc.set_default_response(Gtk.ButtonsType.OK)
        fc.connect(&#34;response&#34;, self.done_mac_open_fc, old)
        fc.run()

    def done_mac_open_fc(self, win, resp, old):
        #print(  &#34;done_mac_fc&#34;, resp)

        # Back to original dir
        os.chdir(os.path.dirname(old))
        if resp == Gtk.ButtonsType.OK:
            try:
                fname = win.get_filename()
                if not fname:
                    print(&#34;Must have filename&#34;)
                else:
                    fh = open(fname, &#34;rb&#34;)
                    self.recarr = pickle.load(fh)
                    fh.close()
            except:
                print(&#34;Cannot load macro file&#34;, sys.exc_info())

        win.destroy()

    # Refresh current search buffer
    def search_again(self):
        if len(self.accum) == 0:
            return

        if self.src_changed:
            self.search(self.srctxt, self.regex, self.boolcase, self.boolregex)

    # --------------------------------------------------------------------
    def search(self, srctxt, regex, boolcase, boolregex):

        # Remember old settings:
        self.srctxt = srctxt;       self.regex = regex
        self.boolcase = boolcase;   self.boolregex = boolregex
        self.src_changed = False

        self.accum = []

        curr = self.caret[1] + self.ypos
        was = -1; cnt = 0; cnt2 = 0

        for line in self.text:
            # Search one line for multiple matches
            mmm = src_line(line, cnt, srctxt, regex, boolcase, boolregex)

            if cnt &gt; curr and was == -1:
                was = cnt2
            if  mmm:
                cnt2 += 1
                for sss in mmm:
                    self.accum.append(sss)
            if cnt % 100 == 0:
                self.mained.update_statusbar(&#34;Searching at %d&#34; % cnt)
                usleep(1)
            cnt += 1
        return was, cnt2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gi.repository.Gtk.DrawingArea</li>
<li>gi.overrides.Gtk.Widget</li>
<li>gi.repository.Gtk.Widget</li>
<li>gi.repository.GObject.InitiallyUnowned</li>
<li>gi.overrides.GObject.Object</li>
<li>gi.repository.GObject.Object</li>
<li>gi._gi.GObject</li>
<li>gi.repository.Atk.ImplementorIface</li>
<li>gi.repository.Gtk.Buildable</li>
<li>gobject.GInterface</li>
<li>pedlib.peddraw.peddraw</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="peddoc_diff.pedDoc.activate_action"><code class="name flex">
<span>def <span class="ident">activate_action</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def activate_action(self, action):
    dialog = Gtk.MessageDialog(self, Gtk.DIALOG_DESTROY_WITH_PARENT,
        Gtk.ButtonsType.INFO, Gtk.ButtonsType.CLOSE,
        &#39;You activated action: &#34;%s&#34; of type &#34;%s&#34;&#39; % (action.get_name(), type(action)))
    # Close dialog on user response
    dialog.connect (&#34;response&#34;, lambda d, r: d.destroy())
    dialog.show()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.addict"><code class="name flex">
<span>def <span class="ident">addict</span></span>(<span>self, widget, string, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addict(self, widget, string, arg):
    #print( &#34;addict&#34;, arg)
    if not pedspell.append_user_dict(self, arg):
        self.mained.update_statusbar(&#34;Cannot append to user dict&#34;)
    else:
        self.mained.update_statusbar(&#34;Added &#39;%s&#39; to user dict&#34; % arg)
        self.newword = True

    # Force new spell check
    self.fired += 1
    GLib.timeout_add(300, self.keytime)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.area_button"><code class="name flex">
<span>def <span class="ident">area_button</span></span>(<span>self, area, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_button(self, area, event):

    self.lastevent = event

    if pedconfig.conf.pgdebug &gt; 5:
        print( &#34;Button press  &#34;, event.type, &#34; x=&#34;, event.x, &#34; y=&#34;, event.y)

    event.x = int(event.x)
    event.y = int(event.y)

    if  event.type == Gdk.EventType.BUTTON_PRESS:
        if event.button == 1:
            #print( &#34;Left Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
            self.mx = int(event.x); self.my = int(event.y)
            xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;
            offs = calc_tabs2(line, xxx)

            #print( &#34;offs, xxx&#34;, offs, xxx)
            self.set_caret(self.xpos + xxx - (offs - xxx),
                                 self.ypos + yyy )
            #rp = xxx + self.xpos
            #print( &#34;xpos&#34;, self.xpos, &#34;xxx&#34;, xxx, &#34;rp&#34;, rp)
            #print( line)
            #print( &#34;line part&#34;, &#34;&#39;&#34; + line[rp:rp+8] + &#34;&#39;&#34;)

            # Erase selection
            if self.xsel != -1:
                self.clearsel()

            self.fired += 1
            GLib.timeout_add(300, self.keytime)

        if event.button == 3:
            #print( &#34;Right Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
            flag = False; xx = 0; yy = 0; zz = 0
            if self.spell:
                yyy = int(self.ypos + self.get_height() / self.cyy)
                for xaa, ybb, lcc in self.ularr:
                    # Look within visible range
                    if ybb &gt;= self.ypos and ybb &lt; yyy:
                        ybb -= self.ypos
                        xaa -= self.xpos; lcc -= self.xpos
                        xaa *= self.cxx ; ybb *= self.cyy
                        lcc *= self.cxx
                        yy2 = ybb + self.cyy

                        if self.intersect(xaa, ybb, lcc, yy2, event):
                            xx = int(xaa / self.cxx + self.xpos)
                            yy = int(ybb / self.cyy + self.ypos)
                            zz = int(lcc / self.cxx + self.xpos)
                            flag = True
            if flag:
                line = self.text[yy]
                #print( &#34;Spell delimit: &#39;&#34; + line[xx:zz] + &#34;&#39;&#34;)
                self.xsel = xx;
                self.xsel2 = zz

                self.ysel = self.ysel2 = yy
                self.spellstr = line[int(xx):int(zz)]
                self.popspell(area, event, self.spellstr)
            else:
                if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                    if self.xsel == -1:
                        yyy = int(event.y / self.cyy + self.ypos)
                        xxx = int(event.x / self.cxx + self.xpos)
                        line = self.text[yyy]
                        self.xsel, self.xsel2 = selasci2(line, xxx, &#34;_-&#34;)
                        self.ysel = self.ysel2 = yyy
                    else:
                        line = self.text[self.ysel]

                    strx = line[int(self.xsel):int(self.xsel2)]
                    #print(&#34;&#39;&#34; + strx + &#34;&#39;&#34;)
                    if strx:
                        self.poprclick2(area, event, strx)
                else:
                    self.poprclick(area, event)

    elif  event.type == Gdk.EventType.BUTTON_RELEASE:
        #print( &#34;button release&#34;, event.button)
        self.mx = -1; self.my = -1
        self.scrtab = False
        ttt = &#34;Release&#34;
        xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
        # Find current pos, gather tabs, adjust back
        try:
            line = self.text[self.ypos + yyy]
        except:
            line = &#34;&#34;
        offs = calc_tabs2(line, xxx)
        self.set_caret(self.xpos + xxx - (offs - xxx),
                                 self.ypos + yyy )

    elif  event.type == Gdk.EventType._2BUTTON_PRESS:

        if pedconfig.conf.pgdebug &gt; 2:
            print (&#34;Double click %.2f %.2f&#34; % (event.x, event.y))

        self.mx = int(event.x); self.my = int(event.y)
        xxx = int(event.x / self.cxx)
        yyy = int(event.y / self.cyy)

        # Find current pos, gather tabs, adjust back
        try:
            line = self.text[self.ypos + yyy]
        except:
            line = &#34;&#34;

        # Find current pos on tabbed line
        offs = calc_tabs2(line, xxx)
        self.set_caret(self.xpos + xxx - (offs - xxx), self.ypos + yyy )
        #self.set_caret(len(xxx2), yyy)

        # Erase selection
        if self.xsel != -1:
            self.clearsel()

        # Select word
        if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
            pedconfig.conf.keyh.acth.ctrl_b(self)
        else:
            pedconfig.conf.keyh.acth.alt_v(self)
        # Copy to clip

        if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
            pedconfig.conf.keyh.acth.ctrl_c(self)

    else:
        print(&#34;Unexpected mouse op.&#34;)

    self.grab_focus()
    return True</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.area_enter"><code class="name flex">
<span>def <span class="ident">area_enter</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_enter(self, widget, event):
    #print( &#34;area_enter&#34;)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.area_focus"><code class="name flex">
<span>def <span class="ident">area_focus</span></span>(<span>self, area, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_focus(self, area, event):
    #print( &#34;ped doc area focus&#34;, event)
    return False</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.area_key"><code class="name flex">
<span>def <span class="ident">area_key</span></span>(<span>self, area, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_key(self, area, event):

    #print (&#34;area_key&#34;, event)
    # Restart timer ticks
    pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
    pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

    # Maintain a count of events, only fire only fire on the last one
    self.fired += 1
    GLib.timeout_add(300, self.keytime)
    # The actual key handler
    self.keyh.handle_key(self, area, event)

    #if event.type == Gdk.KEY_RELEASE:
    #    self.source_id = GObject.idle_add(self.idle_callback)

    # We handled it
    return True</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.area_leave"><code class="name flex">
<span>def <span class="ident">area_leave</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_leave(self, widget, event):
    #print( &#34;area_leave&#34;)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.area_motion"><code class="name flex">
<span>def <span class="ident">area_motion</span></span>(<span>self, area, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_motion(self, area, event):
    #print (&#34;motion event&#34;, event.state, event.x, event.y)
    if event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
        #print( &#34;motion event butt 1&#34;, event.state, event.x, event.y)
        if self.xsel == -1 and self.scrtab != True:
            begsel = False
            # Horiz drag - regular sel
            if abs(event.x - self.mx) &gt; DRAGTRESH:
                self.colsel = False; begsel = True

            if begsel:
                self.xsel = self.xsel2 = self.xpos + self.caret[0]
                self.ysel = self.ysel2 = self.ypos + self.caret[1]
                #print( &#34;colsel xsel, ysel&#34;, self.colsel, self.xsel, self.ysel)
            if self.scrtab == False:
                # Vert drag - colsel
                if abs(event.y - self.my) &gt; DRAGTRESH:
                    self.scrtab  = True
                    self.colsel = True

        if self.scrtab  == True:
            self.xsel = self.xsel2 = self.xpos + self.caret[0]
            self.ysel = self.ysel2 = self.ypos + self.caret[1]
            xidx = self.xpos + self.caret[0]
            yidx = self.ypos + self.caret[1]
            if  event.y &gt;  self.my:
                yidx += 1
            if  event.y &gt;  self.my:
                yidx -= 1
            self.set_caret(xidx, yidx)
            self.my = event.y

        if self.xsel != -1:
            # Already selected, mark
            self.ysel2 = self.pix2ypos(event.y)
            if self.ysel2 &lt; self.ysel:
                self.xsel    = self.pix2xpos(event.x)
            else:
                self.xsel2 = self.pix2xpos(event.x)

        self.invalidate()

    if event.state &amp; Gdk.ModifierType.SHIFT_MASK and \
        event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
        #print( &#34;Shift Drag&#34;, event.x, event.y)
        pass
    pass</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.build_menu"><code class="name flex">
<span>def <span class="ident">build_menu</span></span>(<span>self, window, items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_menu(self, window, items):

    self.menu =  Gtk.Menu()
    for aa, bb, cc, dd, ee  in items:
        #print (&#34;menu item&#34;, aa)
        if ee:
            menu_item = Gtk.MenuItem.new_with_mnemonic(
                        &#34;----------------------------&#34;)
            menu_item.set_sensitive(False)
            menu_item.set_size_request(-1, 10)
            pass
        else:
            ttt = str(bb).replace(&#34;&lt;control&gt;&#34;, &#34;CTRL+&#34;)
            ttt = str(ttt).replace(&#34;&lt;alt&gt;&#34;,     &#34;ALT+&#34;)
            ttt = str(ttt).replace(&#34;&lt;shift&gt;&#34;,   &#34;SHIFT+&#34;)
            fff = &#34; &#34; * (15 - len(aa))
            sss = aa + &#34;%s\t%s&#34; % (fff, ttt)
            menu_item = Gtk.MenuItem.new_with_mnemonic(sss)
            menu_item.connect(&#34;activate&#34;, self.rclick_action, aa, dd )

        self.menu.append(menu_item)
    self.menu.show_all()
    return self.menu</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.builddoc"><code class="name flex">
<span>def <span class="ident">builddoc</span></span>(<span>self, ppp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def builddoc(self, ppp):
    if ppp.area.diffmode == 1:
        got_src = True
    if ppp.area.diffmode == 2:
        got_targ = True</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.calc_maxline"><code class="name flex">
<span>def <span class="ident">calc_maxline</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_maxline(self):
    mlen = 0
    for aa in self.text:
        xlen = len(aa)
        if mlen &lt; xlen:
            mlen = xlen
    #self.maxlinelen = mlen
    return mlen</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.clearsel"><code class="name flex">
<span>def <span class="ident">clearsel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearsel(self):
    old = self.xsel
    self.xsel  =  self.ysel = -1
    self.xsel2 =  self.ysel2 = -1
    if old != -1:
        self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.close_button"><code class="name flex">
<span>def <span class="ident">close_button</span></span>(<span>self, arg1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_button(self, arg1):
    #print( &#34;close_button&#34;, arg1)
    # Select me first
    self.mained.closedoc(self)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.closedoc"><code class="name flex">
<span>def <span class="ident">closedoc</span></span>(<span>self, noprompt=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closedoc(self, noprompt = False):
    strx = &#34;Closing &#39;{0:s}&#39;&#34;.format(self.fname)
    if pedconfig.conf.verbose:
        print(&#34;Closing doc:&#34;, strx)
    self.mained.update_statusbar(strx)
    self.saveparms()

    # Clear treestore(s)
    self.mained.update_treestore([])
    self.mained.update_treestore2([])

    # Add to accounting:
    logentry(&#34;Closed File&#34;, self.start_time, self.fname)

    return self.prompt_save(noprompt)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.coloring"><code class="name flex">
<span>def <span class="ident">coloring</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coloring(self, flag):
    self.colflag = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.configure_event"><code class="name flex">
<span>def <span class="ident">configure_event</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_event(self, widget, event):
    #print( &#34;configure_event&#34;, event)
    #self.grab_focus()
    #self.width = 0; self.height = 0
    #self.invalidate()
    #print( self, event)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.create_menuitem"><code class="name flex">
<span>def <span class="ident">create_menuitem</span></span>(<span>self, string, action, arg=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_menuitem(self, string, action, arg = None):
    rclick_menu = Gtk.MenuItem(string)
    if action:
        rclick_menu.connect(&#34;activate&#34;, action, string, arg)
    rclick_menu.show()
    return rclick_menu

    # Create the menubar and toolbar
    action_group = Gtk.ActionGroup(&#34;DocWindowActions&#34;)
    action_group.add_actions(entries)
    return action_group</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.delundo"><code class="name flex">
<span>def <span class="ident">delundo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delundo(self):
    self.undoarr = []; self.redoarr = []
    # Remove file
    hhh = hash_name(self.fname) + &#34;.udo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    fh = open(xfile, &#34;w&#34;)
    fh.close()
    hhh = hash_name(self.fname) + &#34;.rdo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    fh = open(xfile, &#34;w&#34;)
    fh.close()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.diffx"><code class="name flex">
<span>def <span class="ident">diffx</span></span>(<span>self, srctxt, targtxt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diffx(self, srctxt, targtxt):

    #self.mained.diffpane.area.text.append(&#34;Diff started.&#34;)

    for aa in range(len(targtxt)):
        if srctxt[aa] == targtxt[aa]:
            self.mained.diffpane.area.text.append(targtxt[aa])
        else:
            self.mained.diffpane.area.text.append(&#34; --- &#34;)

    self.mained.diffpane.area.xpos = self.xpos
    self.mained.diffpane.area.ypos = self.ypos
    self.mained.diffpane.area.gotoxy(
                     self.xpos + self.caret[0], self.ypos + self.caret[1])
    self.mained.diffpane.area.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.do_chores"><code class="name flex">
<span>def <span class="ident">do_chores</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_chores(self):

    #print( &#34;do_chores&#34;)

    if  not self.needscan:
        return

    self.needscan = False

    # Scan left pane
    pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
    pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.doclabel_callb"><code class="name flex">
<span>def <span class="ident">doclabel_callb</span></span>(<span>self, widg, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doclabel_callb(self, widg, event):
    #print(&#34;doclabel_callb&#34;, event.button, event.type)
    if event.button == 3:
        #print(&#34;Right click&#34;, self.fname)
        self.poprclick3(event)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.done_fc"><code class="name flex">
<span>def <span class="ident">done_fc</span></span>(<span>self, win, resp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done_fc(self, win, resp):
    #print( &#34;done_fc&#34;, win, resp)
    if resp == Gtk.ResponseType.OK:
        fname = win.get_filename()
        if not fname:
            print(&#34;Must have filename&#34;)
        else:
            if os.path.isfile(fname):
                dialog = Gtk.MessageDialog(None, Gtk.DIALOG_DESTROY_WITH_PARENT,
                Gtk.MESSAGE_QUESTION, Gtk.ButtonsType.YES_NO,
                &#34;\nWould you like overwrite file:\n\n  \&#34;%s\&#34; \n&#34; % fname)
                dialog.set_title(&#34;Overwrite file ?&#34;)
                dialog.set_default_response(Gtk.ResponseType.YES)
                dialog.connect(&#34;response&#34;, self.overwrite_done, fname, win)
                dialog.run()
            else:
                win.destroy()
                self.fname = fname
                self.writeout()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.done_mac_fc"><code class="name flex">
<span>def <span class="ident">done_mac_fc</span></span>(<span>self, win, resp, old)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done_mac_fc(self, win, resp, old):
    #print(  &#34;done_mac_fc&#34;, resp)
    # Back to original dir
    os.chdir(os.path.dirname(old))
    if resp == Gtk.ButtonsType.OK:
        try:
            fname = win.get_filename()
            if not fname:
                print(&#34;Must have filename&#34;)
            else:
                fh = open(fname, &#34;wb&#34;)
                pickle.dump(self.recarr, fh)
                fh.close()
        except:
            print(&#34;Cannot save macro file&#34;, sys.exc_info())

    win.destroy()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.done_mac_open_fc"><code class="name flex">
<span>def <span class="ident">done_mac_open_fc</span></span>(<span>self, win, resp, old)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done_mac_open_fc(self, win, resp, old):
    #print(  &#34;done_mac_fc&#34;, resp)

    # Back to original dir
    os.chdir(os.path.dirname(old))
    if resp == Gtk.ButtonsType.OK:
        try:
            fname = win.get_filename()
            if not fname:
                print(&#34;Must have filename&#34;)
            else:
                fh = open(fname, &#34;rb&#34;)
                self.recarr = pickle.load(fh)
                fh.close()
        except:
            print(&#34;Cannot load macro file&#34;, sys.exc_info())

    win.destroy()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.draw_event"><code class="name flex">
<span>def <span class="ident">draw_event</span></span>(<span>self, pdoc, cr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_event(self, pdoc, cr):

    self.hhh = self.get_height();  self.www = self.get_width()
    self.xlen = len(self.text)

    ctx = self.get_style_context()
    fg_color = ctx.get_color(Gtk.StateFlags.NORMAL)
    #bg_color = ctx.get_background_color(Gtk..NORMAL)

    # Paint white, ignore system BG
    #cr.set_source_rgba(255, 255, 255)
    # Paint prescribed color
    if self.readonly:
        # Slightly darker / lighter
        newcol =  list(self.bgcolor)
        for aa in range(len(newcol)):
            if newcol[aa] &gt; 0.5: newcol[aa] -= .1
            else: newcol[aa] += .2
        cr.set_source_rgba(*list(newcol))
    else:
        cr.set_source_rgba(*list(self.bgcolor))

    cr.rectangle( 0, 0, self.www, self.hhh)
    cr.fill()

    # Pre set for drawing
    #cr.set_source_rgba(*list(fg_color))
    # Paint prescribed color
    cr.set_source_rgba(*list(self.fgcolor))

    cr.move_to(0, 0)
    self.layout = PangoCairo.create_layout(cr)
    self.layout.set_font_description(self.fd)

    self.draw_maintext(cr)

    if not self.hex:
        # Do the text drawing in stages ...
        self.draw_selection(cr)
        self.draw_syntax(cr)
        self.draw_clsyntax(cr)
        self.draw_comments(cr)
        self.draw_spellerr(cr)

    if self.startxxx != -1:
        self.gotoxy(self.startxxx, self.startyyy)
        self.startxxx = -1; self.startyyy = -1

    self.draw_caret(cr)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.file_dlg"><code class="name flex">
<span>def <span class="ident">file_dlg</span></span>(<span>self, resp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_dlg(self, resp):
    #print &#34;File dialog&#34;
    if resp == Gtk.ResponseType.YES:
        but =   &#34;Cancel&#34;, Gtk.ResponseType.CANCEL,   \
                        &#34;Save File&#34;, Gtk.ResponseType.OK
        fc = Gtk.FileChooserDialog(&#34;Save file as ... &#34;, None,
                Gtk.FileChooserAction.SAVE, but)
        #fc.set_do_overwrite_confirmation(True)

        fc.set_current_name(os.path.basename(self.fname))
        fc.set_current_folder(os.path.dirname(self.fname))
        fc.set_default_response(Gtk.ResponseType.OK)
        fc.connect(&#34;response&#34;, self.done_fc)
        fc.run()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.flash"><code class="name flex">
<span>def <span class="ident">flash</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flash(self, flag):
    self.bigcaret = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.focus_in_cb"><code class="name flex">
<span>def <span class="ident">focus_in_cb</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus_in_cb(self, widget, event):
    #print (&#34;focus_in_cb&#34;)
    self.focus = True

    try:
        os.chdir(os.path.dirname(self.fname))
        xstat = os.stat(self.fname)
        if not self.readonly:
            #print(self.fname, &#34;stat&#34;, self.stat.st_mtime, &#34;xstat&#34;, xstat.st_mtime)
            if self.stat.st_mtime !=  xstat.st_mtime:
                rrr = pedync.yes_no_cancel(&#34;File changed outside PyEdPro&#34;,
                    &#34;&#39;%s&#39;\n&#34; \
                    &#34;changed outside PyEdPro.&#34; \
                    &#34;Reload?&#34; % self.fname, False)
                if rrr == Gtk.ResponseType.YES:
                    print(&#34;Reloading&#34;)
                    self.savebackup()
                    self.loadfile(self.fname)

        # Update stat info
        self.stat = xstat
    except:
        #pedutil.put_exception(&#34;cmp mtime&#34;)
        pass

    self.update_bar2()
    self.needscan = True
    self.do_chores()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.focus_out_cb"><code class="name flex">
<span>def <span class="ident">focus_out_cb</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus_out_cb(self, widget, event):
    #print( &#34;focus_out_cb&#34;, widget, event)
    self.focus = False</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.get_height"><code class="name flex">
<span>def <span class="ident">get_height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_height(self):
    rect = self.get_allocation()
    return rect.height</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.get_height_char"><code class="name flex">
<span>def <span class="ident">get_height_char</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_height_char(self):
    return self.get_height()  / self.cyy</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self):
    rect = self.get_allocation()
    return rect.width, rect.height</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.get_width"><code class="name flex">
<span>def <span class="ident">get_width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width(self):
    rect = self.get_allocation()
    return rect.width</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.get_width_char"><code class="name flex">
<span>def <span class="ident">get_width_char</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width_char(self):
    return self.get_width() / self.cxx</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.gotoxy"><code class="name flex">
<span>def <span class="ident">gotoxy</span></span>(<span>self, xx, yy, sel=None, mid=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gotoxy(self, xx, yy, sel = None, mid = False):

    #print (&#34;gotoxy&#34;, xx, yy)

    # Contain
    ylen = len(self.text)
    xx2 = max(xx, 0);  yy2 = max(yy, 0)
    xx2 = min(xx, self.maxlinelen);  yy2 = min(yy, ylen)

    if sel:
        self.xsel = xx2; self.xsel2 = xx2 + sel
        self.ysel = yy2; self.ysel2 = yy2
        self.invalidate()

    if mid:
        self.set_caret_middle(xx, yy)
    else:
        self.set_caret(xx, yy)

    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.grab_focus_cb"><code class="name flex">
<span>def <span class="ident">grab_focus_cb</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grab_focus_cb(self, widget):
    #print( &#34;grab_focus_cb&#34;, widget)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.hexview"><code class="name flex">
<span>def <span class="ident">hexview</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hexview(self, flag):
    self.hex = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.hscroll_cb"><code class="name flex">
<span>def <span class="ident">hscroll_cb</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hscroll_cb(self, widget):
    #print( &#34;hscroll_cb&#34;, widget.get_value())
    # Skip one callback
    if self.honeshot:
        self.honeshot = False; return
    xidx = int(widget.get_value())

    #print( &#34;hscroll_cb ok&#34;, widget.get_value())
    self.set_caret(xidx, self.ypos + self.caret[1])
    self.invalidate()


    #print( &#34;vscroll_cb&#34;, widget.get_value())
    # Skip one callback
    if self.oneshot:
        self.oneshot = False; return
    #print( &#34;vscroll_cb ok&#34;, widget.get_value())
    yidx = int(widget.get_value())
    self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.idle_callback"><code class="name flex">
<span>def <span class="ident">idle_callback</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idle_callback(self):
    #print( &#34;Idle callback&#34;)
    GLib.source_remove(self.source_id)
    try:
        if self.changed:
            hhh = hash_name(self.fname) + &#34;.sav&#34;
            xfile = pedconfig.conf.data_dir + os.sep + hhh
            err = writefile(xfile, self.text, &#34;\n&#34;)
            if err[0]:
                strx = &#34;Backed up file &#39;{0:s}&#39;&#34;.format(xfile)
            else:
                strx = &#34;Cannot back up file &#39;{0:s}&#39; {1:s}&#34;.format(xfile, err[1])

            self.mained.update_statusbar(strx)
    except:
        print(&#34;Exception in idle handler&#34;, sys.exc_info())</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.idle_callback2"><code class="name flex">
<span>def <span class="ident">idle_callback2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idle_callback2(self):
    #print( &#34;Idle callback2&#34;)
    GLib.source_remove(self.source_id2)
    try:
        run_async_time(self)
    except:
        print(&#34;Exception in async handler&#34;, sys.exc_info())</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.idle_queue"><code class="name flex">
<span>def <span class="ident">idle_queue</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idle_queue(func):
    self.queue.append(func)
    #print( queue)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.intersect"><code class="name flex">
<span>def <span class="ident">intersect</span></span>(<span>self, xx, yy, xx2, yy2, event)</span>
</code></dt>
<dd>
<div class="desc"><p>intersect(self, area:Gdk.Rectangle) -&gt; bool, intersection:Gdk.Rectangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect(self, xx, yy, xx2, yy2, event):
    # Does X intersect?
    if event.x &gt; xx and event.x &lt; xx2:
        #print( &#34;x inter&#34;, xaa, lcc)
        # Does Y intersect?
        if event.y &gt; yy and event.y &lt; yy2:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.inval_line"><code class="name flex">
<span>def <span class="ident">inval_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inval_line(self):
    rect = Gdk.Rectangle()
    xx = self.caret[0] * self.cxx
    yy = self.caret[1] * self.cyy
    ww = self.get_width()
    hh = self.cyy
    #self.invalidate(rect)
    xx = 0
    self.queue_draw_area(xx, yy, ww, hh)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.invalidate"><code class="name flex">
<span>def <span class="ident">invalidate</span></span>(<span>self, rect=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invalidate(self, rect = None):
    #print( &#34;Invalidate:&#34;, rect)
    if rect == None:
        self.queue_draw()
    else:
        self.queue_draw_area(rect.x, rect.y,
                        rect.width, rect.height)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.iterdocs"><code class="name flex">
<span>def <span class="ident">iterdocs</span></span>(<span>self, callb, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterdocs(self, callb, arg):
    nn = self.notebook.get_n_pages(); cnt = 0
    while True:
        if cnt &gt;= nn: break
        ppp = self.notebook.get_nth_page(cnt)
        #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
        callb(ppp.area, arg)
        cnt += 1</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.keytime"><code class="name flex">
<span>def <span class="ident">keytime</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keytime(self):
    #print( &#34;keytime raw&#34;, time.time(), self.fired)
    if self.fired ==  1:
        #print( &#34;keytime&#34;, time.time(), self.fired)
        pedspell.spell(self, self.spellmode)
        self.walk_func()
    self.fired -= 1

    # Track this buffer
    if self.diffmode == 2:
        self.mained.diffpane.area.xpos = self.xpos
        self.mained.diffpane.area.ypos = self.ypos
        self.mained.diffpane.area.set_caret(self.xpos + self.caret[0],
                                                    self.ypos + self.caret[1])</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.loadfile"><code class="name flex">
<span>def <span class="ident">loadfile</span></span>(<span>self, filename, create=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadfile(self, filename, create = False):
    self.fname = filename
    try:
        self.stat = os.stat(self.fname)
    except:
        pass

    #pedync.message(&#34;\n   open / read file:  \n\n&#34;
    #                      &#34;      %s&#34; % self.fname)

    #print(&#34;stat&#34;, self.stat.st_mtime)
    self.start_time = time.time()
    if self.fname == &#34;&#34;:
        strx = &#34;Must specify file name.&#34;
        print(strx)
        self.mained.update_statusbar(strx)
        return False
    try:
        self.text = readfile(self.fname)
    except:
        errr = &#34;Cannot read file &#39;&#34; + self.fname + &#34;&#39;&#34; #, sys.exc_info()
        if pedconfig.conf.verbose:
            print(errr, sys.exc_info())

        #pedync.message(&#34;\n   Cannot open / read file:  \n\n&#34;
        #                  &#34;      %s&#34; % self.fname)

        self.mained.update_statusbar(errr)
        usleep(10)
        return False

    #self.ularr.append((10 ,10, 20))
    mlen = self.calc_maxline()

    # Set up scroll bars
    self.set_maxlinelen(mlen, False)
    self.set_maxlines(len(self.text), False)

    self.loadundo()
    self.saveorg()
    self.savebackup()
    self.loadparms()

    # Add to accounting:
    logentry(&#34;Opened File&#34;, self.start_time, self.fname)

    # Propagate main wndow ref
    pedmenu.mained = self.mained

    self.set_nocol()

    try:
        os.chdir(os.path.dirname(self.fname))
    except:
        print(&#34;Cannot change dir to file&#39;s cwd&#34;, sys.exc_info())

    # Let the system breed
    self.invalidate()
    usleep(10)

    # Color ON?
    self.set_nocol()

    return True</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.loadmacro"><code class="name flex">
<span>def <span class="ident">loadmacro</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadmacro(self):
    #print( &#34;Loadmacro&#34;)

    xfile = pedconfig.conf.config_dir + &#34;/macros/&#34;
    old = os.getcwd()
    try:
        os.chdir(os.path.dirname(xfile))
    except:
        print(&#34;No macros directory&#34;, sys.exc_info())

    but =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Load Macro&#34;, Gtk.ButtonsType.OK
    fc = Gtk.FileChooserDialog(&#34;Load Macro&#34;, None, Gtk.FileChooserAction.OPEN, \
        but)

    fc.set_current_folder(xfile)
    #fc.set_current_folder(old)
    fc.set_default_response(Gtk.ButtonsType.OK)
    fc.connect(&#34;response&#34;, self.done_mac_open_fc, old)
    fc.run()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.loadparms"><code class="name flex">
<span>def <span class="ident">loadparms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadparms(self):
    hhh = hash_name(self.fname)

    self.startxxx  =  pedconfig.conf.sql.get_int(hhh + &#34;/xx&#34;)
    self.startyyy  =  pedconfig.conf.sql.get_int(hhh + &#34;/yy&#34;)
    #print(&#34;got cursor pos:&#34;, self.fname, self.startxxx, self.startyyy)
    # Note: we set cursor on first focus</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.loadundo"><code class="name flex">
<span>def <span class="ident">loadundo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadundo(self):
    hhh = hash_name(self.fname) + &#34;.udo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    try:
        fh = open(xfile, &#34;rb&#34;)
        try:
            self.undoarr = pickle.load(fh)
        except:
            pass
        fh.close()
    except:
        pass
        # Ignore it, not all files will have undo
        #print( &#34;Cannot load undo file&#34;, xfile)
    self.initial_undo_size = len(self.undoarr)

    hhh = hash_name(self.fname) + &#34;.rdo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    try:
        fh = open(xfile, &#34;rb&#34;)
        try:
            self.redoarr = pickle.load(fh)
        except:
            pass
        fh.close()
    except:
        pass
        # Ignore it, not all files will have redo
        #print( &#34;Cannot load redo file&#34;, xfile)
    self.initial_redo_size = len(self.redoarr)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.locate"><code class="name flex">
<span>def <span class="ident">locate</span></span>(<span>self, xstr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def locate(self, xstr):
    #print( &#34;locate &#39;&#34; + xstr +&#34;&#39;&#34;)
    cnt = 0; cnt2 = 0; idx = 0; found = 0
    for line in self.text:
        if xstr == line:
            self.gotoxy(idx, cnt, len(xstr), True)
            found = 1
            break
        cnt += 1
    if not found:
        xstr2 = xstr.lstrip().replace(&#34;\t&#34;, &#34; &#34;)
        for line2 in self.text:
            idx2 = line2.find(xstr2)
            if idx2 &gt;= 0:
                self.gotoxy(idx2, cnt2, len(xstr2), True)
                break
            cnt2 += 1</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.menuitem_response"><code class="name flex">
<span>def <span class="ident">menuitem_response</span></span>(<span>self, widget, stringx, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def menuitem_response(self, widget, stringx, arg):
    #print( &#34;menuitem response &#39;%s&#39;&#34; % stringx)
    #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)

    # See if Capitalized or UPPERCASE :
    if self.spellstr[0] in string.ascii_uppercase:
        stringx = stringx.capitalize()

    if self.spellstr.isupper():
        stringx = stringx.upper()

    pedconfig.conf.keyh.acth.clip_cb(None, stringx, self, False)

    self.fired += 1
    GLib.timeout_add(300, self.keytime)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.menuitem_response2"><code class="name flex">
<span>def <span class="ident">menuitem_response2</span></span>(<span>self, widget, stringx, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def menuitem_response2(self, widget, stringx, arg):
    #print( &#34;menuitem response2 &#39;%s&#39;&#34; % stringx)
    #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)
    disp2 = Gdk.Display()
    disp = disp2.get_default()
    clip = Gtk.Clipboard.get_default(disp)
    stringx = stringx.strip()
    clip.set_text(stringx, len(stringx))
    strs = &#34;Copied to clipboard &#39;{0:s}&#39;&#34;.format(stringx)
    self.mained.update_statusbar(strs)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.normsel"><code class="name flex">
<span>def <span class="ident">normsel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normsel(self):
    xssel = min(self.xsel, self.xsel2)
    xesel = max(self.xsel, self.xsel2)
    yssel = min(self.ysel, self.ysel2)
    yesel = max(self.ysel, self.ysel2)

    self.xsel  = xssel;  self.ysel  = yssel
    self.xsel2 = xesel;  self.ysel2 = yesel</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.on_drag_data_received"><code class="name flex">
<span>def <span class="ident">on_drag_data_received</span></span>(<span>self, widget, drag_context, x, y, data, info, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_drag_data_received(self, widget, drag_context, x, y, data, info, time):

    if info ==  TARGET_ENTRY_TEXT:
        text = data.get_text()
        #print(&#34;Received text: %s&#34; % text)
        pedconfig.conf.keyh.acth.add_str(self, text)

    elif info ==  TARGET_ENTRY_PIXBUF:
        pixbuf = data.get_pixbuf()
        width = pixbuf.get_width()
        height = pixbuf.get_height()

        print(&#34;Received pixbuf with width %spx and height %spx&#34; % (width, height))</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.on_drag_drop"><code class="name flex">
<span>def <span class="ident">on_drag_drop</span></span>(<span>self, widget, context, x, y, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_drag_drop(self, widget, context, x, y, time):
    widget.drag_get_data(context, context.list_targets()[-1], time)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.on_drag_motion"><code class="name flex">
<span>def <span class="ident">on_drag_motion</span></span>(<span>self, widgt, context, c, y, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_drag_motion(self, widgt, context, c, y, time):
    Gdk.drag_status(context, Gdk.DragAction.COPY, time)
    return True</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.overwrite_done"><code class="name flex">
<span>def <span class="ident">overwrite_done</span></span>(<span>self, win, resp, fname, win2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overwrite_done(self, win, resp, fname, win2):
    #print( &#34;overwrite done&#34;, resp)
    if resp == Gtk.ResponseType.YES:
        self.fname = fname
        self.writeout()
        self.set_nocol()
        win2.destroy()
    win.destroy()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.pix2pos"><code class="name flex">
<span>def <span class="ident">pix2pos</span></span>(<span>self, xx, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pix2pos(self, xx, yy):
    return int(self.xpos + xx / self.cxx), int(self.ypos + yy / self.cyy)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.pix2xpos"><code class="name flex">
<span>def <span class="ident">pix2xpos</span></span>(<span>self, xx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pix2xpos(self, xx):
    return int(self.xpos + xx / self.cxx)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.pix2ypos"><code class="name flex">
<span>def <span class="ident">pix2ypos</span></span>(<span>self, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pix2ypos(self, yy):
    return int(self.ypos + yy / self.cyy)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.poprclick"><code class="name flex">
<span>def <span class="ident">poprclick</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poprclick(self, widget, event):
    #print (&#34;Making rclick&#34;)
    self.build_menu(self, pedmenu.rclick_menu)
    if event:
        self.menu.popup(None, None, None, None, event.button, event.time)
    else:
        event = Gdk.EventButton()
        self.menu.popup(None, None, None, None, event.button, event.time)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.poprclick2"><code class="name flex">
<span>def <span class="ident">poprclick2</span></span>(<span>self, widget, event, strx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poprclick2(self, widget, event, strx):
    #print (&#34;Making shift rclick2&#34;)
    self.menu2 = Gtk.Menu()
    self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % strx, None))
    mi = self.create_menuitem(&#34;-------------&#34;, None)
    mi.set_sensitive(False)
    self.menu2.append(mi)
    strs = &#34;Creating class list for &#39;{0:s}&#39;&#34;.format(strx)
    self.mained.update_statusbar(strs)
    arr = pedstruct.suggest(self, strx)
    if len(arr) == 0:
        self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
    else:
        for bb in arr:
            self.menu2.append(self.create_menuitem(bb, self.menuitem_response2))

    self.menu2.popup(None, None, None, None, event.button, event.time)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.poprclick3"><code class="name flex">
<span>def <span class="ident">poprclick3</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poprclick3(self, event):
    #print (&#34;Making shift rclick3&#34;)
    got_src = 0; got_targ = 0

    nn = self.notebook.get_n_pages(); cnt = 0
    while True:
        if cnt &gt;= nn: break
        ppp = self.notebook.get_nth_page(cnt)
        #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
        if ppp.area.diffmode == 1:
            got_src = True
        if ppp.area.diffmode == 2:
            got_targ = True
        cnt += 1

    # Check if there is any:
    nn = self.notebook.get_n_pages(); cnt = 0
    while True:
        if cnt &gt;= nn: break
        ppp = self.notebook.get_nth_page(cnt)
        #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
        if ppp.area.diffmode == 1:
            got_src = True
        if ppp.area.diffmode == 2:
            got_targ = True
        cnt += 1

    self.menu3 = Gtk.Menu()
    if not got_src:
        self.menu3.append(self.create_menuitem(&#34;Set as Diff Source&#34;, self.set_diffs, 1))
    if not got_targ:
        self.menu3.append(self.create_menuitem(&#34;Set as Diff Target&#34;, self.set_diffs, 2))

    self.menu3.append(self.create_menuitem(&#34;Unset (stop) Diff&#34;,  self.set_diffs, 0))
    self.menu3.popup(None, None, None, None, event.button, event.time)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.popspell"><code class="name flex">
<span>def <span class="ident">popspell</span></span>(<span>self, widget, event, xstr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popspell(self, widget, event, xstr):
    # Create a new menu-item with a name...
    self.menu2 = Gtk.Menu()
    self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % xstr, None))
    self.menu2.append(self.create_menuitem(&#34;Add to Dict&#34;, self.addict, xstr))

    mi = self.create_menuitem(&#34;-------------&#34;, None)
    mi.set_sensitive(False)
    self.menu2.append(mi)

    strs = &#34;Creating suggestion list for &#39;{0:s}&#39;&#34;.format(self.spellstr)
    self.mained.update_statusbar(strs)
    arr = pedspell.suggest(self, xstr)

    if len(arr) == 0:
        self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
    else:
        for aa, bb in arr:
            self.menu2.append(self.create_menuitem(bb, self.menuitem_response))

    self.menu2.popup(None, None, None, None, event.button, event.time)
    #self.mained.update_statusbar(&#34;Done menu popup.&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.prompt_save"><code class="name flex">
<span>def <span class="ident">prompt_save</span></span>(<span>self, askname=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prompt_save(self, askname = True):

    # Always save params
    self.saveparms()

    if not self.changed:
        #print &#34;not changed&#34;, self.fname
        return False

    msg = &#34;\nWould you like to save:\n\n  \&#34;%s\&#34; \n&#34; % self.fname
    rp = pedync.yes_no_cancel(&#34;pyedpro: Save File ?&#34;, msg)

    if rp == Gtk.ResponseType.YES:
        if askname:
            self.file_dlg(rp)
        else:
            self.save()
    elif rp == Gtk.ResponseType.NO:
        pass
    elif  rp == Gtk.ResponseType.CANCEL:
        return True
    else:
        print(&#34;warning: invalid response from dialog&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.rclick_action"><code class="name flex">
<span>def <span class="ident">rclick_action</span></span>(<span>self, action, sss, ttt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rclick_action(self, action, sss, ttt):
    #print( &#34;rclck_action&#34;, sss, ttt)
    if ttt == 1:
        self.mained.newfile()
    elif ttt == 3:
        self.mained.open()
    elif ttt == 4:
        self.mained.save()
    elif ttt == 5:
        self.mained.save(True)
    elif ttt == 7:
        self.mained.copy()
    elif ttt == 8:
        self.mained.cut()
    elif ttt == 9:
        self.mained.paste()
    elif ttt == 11:
        self.toggle_ro()
    elif ttt == 13:
        self.mained.activate_exit()
    elif ttt == 14:
        self.start_term()
    elif ttt == 15:
        self.start_edit()
    elif ttt == 16:
        self.mained.tts()
    elif ttt == 17:
        pedmisc.exec_test(self, &#34;rc&#34;)
    elif ttt == 18:
        self.start_external([&#34;libreoffice&#34;, &#34;--writer&#34;],
                                    [&#34;libreoffice&#34;, &#34;--writer&#34;])
    else:
        print(&#34;peddoc: Invalid menu item selected&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):

    #print (&#34;Saving&#34;, self.fname)
    # Always save params
    self.saveparms()
    strx = &#34;&#34;
    if not self.changed:
        strx = &#34;File is not modified.&#34;
        #self.mained.update_statusbar(strx)
        return

    # Is this file named &#39;untitled&#39;?
    base, ext =  os.path.splitext(pedconfig.conf.UNTITLED)
    base1 = os.path.basename(self.fname)
    base2, ext2 =  os.path.splitext(base1)
    if base2[:len(base)] == base:
        self.file_dlg(Gtk.ResponseType.YES)
    else:
        bn = os.path.basename(self.fname)
        err = self.writeout()
        if  err[0]:
            strx = &#34;Saved &#39;{0:s}&#39;&#34;.format(self.fname)
        else:
            #strx = &#34;Not Saved &#39;{0:s}&#39; {1:s}&#34;.format(bn, err[1])
            strx = &#34;Not Saved &#34;

    if pedconfig.conf.verbose:
        print(strx)
    self.mained.update_statusbar(strx)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.saveas"><code class="name flex">
<span>def <span class="ident">saveas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveas(self):
    self.file_dlg(Gtk.ResponseType.YES)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.savebackup"><code class="name flex">
<span>def <span class="ident">savebackup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savebackup(self):
    hhh = hash_name(self.fname) + &#34;.bak&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    try:
        writefile(xfile, self.text, &#34;\n&#34;)
    except:
        sss = &#34;Cannot create backup file&#34; + xfile + sys.exc_info()
        print(sss)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.savemacro"><code class="name flex">
<span>def <span class="ident">savemacro</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savemacro(self):
    #print( &#34;Savemacro&#34;)

    fname = &#34;untitled.mac&#34;
    xfile = pedconfig.conf.config_dir + &#34;/macros/&#34; + fname
    old = os.getcwd()
    try:
        os.chdir(os.path.dirname(xfile))
    except:
        print(&#34;No macros directory&#34;, sys.exc_info())

    but =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Save Macro&#34;, Gtk.ButtonsType.OK
    fc = Gtk.FileChooserDialog(&#34;Save Macro&#34;, None, Gtk.FileChooserAction.SAVE, \
        but)

    fc.set_current_folder(xfile)
    fc.set_current_name(os.path.basename(xfile))
    fc.set_default_response(Gtk.ButtonsType.OK)
    fc.connect(&#34;response&#34;, self.done_mac_fc, old)
    fc.run()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.saveorg"><code class="name flex">
<span>def <span class="ident">saveorg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveorg(self):
    hhh = hash_name(self.fname) + &#34;.org&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    if not os.path.isfile(xfile):
        err =  writefile(xfile, self.text, &#34;\n&#34;)
        if not err[0]:
            print(&#34;Cannot create (org) backup file&#34;, xfile, sys.exc_info())</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.saveparms"><code class="name flex">
<span>def <span class="ident">saveparms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  saveparms(self):
    hhh = hash_name(self.fname)
    pedconfig.conf.sql.put(hhh + &#34;/xx&#34;, self.xpos + self.caret[0])
    pedconfig.conf.sql.put(hhh + &#34;/yy&#34;, self.ypos + self.caret[1])
    pedconfig.conf.sql.put(hhh + &#34;/fname&#34;, self.fname)

    if self.tts:
        self.tts.haltspeak = True

    #print  &#34;saveparm&#34;, time.clock() - got_clock</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.saveundo"><code class="name flex">
<span>def <span class="ident">saveundo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveundo(self):
    hhh = hash_name(self.fname) + &#34;.udo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    try:
        fh = open(xfile, &#34;wb&#34;)
        pickle.dump(self.undoarr, fh)
        fh.close()
    except:
        print(&#34;Cannot save undo file&#34;, sys.exc_info())
        pedutil.put_exception(&#34;undo&#34;)


    hhh = hash_name(self.fname) + &#34;.rdo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    try:
        fh = open(xfile, &#34;wb&#34;)
        pickle.dump(self.redoarr, fh)
        fh.close()
    except:
        print(&#34;Cannot save redo file&#34;, sys.exc_info())</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.scroll_event"><code class="name flex">
<span>def <span class="ident">scroll_event</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_event(self, widget, event):
    #print( &#34;scroll_event&#34;, event, event.direction)
    xidx = self.xpos + self.caret[0]
    yidx = self.ypos + self.caret[1]
    if event.direction == Gdk.ScrollDirection.SMOOTH:
        flag, directx, directy = event.get_scroll_deltas()
        if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
            yidx += 10 * int(directy)
        elif event.state &amp; Gdk.ModifierType.SHIFT_MASK:
            yidx += 5 * int(directy)
        else:
            yidx += int(directy)
    else:
        #print( &#34;type&#34;, type(event.type))
        #print(&#34;truth&#34;, isinstance(event.type, Gdk.EventType))
        if event.direction == Gdk.ScrollDirection.UP:
            yidx -= int(self.pgup / 2)
        else:
            yidx += int(self.pgup / 2)

    self.set_caret(xidx, yidx)
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, srctxt, regex, boolcase, boolregex)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, srctxt, regex, boolcase, boolregex):

    # Remember old settings:
    self.srctxt = srctxt;       self.regex = regex
    self.boolcase = boolcase;   self.boolregex = boolregex
    self.src_changed = False

    self.accum = []

    curr = self.caret[1] + self.ypos
    was = -1; cnt = 0; cnt2 = 0

    for line in self.text:
        # Search one line for multiple matches
        mmm = src_line(line, cnt, srctxt, regex, boolcase, boolregex)

        if cnt &gt; curr and was == -1:
            was = cnt2
        if  mmm:
            cnt2 += 1
            for sss in mmm:
                self.accum.append(sss)
        if cnt % 100 == 0:
            self.mained.update_statusbar(&#34;Searching at %d&#34; % cnt)
            usleep(1)
        cnt += 1
    return was, cnt2</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.search_again"><code class="name flex">
<span>def <span class="ident">search_again</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_again(self):
    if len(self.accum) == 0:
        return

    if self.src_changed:
        self.search(self.srctxt, self.regex, self.boolcase, self.boolregex)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.set_caret"><code class="name flex">
<span>def <span class="ident">set_caret</span></span>(<span>self, xx, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_caret(self, xx, yy):

    #print( &#34;set_caret&#34;, xx, yy)
    xx = int(xx); yy = int(yy)

    # Needs scroll?
    need_inval = False
    cww = self.get_width_char()
    chh = self.get_height_char()
    xlen = len(self.text)

    # ----------------------------------------------------------------
    # Put it back in view yyy:

    off = chh - self.vscgap
    if yy - self.ypos &gt; off:
        #print( &#34;Scroll from caret down&#34;)
        if yy &gt; self.ypos + self.caret[1]:
            #print( &#34;move d&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
            self.ypos = int(yy - off)
            need_inval = True
            # Force new spell check
            self.fired += 1
            #goject.timeout_add(
            GLib.timeout_add(300, self.keytime)

    if yy - self.ypos &lt; self.vscgap and self.ypos:
        #print( &#34;Scroll from caret up&#34;)
        if yy &lt; self.ypos + self.caret[1]:
            #print( &#34;move u&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
            self.ypos = int(yy - self.vscgap)
            self.ypos = int(max(self.ypos, 0))
            need_inval = True
            # Force new spell check
            self.fired += 1
            GLib.timeout_add(300, self.keytime)

    yy -= self.ypos
    if self.ypos &lt; 0: self.ypos = 0

    # ----------------------------------------------------------------
    # Put it back in view xxx:

    xoff = cww - self.hscgap
    if  xx - self.xpos  &gt; xoff:
        #print( &#34;Scroll from caret right&#34;, &#34;xx&#34;, xx, &#34;xpos&#34;, self.xpos)
        if self.xpos + self.caret[0] &lt; xx:
            #print( &#34;moved r&#34;,  xx, self.caret[0], self.xpos)
            self.xpos =  int(xx - xoff)
            self.xpos = int(max(self.xpos, 0))
            need_inval = True

    if  xx - self.xpos &lt;  self.hscgap:
        #print( &#34;Scroll from caret left &#34;, xx, self.xpos)
        if self.xpos + self.caret[0] &gt; xx:
            #print( &#34;moved l&#34;, &#34;xx&#34;, xx, &#34;caret&#34;, self.caret[0], &#34;xpos&#34;, self.xpos)
            self.xpos = int(xx - self.hscgap)
            self.xpos = int(max(self.xpos, 0))
            need_inval = True

    xx -= self.xpos
    if self.xpos &lt; 0: self.xpos = 0

    oldx = self.caret[0] * self.cxx
    oldy = self.caret[1] * self.cyy

    # Cheat - invalidate all if tab is involved at old line
    try:
        line = self.text[oldy]
    except:
        line = &#34;&#34;; need_inval = True
    if line.find(&#34;\t&#34;) &gt;= 0:
        need_inval = True

    self.caret[0] = xx; self.caret[1] = yy

    # Low limit
    if self.caret[0] &lt; 0: self.caret[0] = 0
    if self.caret[1] &lt; 0: self.caret[1] = 0

    wxx = self.caret[0] * self.cxx
    wyy = self.caret[1] * self.cyy

    # Cheat - invalidate all if tab is involoved
    try:
        line = self.text[self.ypos + self.caret[1]]
    except:
        line = &#34;&#34;; need_inval = True
    if line.find(&#34;\t&#34;) &gt;= 0:
        need_inval = True

    # Optimize cursor movement invalidation
    &#39;&#39;&#39;if  not need_inval :
        rect = Gdk.Rectangle(wxx, wyy, self.cxx * self.cxx /2, self.cyy + 1)
        self.invalidate(rect)

        rect = Gdk.Rectangle(oldx, oldy, self.cxx + self.cxx /2 , self.cyy + 1)
        self.invalidate(rect)
    &#39;&#39;&#39;
    self.invalidate(None)

    # Update scroll bars, prevent them from sending scroll message:
    self.oneshot = True; self.vscroll.set_value(self.ypos)
    self.honeshot = True; self.hscroll.set_value(self.xpos)

    self.update_bar2()

    if  need_inval or self.bigcaret:
        self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.set_caret_middle"><code class="name flex">
<span>def <span class="ident">set_caret_middle</span></span>(<span>self, xx, yy, sel=None, quart=2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_caret_middle(self, xx, yy, sel = None, quart = 2):

    xx = int(xx); yy = int(yy)

    # Needs scroll?
    #xxx, yyy = self.get_size()
    xlen = len(self.text)

    # Put it back in view:
    off = (self.get_height() / self.cyy) / quart
    if yy &gt; off:
        self.ypos = int(yy - off)
    else:
        self.ypos = 0

    self.set_caret(xx, yy)
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.set_changed"><code class="name flex">
<span>def <span class="ident">set_changed</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_changed(self, flag):
    old = self.changed
    self.changed = flag
    # Exec actions:
    if old != self.changed:
        #print( &#34;Setting changed on &#34;, self.fname)
        self.set_tablabel()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.set_diffs"><code class="name flex">
<span>def <span class="ident">set_diffs</span></span>(<span>self, arg1, arg2, arg3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_diffs(self, arg1, arg2, arg3):
    # reset all
    if arg3 == 0:
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            ppp.area.diffmode = 0
            ppp.area.set_tablabel()
            cnt += 1
        www = self.mained.get_width()
        self.mained.hpaned3.set_position(www - 10)

    else:
        self.diffmode = arg3
        self.set_tablabel()

        got_src = 0; got_targ = 0; action_page = 0;
        src = &#34;&#34;; targ = &#34;&#34;
        srctxt = [] ;  targtxt = []
        action_tab = None

        # See if diff complete, put it in motion
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
                src = os.path.basename(ppp.area.fname)
                srctxt = ppp.area.text

            if ppp.area.diffmode == 2:
                got_targ = True
                targ = os.path.basename(ppp.area.fname)
                targtxt = ppp.area.text
                action_page = cnt
                action_tab = ppp

            if ppp.area.diffmode == 1:
                got_src = True
            cnt += 1

        if got_src and got_targ:
            www = self.mained.get_width()
            if self.mained.hpaned3.get_position() &gt; www - 20:
                self.mained.hpaned3.set_position(www - www / 3)

            self.mained.update_statusbar(    \
                        &#34;Diff started.  Source: &#39;%s&#39; Target: &#39;%s&#39;&#34; % (src, targ))

            self.notebook.set_current_page(action_page)
            action_tab.area.diffx(srctxt, targtxt)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.set_maxlinelen"><code class="name flex">
<span>def <span class="ident">set_maxlinelen</span></span>(<span>self, mlen=-1, ignore=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  set_maxlinelen(self, mlen = -1, ignore = True):
    if mlen == -1: self.calc_maxline()
    self.maxlinelen = mlen
    self.oneshot = ignore
    #value, lower, upper, step_increment, page_increment, page_size)
    #self.hadj.set_all(0, 0, self.maxlinelen * 2, 1, 15, 25)
    self.hadj.set_value(0)
    self.hadj.set_lower(0)
    self.hadj.set_upper(self.maxlinelen * 2)
    self.hadj.set_step_increment(1)
    self.hadj.set_page_increment(15)
    self.hadj.set_page_size(25)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.set_maxlines"><code class="name flex">
<span>def <span class="ident">set_maxlines</span></span>(<span>self, lines=0, ignore=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  set_maxlines(self, lines = 0, ignore = True):
    self.maxlines = len(self.text) + self.get_height() / self.cyy + 25
    self.oneshot = ignore
    #self.vadj.set_all(0, 0, self.maxlines, 1, 15, 25)
    self.vadj.set_value(0)
    self.vadj.set_lower(0)
    self.vadj.set_upper(self.maxlines)
    self.vadj.set_step_increment(1)
    self.vadj.set_page_increment(15)
    self.vadj.set_page_size(25)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.set_nocol"><code class="name flex">
<span>def <span class="ident">set_nocol</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_nocol(self):
    colflag = False
    ext = os.path.splitext(self.fname)[1].lower()
    for aa in pedconfig.conf.color_on:
        if ext == aa:
            colflag = True
            break
    self.colflag = colflag</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.set_tablabel"><code class="name flex">
<span>def <span class="ident">set_tablabel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tablabel(self):
    # Find me in tabs
    nn = self.notebook.get_n_pages(); cnt = 0
    while True:
        if cnt &gt;= nn: break
        ppp = self.notebook.get_nth_page(cnt)
        if ppp.area == self:
            self._setlabel(ppp)
            break
        cnt += 1</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.setcol"><code class="name flex">
<span>def <span class="ident">setcol</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setcol(self):
    ccc = pedconfig.conf.sql.get_str(&#34;fgcolor&#34;)
    if ccc == &#34;&#34;:
        self.fgcolor  = pedcolor.str2float(FGCOLOR)
    else:
        self.fgcolor  = pedcolor.str2float(ccc)
    #print( &#34;fgcol&#34;, self.fgcolor, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;rbgcolor&#34;)
    if ccc == &#34;&#34;:
        self.rbgcolor = pedcolor.str2float(RBGCOLOR)
    else:
        self.rbgcolor = pedcolor.str2float(ccc)
    #print( &#34;rgbcolor&#34;, self.rbgcolor, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;bgcolor&#34;)
    if ccc == &#34;&#34;:
        self.bgcolor = pedcolor.str2float(BGCOLOR)
    else:
        self.bgcolor = pedcolor.str2float(ccc)
    #print( &#34;bgcolor&#34;, self.bgcolor, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;cbgcolor&#34;)
    if ccc == &#34;&#34;:
        self.cbgcolor = pedcolor.str2float(CBGCOLOR)
    else:
        self.cbgcolor = pedcolor.str2float(ccc)
    #print( &#34;cbgcolor&#34;, self.cbgcolor, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;kwcolor&#34;)
    if ccc == &#34;&#34;:
        self.kwcolor = pedcolor.str2float(KWCOLOR)
    else:
        self.kwcolor = pedcolor.str2float(ccc)
    #print( &#34;load kwcolor&#34;, self.kwcolor, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;clcolor&#34;)
    if ccc == &#34;&#34;:
        self.clcolor = pedcolor.str2float(CLCOLOR)
    else:
        self.clcolor = pedcolor.str2float(ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;cocolor&#34;)
    if ccc == &#34;&#34;:
        self.cocolor = pedcolor.str2float(COCOLOR)
    else:
        self.cocolor = pedcolor.str2float(ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;stcolor&#34;)
    if ccc == &#34;&#34;:
        self.stcolor = pedcolor.str2float(STCOLOR)
    else:
        self.stcolor = pedcolor.str2float(ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;carcolor&#34;)
    if ccc == &#34;&#34;:
        self.carcolor = pedcolor.str2float(CARCOLOR)
    else:
        self.carcolor = pedcolor.str2float(ccc)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.setfont"><code class="name flex">
<span>def <span class="ident">setfont</span></span>(<span>self, fam, size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setfont(self, fam, size):

    self.fd = Pango.FontDescription()
    self.fd.set_family(fam)
    self.fd.set_size(size * Pango.SCALE)

    self.pangolayout = self.create_pango_layout(&#34;a&#34;)
    self.pangolayout.set_font_description(self.fd)

    # Get Pango steps
    self.cxx, self.cyy = self.pangolayout.get_pixel_size()

    # Get Pango tabs
    self.tabarr = Pango.TabArray(80, False)
    #for aa in range(self.tabarr.get_size()):
    #    self.tabarr.set_tab(aa, Pango.TAB_LEFT, aa * TABSTOP * self.cxx * Pango.SCALE)

    self.pangolayout.set_tabs(self.tabarr)
    ts = self.pangolayout.get_tabs()

    &#39;&#39;&#39;if ts != None:
        al, self.tabstop = ts.get_tab(1)
    self.tabstop /= self.cxx * Pango.SCALE&#39;&#39;&#39;</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.showcol"><code class="name flex">
<span>def <span class="ident">showcol</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showcol(self, flag):
    self.scol = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.showtab"><code class="name flex">
<span>def <span class="ident">showtab</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showtab(self, flag):
    self.stab = flag
    self.scol = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.size_alloc"><code class="name flex">
<span>def <span class="ident">size_alloc</span></span>(<span>self, widget, req)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_alloc(self, widget, req):
    #print( &#34;size_alloc&#34;, req)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.size_request"><code class="name flex">
<span>def <span class="ident">size_request</span></span>(<span>self, widget, req)</span>
</code></dt>
<dd>
<div class="desc"><p>size_request(self) -&gt; requisition:Gtk.Requisition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_request(self, widget, req):
    #print( &#34;size_request&#34;, req)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.start_edit"><code class="name flex">
<span>def <span class="ident">start_edit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_edit(self):

    old = os.getcwd()
    fdir = os.path.dirname(os.path.realpath(__file__))
    #print(&#34;fdir:&#34;, fdir)
    mydir = os.path.dirname(os.path.join(fdir, &#34;../&#34;))
    #print(&#34;mydir:&#34;, mydir)
    os.chdir(mydir)
    myscript = os.path.realpath(os.path.join(mydir, &#39;pyedpro.py&#39;))
    #print(&#34;myscript:&#34;, myscript)

    ret = 0
    try:
        if platform.system().find(&#34;Win&#34;) &gt;= 0:
            print(&#34;No exe function on windows. (TODO)&#34;)
        else:
            # Stumble until editor found
            ret = subprocess.Popen([&#34;python3&#34;, myscript])
            if ret.returncode:
                ret = subprocess.Popen([&#34;python&#34;, myscript])
                if not ret.returncode:
                    raise OSError
    except:
        print(&#34;Cannot launch editor instance&#34;, sys.exc_info())
        pedync.message(&#34;\n   Cannot launch new editor instance \n\n&#34;)

    # Back to original dir
    os.chdir(os.path.dirname(old))</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.start_external"><code class="name flex">
<span>def <span class="ident">start_external</span></span>(<span>self, linprog, winprog)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_external(self, linprog, winprog):

    try:
        if platform.system().find(&#34;Win&#34;) &gt;= 0:
            ret = subprocess.Popen(winprog)
            #if not ret.returncode:
            #    raise OSError
        else:
            ret = subprocess.Popen(linprog)
            #if not ret.returncode:
            #    raise OSError
    except:
        print(&#34;Cannot launch %s&#34; % str(linprog), sys.exc_info())
        pedync.message(&#34;\n   Cannot launch %s \n\n&#34;  % str(linprog) +
                   &#34;              (Please install)&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.start_term"><code class="name flex">
<span>def <span class="ident">start_term</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_term(self):
    #print(&#34;Terminal Here&#34;)
    try:
        if platform.system().find(&#34;Win&#34;) &gt;= 0:
            ret = subprocess.Popen([&#34;putty&#34;])
            #if not ret.returncode:
            #    raise OSError
            #print(&#34;No terminal on windows. (TODO)&#34;)
        else:
            # Stumble until terminal found
            ret = subprocess.Popen([&#34;xfce4-terminal&#34;])
            if ret.returncode:
                ret = subprocess.Popen([&#34;gnome-terminal&#34;])
                if ret.returncode:
                    raise OSError
    except:
        print(&#34;Cannot launch terminal&#34;, sys.exc_info())
        pedync.message(&#34;\n   Cannot launch terminal executable \n\n&#34;
                   &#34;              (Please install)&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.toggle_ro"><code class="name flex">
<span>def <span class="ident">toggle_ro</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_ro(self):
    self.readonly = not self.readonly
    self.set_tablabel()
    arrx = [&#34;OFF&#34;, &#34;ON&#34;]
    self.mained.update_statusbar(&#34;Toggled read only to %s&#34; % arrx[self.readonly])</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.update_bar2"><code class="name flex">
<span>def <span class="ident">update_bar2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_bar2(self):
    clip = pedconfig.conf.keyh.acth.currclip
    self.mained.update_statusbar2(self.caret[0] + self.xpos, \
            self.caret[1] + self.ypos, self.insert, len(self.text), clip, self.caps, self.scr)</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.vscroll_cb"><code class="name flex">
<span>def <span class="ident">vscroll_cb</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vscroll_cb(self, widget):
    #print( &#34;vscroll_cb&#34;, widget.get_value())
    # Skip one callback
    if self.oneshot:
        self.oneshot = False; return
    #print( &#34;vscroll_cb ok&#34;, widget.get_value())
    yidx = int(widget.get_value())
    self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.walk_func"><code class="name flex">
<span>def <span class="ident">walk_func</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk_func(self):
    #print( &#34;walk func&#34;)
    # ts2 ---------------------------------------------------
    sumw2 = []
    if self.text:
        sline = self.caret[1] + int(self.ypos)
        sline = max(sline, 0); sline = min(sline, len(self.text))
        #print( &#34;Start point&#34;, sline, self.text[sline])
        # Walk back to last function
        if &#34;.c&#34; in self.fname or &#34;.h&#34; in self.fname or &#34;.php&#34; in self.fname:
            try:
                aa = 0; bb = 0
                regex = re.compile(ckeywords)
                for aa in range(sline - 1, 0, -1):
                    line = self.text[aa]
                    res = regex.search(line)
                    if res:
                        #print( &#34;start&#34;, line, res.start(), res.end())
                        sumw2.append(line)
                        break
                if aa &gt; 0:
                    for bb in range(aa + 1, len(self.text)):
                        line = self.text[bb]
                        res = regex.search(line)
                        if res:
                            #print( &#34;end&#34;, line, res.start(), res.end())
                            break

                    regex2 = re.compile(localkwords)
                    for cc in range(aa + 1, bb - 1):
                        line = self.text[cc]
                        res = regex2.search(line)
                        if res:
                            #print( &#34;match&#34;, line, res.start(), res.end())
                            sumw2.append(line)

            except:
                print(&#34;Exception in c func handler&#34;, sys.exc_info())
                pass
        if &#34;.bas&#34; in self.fname.lower():
            try:
                regex = re.compile(basekeywords)
                for line in win.text:
                    res = regex.search(line)
                    if res:
                        #print( res, res.start(), res.end())
                        sumw.append(line)
            except:
                print(&#34;Exception in bas func extraction handler&#34;, sys.exc_info())
                pass
        if &#34;.py&#34; in self.fname.lower():
            try:
                aa = 0; bb = 0
                regex = re.compile(&#34;class&#34;)
                for aa in range(int(sline) - 1, 0, -1):
                    line = self.text[aa]
                    res = regex.search(line)
                    if res:
                        #print( &#34;start&#34;, line, res.start(), res.end())
                        sumw2.append(line)
                        break

                regex = re.compile(pykeywords2)
                for aa in range(int(sline) - 1, 0, -1):
                    line = self.text[aa]
                    res = regex.search(line)
                    if res:
                        #print( &#34;start&#34;, line, res.start(), res.end())
                        sumw2.append(line)
                        break

                if aa &gt; 0:
                    for bb in range(aa + 1, len(self.text)):
                        line = self.text[bb]
                        res = regex.search(line)
                        if res:
                            #print( &#34;end&#34;, line, res.start(), res.end())
                            break

                    regex2 = re.compile(localpywords)
                    for cc in range(aa + 1, bb - 1):
                        line = self.text[cc]
                        res = regex2.search(line)
                        if res:
                            #print( &#34;match&#34;, line, res.start(), res.end())
                            sumw2.append(line)

            except:
                print(&#34;Exception in py func handler&#34;, sys.exc_info())
                raise
                pass
        else:
            pass

        # Always show todo
        got_todo = 0
        for line in self.text:
            if &#34;TODO&#34; in line:
                if not got_todo:
                    got_todo = 1
                    sumw2.append(&#34;----------- TODO List ----------&#34;)
                sumw2.append(line)

    try:
        self.mained.update_treestore2(sumw2)
    except:
        # This is normal, ignore it
        print(&#34;walk2&#34;, sys.exc_info())
        pass</code></pre>
</details>
</dd>
<dt id="peddoc_diff.pedDoc.writeout"><code class="name flex">
<span>def <span class="ident">writeout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeout(self):

    if pedconfig.conf.verbose:
        print(&#34;Saving &#39;&#34;+ self.fname + &#34;&#39;&#34;)

    wasfile = os.access(self.fname, os.R_OK)
    err = writefile(self.fname, self.text, &#34;\n&#34;)
    if err[0]:
        self.set_changed(False)

    if not wasfile:
        # Change access/ownership to group write
        try:
            ostat = os.stat(self.fname)
            os.chmod(self.fname, ostat.st_mode | stat.S_IWGRP)
        except:
            print(&#34;Cannot change group write on &#39;%s&#39;&#34; % self.fname,  sys.exc_info())

    self.saveundo();  self.saveparms(); self.set_tablabel()

    # Add to accounting:
    logentry(&#34;Wrote File&#34;, self.start_time, self.fname)

    # Update stat info
    self.stat = os.stat(self.fname)

    return err</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="peddoc_diff.run_async_time" href="#peddoc_diff.run_async_time">run_async_time</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="peddoc_diff.pedDoc" href="#peddoc_diff.pedDoc">pedDoc</a></code></h4>
<ul class="">
<li><code><a title="peddoc_diff.pedDoc.activate_action" href="#peddoc_diff.pedDoc.activate_action">activate_action</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.addict" href="#peddoc_diff.pedDoc.addict">addict</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.area_button" href="#peddoc_diff.pedDoc.area_button">area_button</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.area_enter" href="#peddoc_diff.pedDoc.area_enter">area_enter</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.area_focus" href="#peddoc_diff.pedDoc.area_focus">area_focus</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.area_key" href="#peddoc_diff.pedDoc.area_key">area_key</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.area_leave" href="#peddoc_diff.pedDoc.area_leave">area_leave</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.area_motion" href="#peddoc_diff.pedDoc.area_motion">area_motion</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.build_menu" href="#peddoc_diff.pedDoc.build_menu">build_menu</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.builddoc" href="#peddoc_diff.pedDoc.builddoc">builddoc</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.calc_maxline" href="#peddoc_diff.pedDoc.calc_maxline">calc_maxline</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.clearsel" href="#peddoc_diff.pedDoc.clearsel">clearsel</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.close_button" href="#peddoc_diff.pedDoc.close_button">close_button</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.closedoc" href="#peddoc_diff.pedDoc.closedoc">closedoc</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.coloring" href="#peddoc_diff.pedDoc.coloring">coloring</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.configure_event" href="#peddoc_diff.pedDoc.configure_event">configure_event</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.create_menuitem" href="#peddoc_diff.pedDoc.create_menuitem">create_menuitem</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.delundo" href="#peddoc_diff.pedDoc.delundo">delundo</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.diffx" href="#peddoc_diff.pedDoc.diffx">diffx</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.do_chores" href="#peddoc_diff.pedDoc.do_chores">do_chores</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.doclabel_callb" href="#peddoc_diff.pedDoc.doclabel_callb">doclabel_callb</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.done_fc" href="#peddoc_diff.pedDoc.done_fc">done_fc</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.done_mac_fc" href="#peddoc_diff.pedDoc.done_mac_fc">done_mac_fc</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.done_mac_open_fc" href="#peddoc_diff.pedDoc.done_mac_open_fc">done_mac_open_fc</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.draw_event" href="#peddoc_diff.pedDoc.draw_event">draw_event</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.file_dlg" href="#peddoc_diff.pedDoc.file_dlg">file_dlg</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.flash" href="#peddoc_diff.pedDoc.flash">flash</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.focus_in_cb" href="#peddoc_diff.pedDoc.focus_in_cb">focus_in_cb</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.focus_out_cb" href="#peddoc_diff.pedDoc.focus_out_cb">focus_out_cb</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.get_height" href="#peddoc_diff.pedDoc.get_height">get_height</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.get_height_char" href="#peddoc_diff.pedDoc.get_height_char">get_height_char</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.get_size" href="#peddoc_diff.pedDoc.get_size">get_size</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.get_width" href="#peddoc_diff.pedDoc.get_width">get_width</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.get_width_char" href="#peddoc_diff.pedDoc.get_width_char">get_width_char</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.gotoxy" href="#peddoc_diff.pedDoc.gotoxy">gotoxy</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.grab_focus_cb" href="#peddoc_diff.pedDoc.grab_focus_cb">grab_focus_cb</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.hexview" href="#peddoc_diff.pedDoc.hexview">hexview</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.hscroll_cb" href="#peddoc_diff.pedDoc.hscroll_cb">hscroll_cb</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.idle_callback" href="#peddoc_diff.pedDoc.idle_callback">idle_callback</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.idle_callback2" href="#peddoc_diff.pedDoc.idle_callback2">idle_callback2</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.idle_queue" href="#peddoc_diff.pedDoc.idle_queue">idle_queue</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.intersect" href="#peddoc_diff.pedDoc.intersect">intersect</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.inval_line" href="#peddoc_diff.pedDoc.inval_line">inval_line</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.invalidate" href="#peddoc_diff.pedDoc.invalidate">invalidate</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.iterdocs" href="#peddoc_diff.pedDoc.iterdocs">iterdocs</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.keytime" href="#peddoc_diff.pedDoc.keytime">keytime</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.loadfile" href="#peddoc_diff.pedDoc.loadfile">loadfile</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.loadmacro" href="#peddoc_diff.pedDoc.loadmacro">loadmacro</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.loadparms" href="#peddoc_diff.pedDoc.loadparms">loadparms</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.loadundo" href="#peddoc_diff.pedDoc.loadundo">loadundo</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.locate" href="#peddoc_diff.pedDoc.locate">locate</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.menuitem_response" href="#peddoc_diff.pedDoc.menuitem_response">menuitem_response</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.menuitem_response2" href="#peddoc_diff.pedDoc.menuitem_response2">menuitem_response2</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.normsel" href="#peddoc_diff.pedDoc.normsel">normsel</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.on_drag_data_received" href="#peddoc_diff.pedDoc.on_drag_data_received">on_drag_data_received</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.on_drag_drop" href="#peddoc_diff.pedDoc.on_drag_drop">on_drag_drop</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.on_drag_motion" href="#peddoc_diff.pedDoc.on_drag_motion">on_drag_motion</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.overwrite_done" href="#peddoc_diff.pedDoc.overwrite_done">overwrite_done</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.pix2pos" href="#peddoc_diff.pedDoc.pix2pos">pix2pos</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.pix2xpos" href="#peddoc_diff.pedDoc.pix2xpos">pix2xpos</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.pix2ypos" href="#peddoc_diff.pedDoc.pix2ypos">pix2ypos</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.poprclick" href="#peddoc_diff.pedDoc.poprclick">poprclick</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.poprclick2" href="#peddoc_diff.pedDoc.poprclick2">poprclick2</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.poprclick3" href="#peddoc_diff.pedDoc.poprclick3">poprclick3</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.popspell" href="#peddoc_diff.pedDoc.popspell">popspell</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.prompt_save" href="#peddoc_diff.pedDoc.prompt_save">prompt_save</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.rclick_action" href="#peddoc_diff.pedDoc.rclick_action">rclick_action</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.save" href="#peddoc_diff.pedDoc.save">save</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.saveas" href="#peddoc_diff.pedDoc.saveas">saveas</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.savebackup" href="#peddoc_diff.pedDoc.savebackup">savebackup</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.savemacro" href="#peddoc_diff.pedDoc.savemacro">savemacro</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.saveorg" href="#peddoc_diff.pedDoc.saveorg">saveorg</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.saveparms" href="#peddoc_diff.pedDoc.saveparms">saveparms</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.saveundo" href="#peddoc_diff.pedDoc.saveundo">saveundo</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.scroll_event" href="#peddoc_diff.pedDoc.scroll_event">scroll_event</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.search" href="#peddoc_diff.pedDoc.search">search</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.search_again" href="#peddoc_diff.pedDoc.search_again">search_again</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.set_caret" href="#peddoc_diff.pedDoc.set_caret">set_caret</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.set_caret_middle" href="#peddoc_diff.pedDoc.set_caret_middle">set_caret_middle</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.set_changed" href="#peddoc_diff.pedDoc.set_changed">set_changed</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.set_diffs" href="#peddoc_diff.pedDoc.set_diffs">set_diffs</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.set_maxlinelen" href="#peddoc_diff.pedDoc.set_maxlinelen">set_maxlinelen</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.set_maxlines" href="#peddoc_diff.pedDoc.set_maxlines">set_maxlines</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.set_nocol" href="#peddoc_diff.pedDoc.set_nocol">set_nocol</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.set_tablabel" href="#peddoc_diff.pedDoc.set_tablabel">set_tablabel</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.setcol" href="#peddoc_diff.pedDoc.setcol">setcol</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.setfont" href="#peddoc_diff.pedDoc.setfont">setfont</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.showcol" href="#peddoc_diff.pedDoc.showcol">showcol</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.showtab" href="#peddoc_diff.pedDoc.showtab">showtab</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.size_alloc" href="#peddoc_diff.pedDoc.size_alloc">size_alloc</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.size_request" href="#peddoc_diff.pedDoc.size_request">size_request</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.start_edit" href="#peddoc_diff.pedDoc.start_edit">start_edit</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.start_external" href="#peddoc_diff.pedDoc.start_external">start_external</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.start_term" href="#peddoc_diff.pedDoc.start_term">start_term</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.toggle_ro" href="#peddoc_diff.pedDoc.toggle_ro">toggle_ro</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.update_bar2" href="#peddoc_diff.pedDoc.update_bar2">update_bar2</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.vscroll_cb" href="#peddoc_diff.pedDoc.vscroll_cb">vscroll_cb</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.walk_func" href="#peddoc_diff.pedDoc.walk_func">walk_func</a></code></li>
<li><code><a title="peddoc_diff.pedDoc.writeout" href="#peddoc_diff.pedDoc.writeout">writeout</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>