<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>peddoc API documentation</title>
<meta name="description" content="This module is the heart of the editor. Maintains
buffer that is
continually updated to the screen. With the help of sublasses, it draws text,
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>peddoc</code></h1>
</header>
<section id="section-intro">
<p>This module is the heart of the editor. Maintains
buffer that is
continually updated to the screen. With the help of sublasses, it draws text,
undeline, squiggly, syntax coloring etc &hellip; etc.</p>
<p>It also maintains and draws cursor, cursor shape &hellip; etc. Loads Saves
files, file meta information, undo / redo information.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

from __future__ import absolute_import, print_function

import os
import time
import string
import pickle
import re
import platform
import subprocess
import threading

import py_compile

import gi;  gi.require_version(&#34;Gtk&#34;, &#34;3.0&#34;)
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import GLib
from gi.repository import GObject
from gi.repository import Pango

import cairo

gi.require_version(&#39;PangoCairo&#39;, &#39;1.0&#39;)
from gi.repository import PangoCairo

from pedlib import  pedconfig
from pedlib import  peddraw
from pedlib import  pedxtnd
from pedlib import  pedync
from pedlib import  pedspell
from pedlib import  pedcolor
from pedlib import  pedmenu
from pedlib import  pedundo
from pedlib import  pedmisc
from pedlib import  pedtask
from pedlib import  pedfind
from pedlib import  pedplug

from pedlib.pedutil import *
from pedlib.keywords import *

__doc__ =  &#39;&#39;&#39;
    This module is the heart of the editor. Maintains  buffer that is
continually updated to the screen. With the help of sublasses, it draws text,
undeline, squiggly, syntax coloring etc ... etc.

  It also maintains and draws cursor, cursor shape ... etc. Loads Saves
  files, file meta information, undo / redo information.

&#39;&#39;&#39;

(TARGET_ENTRY_TEXT, TARGET_ENTRY_PIXBUF) = range(2)
(COLUMN_TEXT, COLUMN_PIXBUF) = range(2)
DRAG_ACTION = Gdk.DragAction.COPY

VSCROLLGAP  = 2             # Gap between the page boundary and ver. scroll
HSCROLLGAP  = 4             # Gap between the page boundary and hor. scroll
PAGEUP      = 20            # One page worth of scroll

# Do not redefine this here, as it is determined by the gtk (pango) lib
#TABSTOP = 8                 # One tab stop worth of spaces

# On version 0.21 (and after) we force GTK to assume our idea of tabstop.
# Even though we do not draw the tabs with GTK it is cleaner (simpler)
# this way. (See mess on tabs before V21)
TABSTOP = 4                 # One tab stop worth of spaces

# Profile line, use it on bottlenecks Widget set_a
#got_clock = time.clock()
# profiled code here
#print(  &#34;Str&#34;, time.clock() - got_clock)

# Globals

last_scanned = None

# Colors for the text, configure the defaults here

FGCOLOR     = &#34;#000000&#34;
FGCOLORRO   = &#34;#888888&#34;
RFGCOLOR    = &#34;#fefefe&#34;
BGCOLOR     = &#34;#fefefe&#34;
RBGCOLOR    = &#34;#aaaaff&#34;
CBGCOLOR    = &#34;#ff8888&#34;
KWCOLOR     = &#34;#88aaff&#34;
CLCOLOR     = &#34;#880000&#34;
COCOLOR     = &#34;#4444ff&#34;
STCOLOR     = &#34;#ee44ee&#34;
STRIPCOLOR  = &#34;#eeeeee&#34;

CARCOLOR = &#34;#4455dd&#34;

# UI specific values:

DRAGTRESH = 3                   # This many pixels for drag highlight

# ------------------------------------------------------------------------

class pedDoc(Gtk.DrawingArea, peddraw.peddraw, pedxtnd.pedxtnd, pedtask.pedtask):

    &#39;&#39;&#39; We create a custom class for display, as we want a text editor that
    can take thousands of lines.
    &#39;&#39;&#39;

    def __init__(self, buff, mained, readonly = False):

        # Save params
        self.mained = mained
        self.readonly = readonly
        self.ext = &#34;&#34;
        # Gather globals
        self.keyh = pedconfig.conf.keyh
        self.acth = pedconfig.conf.acth

        self.lastkey = &#39; &#39;
        self.second = False
        self.strip = 50
        # Init vars
        self.xpos = 0; self.ypos = 0
        self.changed = False
        self.src_changed = False
        self.needscan = True
        self.record = False
        self.recarr = []                # Macros  recording
        self.undoarr = []               # Undo
        self.redoarr = []               # Redo
        self.queue = []                 # Idle tasks
        self.colsel = False
        self.oldsearch = &#34;&#34;
        self.oldgoto = &#34;&#34;
        self.oldrep = &#34;&#34;
        self.doidle = 0
        self.xsel = -1; self.ysel = -1
        self.xsel2 = -1; self.ysel2 = -1
        self.mx = -1; self.my = -1
        self.caret = []; self.caret.append(0); self.caret.append(0)
        self.focus = False
        self.insert = True
        self.startxxx = -1;  self.startyyy = -1
        self.hex = False
        self.colflag = True
        self.acorr = False
        self.scol = False
        self.accum = []
        self.tokens = []
        self.ularr = []
        self.bigcaret = False
        self.stab = False
        self.oneshot = False
        self.honeshot = False
        self.caretshot = False
        self.initial_undo_size = 0
        self.initial_redo_size = 0
        self.spell = False
        self.spellmode = False
        self.start_time = time.time()
        self.shift = False
        # Init configurables
        self.vscgap = VSCROLLGAP
        self.hscgap = HSCROLLGAP
        self.pgup  = PAGEUP
        self.tabstop = TABSTOP
        # Process buffer into list
        self.text = buff
        self.maxlinelen = 0
        self.maxlines = 0
        self.fired = 0
        self.countup = 0
        self.nokey = False
        self.newword = False
        self.scrtab = False
        self.stat = None
        self.sep = &#34;\n&#34;
        self.tts = None
        self.lastcmd = &#34;&#34;
        self.caps = False
        self.scr = False
        self.lastevent = None
        self.hhh = self.www = 0
        self.diffmode = 0
        self.diffpane = False
        self.webwin = None
        self.nomenu = False
        self.FGCOLOR    = FGCOLOR
        self.FGCOLORRO  = FGCOLORRO
        self.RFGCOLOR   = RFGCOLOR
        self.BGCOLOR    = BGCOLOR
        self.RBGCOLOR   = RBGCOLOR
        self.CBGCOLOR   = CBGCOLOR
        self.KWCOLOR    = KWCOLOR
        self.CLCOLOR    = CLCOLOR
        self.COCOLOR    = COCOLOR
        self.STCOLOR    = STCOLOR
        self.STRIPCOLOR = STRIPCOLOR
        self.currback  =  0

        self.drag = False
        self.text_fillcol = 40
        self.clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
        #self.stopthread = False

        # Parent widget
        Gtk.DrawingArea.__init__(self)
        self.set_can_focus(True)
        peddraw.peddraw.__init__(self, self)

        # Our font
        fsize  =  pedconfig.conf.sql.get_int(&#34;fsize&#34;)
        fname  =  pedconfig.conf.sql.get_str(&#34;fname&#34;)
        if fsize == 0: fsize = 20
        if fname == &#34;&#34;: fname = &#34;Monospace&#34;

        self.setfont(fname, fsize)

        if self.readonly:
            self.set_tooltip_text(&#34;Read only buffer&#34;)

        # Create scroll items
        sm = len(self.text) + self.get_height() / self.cyy + 10
        self.hadj = Gtk.Adjustment(value=0, lower=0, upper=self.maxlinelen,
                            step_increment = 1, page_increment = 15, page_size = 25)
        self.vadj = Gtk.Adjustment(value=0, lower=0, upper=sm,
                            step_increment = 1, page_increment = 15, page_size = 25)

        self.vscroll = Gtk.VScrollbar(adjustment=self.vadj)
        self.hscroll = Gtk.HScrollbar(adjustment=self.hadj)

        # We connect scrollers after construction
        self.hadj.connect(&#34;value-changed&#34;, self.hscroll_cb)
        self.vadj.connect(&#34;value-changed&#34;, self.vscroll_cb)

        self.set_events(Gdk.EventMask.ALL_EVENTS_MASK)

        #self.colormap = Gtk.widget_get_default_colormap()
        self.setcol()

        # Set default background color
        if self.readonly:
            #color = self.colormap.alloc_color(&#34;#d8d8d8&#34;)
            #self.modify_bg(Gtk.STATE_NORMAL, color)
            pass

        #self.connect(&#34;expose-event&#34;, self.area_expose_cb)
        self.connect(&#34;draw&#34;, self.draw_event)
        self.connect(&#34;motion-notify-event&#34;, self.area_motion)
        self.connect(&#34;button-press-event&#34;, self.area_button)
        self.connect(&#34;button-release-event&#34;, self.area_button)

        # This was needed as ALT-a ... ALT-b stopped working;
        # Now getting key from main window
        #self.connect(&#34;key-press-event&#34;, self.area_key)
        #self.connect(&#34;key-release-event&#34;, self.area_key)

        self.connect(&#34;focus&#34;, self.area_focus)
        self.connect(&#34;configure_event&#34;, self.configure_event)
        self.connect(&#34;size-allocate&#34;, self.size_alloc)
        self.connect(&#34;scroll-event&#34;, self.scroll_event)
        self.connect(&#34;focus-in-event&#34;, self.focus_in_cb)
        self.connect(&#34;focus-out-event&#34;, self.focus_out_cb)

        self.drag_dest_set(0, [], 0)
        self.connect(&#39;drag-motion&#39;, self.on_drag_motion)
        self.connect(&#39;drag-drop&#39;, self.on_drag_drop)
        self.connect(&#34;drag-data-received&#34;, self.on_drag_data_received)
        self.connect(&#34;drag-data-get&#34;, self.on_drag_data_get)
        self.connect(&#34;destroy&#34;, self.destroy_cb)

    def run_keytime(self):
        global last_scanned
        last_scanned = &#34;&#34;
        if not self.mained.mac:
            GLib.timeout_add(300, keytime, self, 0)
        pass

    def destroy_cb(self, arg):
        #print(&#34;dest&#34;, arg)
        #self.stopthread = True
        pass

    def on_drag_data_get(self, widget, drag_context, data, info, time):
        #print(&#34;Drag data get entry&#34;)
        if self.xsel == -1 or self.ysel == -1:
            return
        # Normalize
        xssel = min(self.xsel, self.xsel2)
        xesel = max(self.xsel, self.xsel2)
        yssel = min(self.ysel, self.ysel2)
        yesel = max(self.ysel, self.ysel2)

        cnt = yssel; cnt2 = 0; cumm = &#34;&#34;
        while True:
            if cnt &gt; yesel: break

            #self.pad_list(self, cnt)
            line = self.text[cnt]
            if self.colsel:
                frag = line[xssel:xesel]
            else :                                  # startsel - endsel
                if cnt == yssel and cnt == yesel:   # sel on the same line
                    frag = line[xssel:xesel]
                elif cnt == yssel:                  # start line
                    frag = line[xssel:]
                elif cnt == yesel:                  # end line
                    frag = line[:xesel]
                else:
                    frag = line[:]

            if cnt2: frag = &#34;\n&#34; + frag
            cumm += frag
            cnt += 1; cnt2 += 1

        data.set_text(cumm, -1)

    def on_drag_motion(self, widgt, context, c, y, time):
        Gdk.drag_status(context, Gdk.DragAction.COPY, time)
        return True

    def on_drag_drop(self, widget, context, xx, yy, time):
        #print(&#34;xy&#34;, xx // self.cxx , yy // self.cyy);
        self.set_caret(self.xpos + xx // self.cxx, self.ypos + yy // self.cyy)
        widget.drag_get_data(context, context.list_targets()[-1], time)

    def inserttext(self, xtext):

        &#39;&#39;&#39; Insert text at current point &#39;&#39;&#39;

        newtxt = xtext.split(&#34;\n&#34;) + []
        ycoord = self.ypos + self.caret[1]
        #ycoord = self.ypos + y

        xidx = self.caret[0] + self.xpos;
        yidx = self.caret[1] + self.ypos

        tmptext = self.text[:ycoord]
        self.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
        for aa in newtxt:
            self.undoarr.append((xidx, yidx, pedundo.ADDED  \
                + pedundo.CONTFLAG, aa))
            yidx += 1
            tmptext.append(aa)
        tmptext += self.text[ycoord:]
        self.text = tmptext

        self.changed = True
        self.set_caret(self.xpos + self.caret[0],
                    self.ypos + self.caret[1] + len(newtxt))

        mlen = self.calc_maxline()

        # Set up scroll bars
        self.set_maxlinelen(mlen, False)
        #self.set_maxlines(len(self.text), False)
        self.invalidate()

    def on_drag_data_received(self, widget, drag_context, x, y, data, info, time):

        &#39;&#39;&#39; Drag and drop here &#39;&#39;&#39;

        #print(&#34;Received data:&#34;, data, data.get_data_type(), x, y, info)
        if info == TARGET_ENTRY_TEXT:
            if str(data.get_data_type()) == &#34;text/plain&#34;:
                xtext = data.get_text()
                if xtext:
                    #print(&#34;Received text: %s&#34; % xtext[:48])
                    self.inserttext(xtext)

            if str(data.get_data_type()) == &#34;text/uri-list&#34;:
                xuris = data.get_uris()
                #print(&#34;got uri&#34;, xuris)
                uuu = &#34;file://&#34;
                for aa in xuris:
                    if aa[:7] != uuu:
                        continue
                    try:
                        xfname = aa[7:]
                        try:
                            xstat = os.stat(xfname)
                        except:
                            pass
                        print(&#34;drop xfname&#34;, xfname, xstat)
                        if xstat.st_size &gt; 100000:
                            pedync.message(&#34;\nDragged file is too big.\n&#34;
                                &#34;To open anyway, use the regular open function\n\n&#34;  )
                            continue

                        fp = open(xfname)
                        xtext = fp.read()
                        fp.close()
                        self.inserttext(xtext)
                    except:
                        print(&#34;Cannot open dragged file.&#34;)
                        self.mained.update_statusbar(&#34;Cannot open dragged file. &#39;%s&#39;&#34; % xfname)


        elif info ==  TARGET_ENTRY_PIXBUF:
            pixbuf = data.get_pixbuf()
            width = pixbuf.get_width()
            height = pixbuf.get_height()
            print(&#34;Received pixbuf with width %spx and height %spx&#34; % (width, height))

        Gtk.drag_finish(drag_context, True, False, time)

    def setcol(self):

        &#39;&#39;&#39; Customize your colors here &#39;&#39;&#39;

        ccc = pedconfig.conf.sql.get_str(&#34;fgcolor&#34;)
        if ccc == &#34;&#34;:
            self.fgcolor  = pedcolor.str2float(FGCOLOR)
        else:
            self.fgcolor  = pedcolor.str2float(ccc)
        #print( &#34;fgcol&#34;, self.fgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;fgcolorro&#34;)
        if ccc == &#34;&#34;:
            self.fgcolorro  = pedcolor.str2float(FGCOLORRO)
        else:
            self.fgcolorro  = pedcolor.str2float(ccc)
        #print( &#34;fgcolro&#34;, self.fgcolorro, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;rbgcolor&#34;)
        if ccc == &#34;&#34;:
            self.rbgcolor = pedcolor.str2float(RBGCOLOR)
        else:
            self.rbgcolor = pedcolor.str2float(ccc)
        #print( &#34;rgbcolor&#34;, self.rbgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;bgcolor&#34;)
        if ccc == &#34;&#34;:
            self.bgcolor = pedcolor.str2float(BGCOLOR)
        else:
            self.bgcolor = pedcolor.str2float(ccc)
        #print( &#34;bgcolor&#34;, self.bgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;cbgcolor&#34;)
        if ccc == &#34;&#34;:
            self.cbgcolor = pedcolor.str2float(CBGCOLOR)
        else:
            self.cbgcolor = pedcolor.str2float(ccc)
        #print( &#34;cbgcolor&#34;, self.cbgcolor, ccc)

        self.stripcolor = pedcolor.str2float(STRIPCOLOR)

        ccc = pedconfig.conf.sql.get_str(&#34;kwcolor&#34;)
        if ccc == &#34;&#34;:
            self.kwcolor = pedcolor.str2float(KWCOLOR)
        else:
            self.kwcolor = pedcolor.str2float(ccc)
        #print( &#34;load kwcolor&#34;, self.kwcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;clcolor&#34;)
        if ccc == &#34;&#34;:
            self.clcolor = pedcolor.str2float(CLCOLOR)
        else:
            self.clcolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;cocolor&#34;)
        if ccc == &#34;&#34;:
            self.cocolor = pedcolor.str2float(COCOLOR)
        else:
            self.cocolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;stcolor&#34;)
        if ccc == &#34;&#34;:
            self.stcolor = pedcolor.str2float(STCOLOR)
        else:
            self.stcolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;carcolor&#34;)
        if ccc == &#34;&#34;:
            self.carcolor = pedcolor.str2float(CARCOLOR)
        else:
            self.carcolor = pedcolor.str2float(ccc)

    #def printrect(self, ttt,  rrr):
    #    print(&#34;rect&#34;, ttt, rrr.x / Pango.SCALE, rrr.y /Pango.SCALE,
    #            rrr.width / Pango.SCALE, rrr.height / Pango.SCALE)

    def setfont(self, fam, size):

        self.fd = Pango.FontDescription()

        self.fd.set_family(fam)
        # Will not wotk right on the MAC if simple set_size used
        self.fd.set_absolute_size(size * Pango.SCALE)

        self.pangolayout = self.create_pango_layout(&#34;a&#34;)
        self.pangolayout.set_font_description(self.fd)

        #print(&#34;pc&#34;, dir(PangoCairo))
        #print()
        #fm = Pango.FontMap()
        #ccc = Pango.create_context(fm)
        # Get Pango steps
        #self.cxx, self.cyy = self.pangolayout.get_pixel_size()
        (pr, lr) = self.pangolayout.get_extents()
        #self.printrect(&#34;pix&#34;, pr)
        #self.printrect(&#34;log&#34;, lr)

        self.cxx = lr.width / Pango.SCALE; self.cyy = lr.height / Pango.SCALE

        # Get Pango tabs
        self.tabarr = Pango.TabArray(80, False)
        #for aa in range(self.tabarr.get_size()):
        #    self.tabarr.set_tab(aa, Pango.TAB_LEFT, aa * TABSTOP * self.cxx * Pango.SCALE)

        self.pangolayout.set_tabs(self.tabarr)
        ts = self.pangolayout.get_tabs()

        &#39;&#39;&#39;if ts != None:
            al, self.tabstop = ts.get_tab(1)
        self.tabstop /= self.cxx * Pango.SCALE&#39;&#39;&#39;

        # Also set stip offset
        self.strip = 4 * self.cxx + 8

    def  set_maxlinelen(self, mlen = -1, ignore = True):
        if mlen == -1: self.calc_maxline()
        self.maxlinelen = mlen
        self.oneshot = ignore
        #value, lower, upper, step_increment, page_increment, page_size)
        #self.hadj.set_all(0, 0, self.maxlinelen * 2, 1, 15, 25)
        self.hadj.set_value(0)
        self.hadj.set_lower(0)
        self.hadj.set_upper(self.maxlinelen * 2)
        self.hadj.set_step_increment(1)
        self.hadj.set_page_increment(15)
        self.hadj.set_page_size(25)

    def  set_maxlines(self, lines = 0, ignore = True):
        self.maxlines = len(self.text) + self.get_height() / self.cyy + 25
        self.oneshot = ignore
        #self.vadj.set_all(0, 0, self.maxlines, 1, 15, 25)
        self.vadj.set_value(0)
        self.vadj.set_lower(0)
        self.vadj.set_upper(self.maxlines)
        self.vadj.set_step_increment(1)
        self.vadj.set_page_increment(15)
        self.vadj.set_page_size(25)

    def locate(self, xstr):
        #print( &#34;locate &#39;&#34; + xstr +&#34;&#39;&#34;)
        cnt = 0; cnt2 = 0; idx = 0; found = 0
        for line in self.text:
            if xstr == line:
                self.gotoxy(idx, cnt, len(xstr), True)
                found = 1
                break
            cnt += 1
        if not found:
            xstr2 = xstr.lstrip().replace(&#34;\t&#34;, &#34; &#34;)
            for line2 in self.text:
                idx2 = line2.find(xstr2)
                if idx2 &gt;= 0:
                    self.gotoxy(idx2, cnt2, len(xstr2), True)
                    break
                cnt2 += 1

    def focus_out_cb(self, widget, event):
        #print( &#34;focus_out_cb&#34;, widget, event)
        self.focus = False

    def focus_in_cb(self, widget, event):
        #print (&#34;focus_in_cb&#34;, self.fname)
        self.focus = True
        try:
            if os.path.isfile(self.fname):
                os.chdir(os.path.dirname(self.fname))
                xstat = os.stat(self.fname)
                if not self.readonly:
                    #print(self.fname, &#34;stat&#34;, self.stat.st_mtime, &#34;xstat&#34;, xstat.st_mtime)
                    if self.stat.st_mtime !=  xstat.st_mtime:
                        rrr = pedync.yes_no_cancel(&#34;File changed outside PyEdPro&#34;,
                            &#34;&#39;%s&#39;\n&#34; \
                            &#34;changed outside PyEdPro.&#34; \
                            &#34;Reload?&#34; % self.fname, False)
                        if rrr == Gtk.ResponseType.YES:
                            if pedconfig.conf.verbose:
                               print(&#34;Reloading&#34;, self.fname)
                            self.savebackup()
                            self.saveparms()

                            # Is it already loaded? ... close
                            #nn = self.notebook.get_n_pages()
                            #fname2 = os.path.realpath(self.fname)
                            #for aa in range(nn):
                            #    vcurr = self.notebook.get_nth_page(aa)
                            #    if vcurr.area.fname == fname2:
                            #        if pedconfig.conf.verbose:
                            #            print(&#34;Closing &#39;&#34;+ fname2 + &#34;&#39;&#34;)
                            #        #vcurr.area.closedoc(noprompt = True)
                            #        #self.mained.close_document(self)

                            #usleep(100)
                            self.loadfile(self.fname, reload = True)
                            self.loadparms()

                # Update stat info
                self.stat = xstat
        except:
            put_exception(&#34;cmp mtime&#34;)
            pass

        self.update_bar2()
        self.needscan = True
        self.do_chores()
        #self.fired = 3

    def grab_focus_cb(self, widget):
        #print( &#34;grab_focus_cb&#34;, widget)
        pass

    def area_enter(self, widget, event):
        #print( &#34;area_enter&#34;)
        pass

    def area_leave(self, widget, event):
        #print( &#34;area_leave&#34;)
        pass

    def scroll_event(self, widget, event):
        #print( &#34;scroll_event&#34;, event, event.direction)
        xidx = self.xpos + self.caret[0]
        yidx = self.ypos + self.caret[1]
        if event.direction == Gdk.ScrollDirection.SMOOTH:
            flag, directx, directy = event.get_scroll_deltas()
            if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
                yidx += 10 * int(directy)
            elif event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                yidx += 5 * int(directy)
            else:
                yidx += int(directy)
        else:
            #print( &#34;type&#34;, type(event.type))
            #print(&#34;truth&#34;, isinstance(event.type, Gdk.EventType))
            if event.direction == Gdk.ScrollDirection.UP:
                yidx -= int(self.pgup / 2)
            else:
                yidx += int(self.pgup / 2)

        self.set_caret(xidx, yidx)
        self.invalidate()

    def hscroll_cb(self, widget):
        #print( &#34;hscroll_cb&#34;, widget.get_value())

        # Skip one callback
        if self.honeshot:
            self.honeshot = False; return
        xidx = int(widget.get_value())

        #print( &#34;hscroll_cb ok&#34;, widget.get_value())
        self.set_caret(xidx, self.ypos + self.caret[1])
        self.invalidate()

        #print( &#34;vscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.oneshot:
            self.oneshot = False; return
        #print( &#34;vscroll_cb ok&#34;, widget.get_value())
        yidx = int(widget.get_value())
        self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
        self.invalidate()

    def vscroll_cb(self, widget):
        #print( &#34;vscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.oneshot:
            self.oneshot = False; return
        #print( &#34;vscroll_cb ok&#34;, widget.get_value())
        yidx = int(widget.get_value())
        self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
        self.invalidate()

    def size_request(self, widget, req):
        #print( &#34;size_request&#34;, req)
        pass

    def size_alloc(self, widget, req):
        #print( &#34;size_alloc&#34;, req)
        pass

    def configure_event(self, widget, event):
        #print( &#34;configure_event&#34;, event)
        #self.grab_focus()
        #self.width = 0; self.height = 0
        #self.invalidate()
        #print( self, event)
        pass

    def draw_event(self, pdoc, cr):

        self.hhh = self.get_height();  self.www = self.get_width()
        self.xlen = len(self.text)

        ctx = self.get_style_context()
        fg_color = ctx.get_color(Gtk.StateFlags.NORMAL)
        #bg_color = ctx.get_background_color(Gtk..NORMAL)

        # Paint white, ignore system BG
        #cr.set_source_rgba(255, 255, 255)
        # Paint prescribed color
        if self.readonly:
            # Slightly darker / lighter
            newcol =  list(self.bgcolor)
            for aa in range(len(newcol)):
                if newcol[aa] &gt; 0.5: newcol[aa] -= .08
                else: newcol[aa] += .2
            cr.set_source_rgba(*list(newcol))
        else:
            cr.set_source_rgba(*list(self.bgcolor))

        cr.rectangle( 0, 0, self.www, self.hhh)
        cr.fill()

        cr.set_source_rgba(*list(self.stripcolor))
        cr.rectangle( 0, 0, self.strip - 2, self.hhh)
        cr.fill()

        try:
            pedplug.predraw(self, cr)
        except:
            print(&#34;plugin failed&#34;, sys.exc_info())

        # Pre set for drawing
        #cr.set_source_rgba(*list(fg_color))
        # Paint prescribed color
        cr.set_source_rgba(*list(self.fgcolor))

        cr.move_to(0, 0)
        self.layout = PangoCairo.create_layout(cr)
        self.layout.set_font_description(self.fd)

        self.draw_maintext(cr)

        if not self.hex:
            # Do the text drawing in stages ...
            try:
                self.draw_selection(cr)
                self.draw_syntax(cr)
                self.draw_clsyntax(cr)
                self.draw_comments(cr)
                self.draw_spellerr(cr)
            except:
                print(&#34;Failed to draw colors&#34;, sys.exc_info())

        if self.startxxx != -1:
            self.gotoxy(self.startxxx, self.startyyy)
            self.startxxx = -1; self.startyyy = -1

        self.draw_caret(cr)

    def idle_queue(func):
        self.queue.append(func)
        #print( queue)

    def area_button(self, area, event):

        self.lastevent = event

        #if pedconfig.conf.pgdebug &gt; 5:
        #    print( &#34;Button press  &#34;, self, event.type, &#34; x=&#34;, event.x,
        #    &#34; y=&#34;, event.y)

        event.x = int(event.x) - self.strip
        event.y = int(event.y)

        if  event.type == Gdk.EventType.BUTTON_PRESS:
            if event.button == 1:
                #print( &#34;Left Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
                self.mx = int(event.x); self.my = int(event.y)
                xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
                # Find current pos, gather tabs, adjust back
                try:
                    line = self.text[self.ypos + yyy]
                except:
                    line = &#34;&#34;
                offs = calc_tabs2(line, xxx)

                # Are we in selection?
                #print( &#34;xxx&#34;, self.xpos + xxx, &#34;yyy&#34;, self.ypos + yyy)
                #rp = xxx + self.xpos
                #print( &#34;xpos&#34;, self.xpos, &#34;xxx&#34;, xxx, &#34;rp&#34;, rp)
                #print( line)
                #print( &#34;line part&#34;, &#34;&#39;&#34; + line[rp:rp+8] + &#34;&#39;&#34;)

                # Are we in selection?
                if self.xsel != -1:
                    #print(&#34;xsel&#34;, self.xsel, &#34;ysel&#34;, self.ysel)
                    #print(&#34;xsel2&#34;, self.xsel2, &#34;ysel2&#34;, self.ysel2)

                    xssel = min(self.xsel, self.xsel2)
                    xesel = max(self.xsel, self.xsel2)
                    yssel = min(self.ysel, self.ysel2)
                    yesel = max(self.ysel, self.ysel2)

                    if (self.ypos + yyy &gt;= yssel and self.ypos + yyy &lt;= yesel) and \
                         (self.xpos + xxx &gt;= xssel and self.xpos + xxx &lt;= xesel):
                        #print(&#34;in selection&#34;)
                        self.drag = True
                    else:
                        # Erase selection, pos cursor
                        self.clearsel()
                        self.set_caret(self.xpos + xxx - (offs - xxx),
                                     self.ypos + yyy )
                else:
                    self.set_caret(self.xpos + xxx - (offs - xxx),
                                 self.ypos + yyy )

                self.fired += 1
                self.run_keytime()
                #self.mained.threads.submit_job(keytime, self, None)

            if event.button == 3:
                #print( &#34;Right Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
                flag = False; xx = 0; yy = 0; zz = 0
                if self.spell:
                    yyy = int(self.ypos + self.get_height() / self.cyy)
                    for xaa, ybb, lcc in self.ularr:
                        # Look within visible range
                        if ybb &gt;= self.ypos and ybb &lt; yyy:
                            ybb -= self.ypos
                            xaa -= self.xpos; lcc -= self.xpos
                            xaa *= self.cxx ; ybb *= self.cyy
                            lcc *= self.cxx
                            yy2 = ybb + self.cyy

                            if self.intersect(xaa, ybb, lcc, yy2, event):
                                xx = int(xaa / self.cxx + self.xpos)
                                yy = int(ybb / self.cyy + self.ypos)
                                zz = int(lcc / self.cxx + self.xpos)
                                flag = True
                if flag:
                    line = self.text[yy]
                    #print( &#34;Spell delimit: &#39;&#34; + line[xx:zz] + &#34;&#39;&#34;)
                    self.xsel = xx;
                    self.xsel2 = zz

                    self.ysel = self.ysel2 = yy
                    self.spellstr = line[int(xx):int(zz)]
                    self.popspell(area, event, self.spellstr)
                else:
                    if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                        if self.xsel == -1:
                            yyy = int(event.y / self.cyy + self.ypos)
                            xxx = int(event.x / self.cxx + self.xpos)
                            line = self.text[yyy]
                            self.xsel, self.xsel2 = selasci2(line, xxx, &#34;_-&#34;)
                            self.ysel = self.ysel2 = yyy
                        else:
                            line = self.text[self.ysel]

                        strx = line[int(self.xsel):int(self.xsel2)]
                        #print(&#34;&#39;&#34; + strx + &#34;&#39;&#34;)
                        if strx:
                            self.poprclick2(area, event, strx)
                    else:
                        self.poprclick(area, event)

        elif  event.type == Gdk.EventType.BUTTON_RELEASE:
            #print( &#34;button release&#34;, event.button)
            self.mx = -1; self.my = -1
            self.scrtab = False
            self.drag = False
            ttt = &#34;Release&#34;
            xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;
            offs = calc_tabs2(line, xxx)
            self.set_caret(self.xpos + xxx - (offs - xxx),
                                     self.ypos + yyy )

        elif  event.type == Gdk.EventType._2BUTTON_PRESS:

            if pedconfig.conf.pgdebug &gt; 2:
                print (&#34;Double click %.2f %.2f&#34; % (event.x, event.y))

            self.mx = int(event.x); self.my = int(event.y)
            xxx = int(event.x / self.cxx)
            yyy = int(event.y / self.cyy)

            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;

            # Find current pos on tabbed line
            offs = calc_tabs2(line, xxx)
            self.set_caret(self.xpos + xxx - (offs - xxx), self.ypos + yyy )
            #self.set_caret(len(xxx2), yyy)

            # Erase selection
            if self.xsel != -1:
                self.clearsel()

            # Select word
            if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
                pedconfig.conf.keyh.acth.ctrl_b(self)
            else:
                pedconfig.conf.keyh.acth.alt_v(self)
            # Copy to clip

            if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                pedconfig.conf.keyh.acth.ctrl_c(self)

        else:
            print(&#34;Unexpected mouse op.&#34;)

        self.grab_focus()
        return True

    # See if point in rect
    def intersect(self, xx, yy, xx2, yy2, event):
        # Does X intersect?
        if event.x &gt; xx and event.x &lt; xx2:
            #print( &#34;x inter&#34;, xaa, lcc)
            # Does Y intersect?
            if event.y &gt; yy and event.y &lt; yy2:
                return True
        return False

    # Normalize
    def normsel(self):
        xssel = min(self.xsel, self.xsel2)
        xesel = max(self.xsel, self.xsel2)
        yssel = min(self.ysel, self.ysel2)
        yesel = max(self.ysel, self.ysel2)

        self.xsel  = xssel;  self.ysel  = yssel
        self.xsel2 = xesel;  self.ysel2 = yesel

    def pix2xpos(self, xx):
        return int(self.xpos + (xx-self.strip) / self.cxx)

    def pix2ypos(self, yy):
        return int(self.ypos + yy / self.cyy)

    def pix2pos(self, xx, yy):
        return int(self.xpos + (xx-self.strip) / self.cxx), int(self.ypos + yy / self.cyy)

    def area_motion(self, area, event):
        #print (&#34;motion event&#34;, event.state, event.x, event.y)
        if event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
            #print( &#34;motion event butt 1&#34;, event.state, event.x, event.y)
            if self.drag:
                #print (&#34;drag motion event&#34;, event.state, event.x, event.y)
                targ = Gtk.TargetList(); targ.add_text_targets(0)
                self.drag_begin(targ, Gdk.DragAction.COPY, 0, event)
                self.drag = False
                return

            if self.xsel == -1 and self.scrtab != True:
                begsel = False
                # Horiz drag - regular sel
                if abs(event.x - self.mx) &gt; DRAGTRESH:
                    self.colsel = False; begsel = True

                if begsel:
                    self.xsel = self.xsel2 = self.xpos + self.caret[0]
                    self.ysel = self.ysel2 = self.ypos + self.caret[1]
                    #print( &#34;colsel xsel, ysel&#34;, self.colsel, self.xsel, self.ysel)
                if self.scrtab == False:
                    # Vert drag - colsel
                    if abs(event.y - self.my) &gt; DRAGTRESH:
                        self.scrtab  = True
                        self.colsel = True

            if self.scrtab  == True:
                self.xsel = self.xsel2 = self.xpos + self.caret[0]
                self.ysel = self.ysel2 = self.ypos + self.caret[1]
                xidx = self.xpos + self.caret[0]
                yidx = self.ypos + self.caret[1]
                if  event.y &gt;  self.my:
                    yidx += 1
                if  event.y &gt;  self.my:
                    yidx -= 1
                self.set_caret(xidx, yidx)
                self.my = event.y

            if self.xsel != -1:
                # Already selected, mark
                self.ysel2 = self.pix2ypos(event.y)
                if self.ysel2 &lt; self.ysel:
                    self.xsel    = self.pix2xpos(event.x)
                else:
                    self.xsel2 = self.pix2xpos(event.x)

            self.invalidate()

        if event.state &amp; Gdk.ModifierType.SHIFT_MASK and \
            event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
            #print( &#34;Shift Drag&#34;, event.x, event.y)
            pass
        pass

    def gotoxy(self, xx, yy, sel = None, mid = False):

        #print (&#34;gotoxy&#34;, xx, yy)
        #xx +=  30
        # Contain
        ylen = len(self.text)
        xx2 = max(xx, 0);  yy2 = max(yy, 0)
        xx2 = min(xx, self.maxlinelen);  yy2 = min(yy, ylen)

        if sel:
            self.xsel = xx2; self.xsel2 = xx2 + sel
            self.ysel = yy2; self.ysel2 = yy2
            self.invalidate()
        #else:
        #    self.xsel = xx2; self.xsel2 = xx2
        #    self.ysel = yy2; self.ysel2 = yy2

        if mid:
            self.set_caret_middle(xx, yy)
        else:
            self.set_caret(xx, yy)

        self.invalidate()

    # --------------------------------------------------------------------

    def set_caret_middle(self, xx, yy, sel = None, quart = 2):

        &#39;&#39;&#39;  Goto position, and place it to upper half / quarter &#39;&#39;&#39;

        xx = int(xx); yy = int(yy)

        # Needs scroll?
        #xxx, yyy = self.get_size()
        xlen = len(self.text)

        # Put it back in view:
        off = (self.get_height() / self.cyy) / quart
        if yy &gt; off:
            self.ypos = int(yy - off)
        else:
            self.ypos = 0

        self.set_caret(xx, yy)
        self.invalidate()

    # Dimenswions in character cell
    def get_height_char(self):
        return self.get_height()  / self.cyy

    def get_width_char(self):
        return self.get_width() / self.cxx

    # --------------------------------------------------------------------

    def set_caret(self, xx, yy, ignore = False):

        &#39;&#39;&#39; Goto position, put caret (cursor) back to view, [vh]scrap
            distance from ends. This function was a difficult to write. :-{
            Note the trick with comparing old cursor pos for a hint on scroll
            direction.
            xx, yy - absolute position in the text buffer
        &#39;&#39;&#39;

        if self.caretshot:
            self.caretshot = False; return
        self.caretshot = ignore

        #print( &#34;set_caret&#34;, xx, yy)
        xx = int(xx); yy = int(yy)

        # Needs scroll?
        need_inval = False
        cww = self.get_width_char()
        chh = self.get_height_char()
        xlen = len(self.text)

        # ----------------------------------------------------------------
        # Put it back in view yyy:

        off = chh - self.vscgap
        if yy - self.ypos &gt; off:
            #print( &#34;Scroll from caret down&#34;)
            if yy &gt; self.ypos + self.caret[1]:
                #print( &#34;move d&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
                self.ypos = int(yy - off)
                need_inval = True
                # Force new spell check
                self.fired += 1
                self.run_keytime()
                #self.mained.threads.submit_job(keytime, self, None)

        if yy - self.ypos &lt; self.vscgap and self.ypos:
            #print( &#34;Scroll from caret up&#34;)
            if yy &lt; self.ypos + self.caret[1]:
                #print( &#34;move u&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
                self.ypos = int(yy - self.vscgap)
                self.ypos = int(max(self.ypos, 0))
                need_inval = True
                # Force new spell check
                self.fired += 1
                self.run_keytime()
                #self.mained.threads.submit_job(keytime, self, None)

        yy -= self.ypos
        if self.ypos &lt; 0: self.ypos = 0

        # ----------------------------------------------------------------
        # Put it back in view xxx:

        xoff = cww - self.hscgap - self.strip / self.cxx
        if  xx - self.xpos  &gt; xoff:
            #print( &#34;Scroll from caret right&#34;, &#34;xx&#34;, xx, &#34;xpos&#34;, self.xpos)
            if self.xpos + self.caret[0] &lt; xx:
                #print( &#34;moved r&#34;,  xx, self.caret[0], self.xpos)
                self.xpos =  int(xx - xoff)
                self.xpos = int(max(self.xpos, 0))
                need_inval = True

        if  xx - self.xpos &lt;  self.hscgap:
            #print( &#34;Scroll from caret left &#34;, xx, self.xpos)
            if self.xpos + self.caret[0] &gt; xx:
                #print( &#34;moved l&#34;, &#34;xx&#34;, xx, &#34;caret&#34;, self.caret[0], &#34;xpos&#34;, self.xpos)
                self.xpos = int(xx - self.hscgap)
                self.xpos = int(max(self.xpos, 0))
                need_inval = True

        xx -= self.xpos
        if self.xpos &lt; 0: self.xpos = 0

        oldx = self.caret[0] * self.cxx
        oldy = self.caret[1] * self.cyy

        # Cheat - invalidate all if tab is involved at old line
        try:
            line = self.text[oldy]
        except:
            line = &#34;&#34;; need_inval = True
        if line.find(&#34;\t&#34;) &gt;= 0:
            need_inval = True

        self.caret[0] = xx; self.caret[1] = yy

        # Low limit
        if self.caret[0] &lt; 0: self.caret[0] = 0
        if self.caret[1] &lt; 0: self.caret[1] = 0

        wxx = self.caret[0] * self.cxx
        wyy = self.caret[1] * self.cyy

        # Cheat - invalidate all if tab is involoved
        try:
            line = self.text[self.ypos + self.caret[1]]
        except:
            line = &#34;&#34;; need_inval = True
        if line.find(&#34;\t&#34;) &gt;= 0:
            need_inval = True

        # Optimize cursor movement invalidation
        &#39;&#39;&#39;if  not need_inval :
            rect = Gdk.Rectangle(wxx, wyy, self.cxx * self.cxx /2, self.cyy + 1)
            self.invalidate(rect)

            rect = Gdk.Rectangle(oldx, oldy, self.cxx + self.cxx /2 , self.cyy + 1)
            self.invalidate(rect)
        &#39;&#39;&#39;
        #self.invalidate(None)

        # Update scroll bars, prevent them from sending scroll message:
        self.oneshot = True; self.vscroll.set_value(self.ypos)
        self.honeshot = True; self.hscroll.set_value(self.xpos)

        self.update_bar2()

        if  need_inval or self.bigcaret:
            self.invalidate()

    def update_bar2(self):
        clip = pedconfig.conf.keyh.acth.currclip
        self.mained.update_statusbar2(self.caret[0] + self.xpos, \
                self.caret[1] + self.ypos, self.insert, len(self.text), clip,
                    self.caps, self.scr, self.colsel)

    def clearsel(self):
        old = self.xsel
        self.xsel  =  self.ysel = -1
        self.xsel2 =  self.ysel2 = -1
        if old != -1:
            self.invalidate()

    def is_c_like(self):

        &#39;&#39;&#39; Return True if &#39;C&#39; like file
            This is fooled by non extension items; not a big deal
            colors may get turned on ...
        &#39;&#39;&#39;
        #print(&#34;c like&#34;, self.fname)
        for aa in c_like_exts:
            eee = self.fname[-(len(aa)):]
            #print(&#34;eee&#34;, eee, aa)
            if aa == eee:
                #print(&#34;C Match&#34;, self.fname)
                return True
        return False

    def walk_func(self):

        #print( &#34;walk func&#34;)

        # ts2 ---------------------------------------------------
        sumw2 = []
        if self.text:
            sline = self.caret[1] + int(self.ypos)
            sline = max(sline, 0); sline = min(sline, len(self.text))
            #print( &#34;Start point&#34;, sline, self.text[sline])

            # Walk back to last function
            if self.is_c_like():
                try:
                    aa = 0; bb = 0
                    regex = re.compile(ckeywords)
                    for aa in range(sline - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break
                    if aa &gt; 0:
                        for bb in range(aa + 1, len(self.text)):
                            line = self.text[bb]
                            res = regex.search(line)
                            if res:
                                #print( &#34;end&#34;, line, res.start(), res.end())
                                break

                        regex2 = re.compile(localkwords)
                        for cc in range(aa + 1, bb - 1):
                            line = self.text[cc]
                            res = regex2.search(line)
                            if res:
                                #print( &#34;match&#34;, line, res.start(), res.end())
                                sumw2.append(line)

                except:
                    print(&#34;Exception in c func handler&#34;, sys.exc_info())
                    pass
            if &#34;.bas&#34; in self.fname.lower():
                try:
                    regex = re.compile(basekeywords)
                    for line in win.text:
                        res = regex.search(line)
                        if res:
                            #print( res, res.start(), res.end())
                            sumw.append(line)
                except:
                    print(&#34;Exception in bas func extraction handler&#34;, sys.exc_info())
                    pass
            if &#34;.py&#34; in self.fname.lower():
                try:
                    aa = 0; bb = 0
                    regex = re.compile(&#34;class&#34;)
                    for aa in range(int(sline) - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break

                    regex = re.compile(pykeywords2)
                    for aa in range(int(sline) - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break

                    if aa &gt; 0:
                        for bb in range(aa + 1, len(self.text)):
                            line = self.text[bb]
                            res = regex.search(line)
                            if res:
                                #print( &#34;end&#34;, line, res.start(), res.end())
                                break

                        regex2 = re.compile(localpywords)
                        for cc in range(aa + 1, bb - 1):
                            line = self.text[cc]
                            res = regex2.search(line)
                            if res:
                                #print( &#34;match&#34;, line, res.start(), res.end())
                                sumw2.append(line)

                except:
                    print(&#34;Exception in py func handler&#34;, sys.exc_info())
                    raise
                    pass
            else:
                pass

            # Always show todo
            got_todo = 0
            for line in self.text:
                if &#34;TODO&#34; in line:
                    if not got_todo:
                        got_todo = 1
                        sumw2.append(&#34;----------- TODO List ----------&#34;)
                    sumw2.append(line)

        try:
            self.mained.update_treestore2(sumw2)
        except:
            # This is normal, ignore it
            print(&#34;walk2&#34;, sys.exc_info())
            pass

    # Call key handler
    def area_key(self, area, event):

        #print (&#34;peddoc area_key&#34;, event.keyval)
        #return True # TEST

        # Restart timer ticks
        pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
        pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

        # Maintain a count of events, only fire only fire on the last one
        self.fired += 1
        self.run_keytime()

        #if not self.fired:
        #    self.mained.threads.submit_job(keytime, self, None)

        # The actual key handler
        try:
            self.keyh.handle_key(self, area, event)
        except:
            print(&#34;Key handler died at key&#34;, event.keyval, sys.exc_info())
            put_exception(&#34;key handler&#34;)

        #if event.type == Gdk.KEY_RELEASE:
        #    self.source_id = GObject.idle_add(self.idle_callback)

        # We handled it
        return True

     # Invalidate current line
    def inval_line(self):
        rect = Gdk.Rectangle()
        xx = self.caret[0] * self.cxx
        yy = self.caret[1] * self.cyy
        ww = self.get_width()
        hh = self.cyy
        #self.invalidate(rect)
        xx = 0
        self.queue_draw_area(xx, yy, ww, hh)

    def invalidate(self, rect = None):
        #print( &#34;Invalidate:&#34;, rect)
        if rect == None:
            self.queue_draw()
        else:
            self.queue_draw_area(rect.x, rect.y,
                            rect.width, rect.height)

    def area_focus(self, area, event):
        #print( &#34;ped doc area focus&#34;, event)
        return False

    # Add to user dictionary:
    def addict(self, widget, string, arg):
        #print( &#34;addict&#34;, arg)
        if not pedspell.append_user_dict(self, arg):
            self.mained.update_statusbar(&#34;Cannot append to user dict&#34;)
        else:
            self.mained.update_statusbar(&#34;Added &#39;%s&#39; to user dict&#34; % arg)
            self.newword = True

        # Force new spell check
        self.fired += 1
        self.run_keytime()
        #self.mained.threads.submit_job(keytime, self, None)

    def popspell(self, widget, event, xstr):
        # Create a new menu-item with a name...
        self.menu2 = Gtk.Menu()
        self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % xstr, None))
        self.menu2.append(self.create_menuitem(&#34;Add to Dict&#34;, self.addict, xstr))

        mi = self.create_menuitem(&#34;-------------&#34;, None)
        mi.set_sensitive(False)
        self.menu2.append(mi)

        strs = &#34;Creating suggestion list for &#39;{0:s}&#39;&#34;.format(self.spellstr)
        self.mained.update_statusbar(strs)
        arr = pedspell.suggest(self, xstr)

        if len(arr) == 0:
            self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
        else:
            for aa, bb in arr:
                self.menu2.append(self.create_menuitem
                        (bb, self.menuitem_response))

        self.menu2.popup(None, None, None, None, event.button, event.time)
        #self.mained.update_statusbar(&#34;Done menu popup.&#34;)

    def set_sidetab(self, arg1, arg2, arg3):
        # reset all
        #print(&#34;set_sidetab&#34;, arg1, arg2, arg3)
        www = self.mained.get_width()
        if arg3 == 0:
            if self.mained.hpaned3.get_position() &gt; www - 20:
                self.mained.hpaned3.set_position(www - www / 3)
            self.mained.update_statusbar(&#34;Sidetab buffer switched on.&#34;)
            self.mained.diffpane.area.loadbuff(self.text)
            self.mained.diffpane.area.fname = self.fname
            self.mained.diffpane.area.readonly = True

            usleep(100)
            self.gotoxy(self.xpos + self.caret[0], self.ypos + self.caret[1])
            self.mained.diffpane.area.xpos = self.xpos
            self.mained.diffpane.area.ypos = self.ypos
            self.mained.diffpane.area.gotoxy(
                         self.xpos + self.caret[0], self.ypos + self.caret[1])
            usleep(10)
            self.mained.diffpane.area.invalidate()
            pppp = self.notebook3.get_nth_page(0)
            lab = self.mained.make_label(&#34;ro &#34; + os.path.basename(self.fname))
            lab.set_tooltip_text(self.fname)
            self.notebook3.set_tab_label(pppp, lab)
        else:
            self.mained.hpaned3.set_position(www - 10)
            self.mained.update_statusbar(&#34;Sidetab buffer switched off.&#34;)
            pass

    def set_diffs(self, arg1, arg2, arg3):
        # reset all
        if arg3 == 0:
            nn = self.notebook.get_n_pages(); cnt = 0
            while True:
                if cnt &gt;= nn: break
                ppp = self.notebook.get_nth_page(cnt)
                ppp.area.diffmode = 0
                ppp.area.set_tablabel()
                cnt += 1
            www = self.mained.get_width()
            self.mained.hpaned3.set_position(www - 10)

        else:
            self.diffmode = arg3
            self.set_tablabel()

            got_src = 0; got_targ = 0; action_page = 0;
            src = &#34;&#34;; targ = &#34;&#34;
            srctxt = [] ;  targtxt = []
            action_tab = None

            # See if diff complete, put it in motion
            nn = self.notebook.get_n_pages(); cnt = 0
            while True:
                if cnt &gt;= nn: break
                ppp = self.notebook.get_nth_page(cnt)
                #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
                if ppp.area.diffmode == 1:
                    got_src = True
                    src = os.path.basename(ppp.area.fname)
                    srctxt = ppp.area.text

                if ppp.area.diffmode == 2:
                    got_targ = True
                    targ = os.path.basename(ppp.area.fname)
                    targtxt = ppp.area.text
                    action_page = cnt
                    action_tab = ppp

                if ppp.area.diffmode == 1:
                    got_src = True
                cnt += 1

            if got_src and got_targ:
                www = self.mained.get_width()
                if self.mained.hpaned3.get_position() &gt; www - 20:
                    self.mained.hpaned3.set_position(www - www / 3)

                self.mained.update_statusbar(    \
                            &#34;Diff started.  Source: &#39;%s&#39; Target: &#39;%s&#39;&#34; % (src, targ))

                pppp = self.notebook3.get_nth_page(0)
                self.notebook3.set_tab_label(pppp,
                            self.mained.make_label(&#34;&#39;&#34; + src + &#34;&#39; --vs-- &#39;&#34; + targ + &#34;&#39;&#34;))
                self.notebook.set_current_page(action_page)
                action_tab.area.diffx(srctxt, targtxt)

    # --------------------------------------------------------------------

    def diffx(self, srctxt, targtxt):
        arrx = []; forw = 0; forw2 = 0
        diffscan = 500
        for aa in range(len(targtxt)):
            try:
                if srctxt[aa + forw2] == targtxt[aa + forw]:
                    arrx.append(targtxt[aa + forw])
                    continue
                fff = False
                # Resync forward
                try:
                    for bb in range(diffscan):
                        ttt = targtxt[aa + forw + bb]
                        if srctxt[aa + forw2] == ttt:
                            for cc in range(bb):
                                strx = &#34; --ins-- [ &#34; + targtxt[aa + forw + cc] + &#34; ] &#34;
                                arrx.append(strx)
                            arrx.append(ttt)
                            forw += bb
                            #print(&#34;forward set&#34;, forw, ttt)
                            fff = True
                            break
                except:
                    pass #print(&#34;EOB while fw&#34;, ttt)

                if fff:
                    continue

                # Resync on the other file
                try:
                    for bb in range(diffscan):
                        ttt = srctxt[aa  + forw2 + bb]
                        if ttt ==  targtxt[aa + forw]:
                            for cc in range(bb):
                                strx = &#34; --del-- [ &#34; + srctxt[aa + forw2 + cc] + &#34; ] &#34;
                                arrx.append(strx)
                            arrx.append(targtxt[aa + forw])
                            forw2 += bb
                            #print(&#34;backward set&#34;, forw, ttt)
                            fff = True
                            break
                except:
                    pass #print(&#34;EOB while other fw&#34;)

                if fff:
                    continue

                # See if diff is small
                lendiff = len(srctxt[aa + forw2]) - len(targtxt[aa + forw])
                #print (&#34;lendiff&#34;, lendiff, srctxt[aa], targtxt[aa+forw])
                if abs(lendiff) &lt; 3:
                    strx = &#34; --chg-- [ &#34; + srctxt[aa + forw2] + &#34; ] &#34;
                else:
                    strx = &#34; --ins-- [ &#34; + targtxt[aa + forw] + &#34; ] &#34;
                    forw2 -= 1   # Stand still on the other
                arrx.append(strx)
                #print(&#34;could not resync&#34;)

            except:
                #print(&#34;Buffers are different lengths&#34;, sys.exc_info())
                pass

        self.mained.diffpane.area.loadbuff(arrx)
        usleep(100)
        self.gotoxy(self.xpos + self.caret[0], self.ypos + self.caret[1])

        self.mained.diffpane.area.xpos = self.xpos
        self.mained.diffpane.area.ypos = self.ypos
        self.mained.diffpane.area.gotoxy(
                         self.xpos + self.caret[0], self.ypos + self.caret[1])
        usleep(10)
        self.mained.diffpane.area.invalidate()


    def iterdocs(self, callb, arg):
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            callb(ppp.area, arg)
            cnt += 1

    def builddoc(self, ppp):
        if ppp.area.diffmode == 1:
            got_src = True
        if ppp.area.diffmode == 2:
            got_targ = True

    def set_ro(self, arg1, arg2, arg3):
        print(&#34;set_ro&#34;)

    def re_diff(self, arg1, arg2, arg3):
        got_src = 0; got_targ = 0; action_page = 0;
        src = &#34;&#34;; targ = &#34;&#34;
        srctxt = [] ;  targtxt = []
        action_tab = None

        # See if diff complete, put it in motion
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
                src = os.path.basename(ppp.area.fname)
                srctxt = ppp.area.text

            if ppp.area.diffmode == 2:
                got_targ = True
                targ = os.path.basename(ppp.area.fname)
                targtxt = ppp.area.text
                action_page = cnt
                action_tab = ppp

            if ppp.area.diffmode == 1:
                got_src = True
            cnt += 1

        if got_src and got_targ:
            www = self.mained.get_width()
            if self.mained.hpaned3.get_position() &gt; www - 20:
                self.mained.hpaned3.set_position(www - www / 3)

            self.mained.update_statusbar(    \
                        &#34;Diff re-started.  Source: &#39;%s&#39; Target: &#39;%s&#39;&#34; % (src, targ))

            self.notebook.set_current_page(action_page)
            action_tab.area.diffx(srctxt, targtxt)


    def poprclick3(self, event):
        #print (&#34;Making shift rclick3&#34;)
        if self.nomenu: return

        got_src = 0; got_targ = 0

        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
            if ppp.area.diffmode == 2:
                got_targ = True
            cnt += 1

        # Check if there is any:
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
            if ppp.area.diffmode == 2:
                got_targ = True
            cnt += 1

        self.menu3 = Gtk.Menu()
        if not got_src:
            self.menu3.append(self.create_menuitem(&#34;Set as Diff Source&#34;, self.set_diffs, 1))
        if not got_targ:
            self.menu3.append(self.create_menuitem(&#34;Set as Diff Target&#34;, self.set_diffs, 2))
        else:
            self.menu3.append(self.create_menuitem(&#34;Re-Diff Buffers&#34;,  self.re_diff, 0))

        self.menu3.append(self.create_menuitem(&#34;Stop Diffing&#34;,  self.set_diffs, 0))
        self.menu3.append(self.create_menuitem(&#34;- - - - - - - - - - - - - - - &#34;,  None, 0))
        self.menu3.append(self.create_menuitem(&#34;Show Buffer in Sidetab&#34;,  self.set_sidetab, 0))
        self.menu3.append(self.create_menuitem(&#34;Hide Sidetab&#34;,  self.set_sidetab, 1))

        #mi = self.create_menuitem(&#34;-------------&#34;, None)
        #mi.set_sensitive(False); self.menu3.append(mi)
        #self.menu3.append(self.create_menuitem(&#34;Toggle Read Only&#34;,  self.set_ro, 0))

        self.menu3.popup(None, None, None, None, event.button, event.time)

    def poprclick2(self, widget, event, strx):
        #print (&#34;Making shift rclick2&#34;)
        if self.nomenu: return

        self.menu2 = Gtk.Menu()
        self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % strx, None))
        mi = self.create_menuitem(&#34;-------------&#34;, None)
        mi.set_sensitive(False)
        self.menu2.append(mi)
        strs = &#34;Creating class list for &#39;{0:s}&#39;&#34;.format(strx)
        self.mained.update_statusbar(strs)
        arr = pedstruct.suggest(self, strx)
        if len(arr) == 0:
            self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
        else:
            for bb in arr:
                self.menu2.append(self.create_menuitem(bb, self.menuitem_response2))

        self.menu2.popup(None, None, None, None, event.button, event.time)

    def poprclick(self, widget, event):

        if self.nomenu: return

        #print (&#34;Making rclick&#34;)
        menu = self.build_menu(self, pedmenu.rclick_menu)
        menu.show_all()

        if event:
            menu.popup(None, None, None, None, event.button, event.time)
        else:
            event = Gdk.EventButton()
            menu.popup(None, None, None, None, event.button, event.time)

    def menuitem_response2(self, widget, stringx, arg):
        #print( &#34;menuitem response2 &#39;%s&#39;&#34; % stringx)
        #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)
        disp2 = Gdk.Display()
        disp = disp2.get_default()
        clip = Gtk.Clipboard.get_default(disp)
        stringx = stringx.strip()
        clip.set_text(stringx, len(stringx))
        strs = &#34;Copied to clipboard &#39;{0:s}&#39;&#34;.format(stringx)
        self.mained.update_statusbar(strs, True)

    def menuitem_response(self, widget, stringx, arg):
        #print( &#34;menuitem response &#39;%s&#39;&#34; % stringx)
        #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)

        # See if Capitalized or UPPERCASE :
        if self.spellstr[0] in string.ascii_uppercase:
            stringx = stringx.capitalize()

        if self.spellstr.isupper():
            stringx = stringx.upper()

        pedconfig.conf.keyh.acth.clip_cb(None, stringx, self, False)

        self.fired += 1
        self.run_keytime()
        #self.mained.threads.submit_job(keytime, self, None)

    def doc_activate_action(self, action):

        print(&#34;doc_activate_action&#34;)

        dialog = Gtk.MessageDialog(self, Gtk.DIALOG_DESTROY_WITH_PARENT,
            Gtk.ButtonsType.INFO, Gtk.ButtonsType.CLOSE,
            &#39;You activated action: &#34;%s&#34; of type &#34;%s&#34;&#39; % (action.get_name(), type(action)))
        # Close dialog on user response
        dialog.connect (&#34;response&#34;, lambda d, r: d.destroy())
        dialog.show()

    def rclick_action_doc(self, action, sss, ttt):

        if pedconfig.conf.verbose:
            print( &#34;rclick_action_doc&#34;, sss, ttt)

        if ttt == 1:
            self.mained.newfile()
        elif ttt == 3:
            self.mained.open()
        elif ttt == 4:
            self.mained.save()
        elif ttt == 5:
            self.mained.save(True)
        elif ttt == 7:
            self.mained.copy()
        elif ttt == 8:
            self.mained.cut()
        elif ttt == 9:
            self.mained.paste()
        elif ttt == 11:
            self.toggle_ro()
        elif ttt == 13:
            print(&#34;menu exit&#34;)
            self.mained.activate_exit()
        elif ttt == 14:
             pedconfig.conf.pedwin.start_term()
        elif ttt == 15:
            self.start_edit(self.fname)
        elif ttt == 16:
            self.mained.tts()
        elif ttt == 17:
            pedmisc.exec_test(self, &#34;rc&#34;)
        elif ttt == 18:
            self.start_external([&#34;libreoffice&#34;, &#34;--writer&#34;],
                                        [&#34;libreoffice&#34;, &#34;--writer&#34;])
        elif ttt == 19:
            self.start_m4filter()
        elif ttt == 20:
            self.start_mdfilter()
        elif ttt == 21:
            self.start_browser(self.fname)
        elif ttt == 22:
            self.start_htmlwin(self.fname)
        elif ttt == 23:
            self.start_htmlstr()
        elif ttt == 24:
            self.start_external([&#34;thunar&#34;, &#34;.&#34;], # Caja ?
                                        [&#34;explorer&#34;, &#34;&#34;])
        elif ttt == 25:
            self.rescan()
        elif ttt == 26:
            self.find(self)
        elif ttt == 27:
            #print(&#34;Alt-Y&#34;)
            self.check_syntax()
        else:
            print(&#34;peddoc: Invalid menu item selected&#34;, ttt)

    def rescan(self):
        global last_scanned
        last_scanned = &#34;&#34;
        run_async_time(self, 0)
        self.mained.update_statusbar(&#34;Started rescan ...&#34;)

    def toggle_ro(self):
        self.readonly = not self.readonly
        self.set_tablabel()
        arrx = [&#34;OFF&#34;, &#34;ON&#34;]
        self.mained.update_statusbar(&#34;Toggled read only to %s&#34; % arrx[self.readonly])

    def create_menuitem(self, string, action, arg = None):
        rclick_menu = Gtk.MenuItem(string)
        if action:
            rclick_menu.connect(&#34;activate&#34;, action, string, arg)
        rclick_menu.show()
        return rclick_menu

        # Create the menubar and toolbar
        action_group = Gtk.ActionGroup(&#34;DocWindowActions&#34;)
        action_group.add_actions(entries)
        return action_group

    def _fill(self, aa,  bb):
        ttt = str(bb).replace(&#34;&lt;control&gt;&#34;, &#34;CTRL+&#34;)
        ttt = str(ttt).replace(&#34;&lt;alt&gt;&#34;,     &#34;ALT+&#34;)
        ttt = str(ttt).replace(&#34;&lt;shift&gt;&#34;,   &#34;SHIFT+&#34;)
        fff = &#34; &#34; * (15 - len(aa))
        sss = aa + &#34;%s\t%s&#34; % (fff, ttt)
        return sss

    def build_menu(self, window, items):

        menu =  Gtk.Menu()
        for aa, bb, cc, dd, ee  in items:
            #print (&#34;menu item&#34;, aa)
            if ee == &#34;&lt;Separator&gt;&#34;:
                menu_item = Gtk.MenuItem.new_with_mnemonic(
                            &#34;----------------------------&#34;)
                menu_item.set_sensitive(False)
                menu_item.set_size_request(-1, 10)
                pass
            elif type(ee) == type(()):
                self.submenu =  Gtk.Menu()
                for aaa, bbb, ccc, ddd, eee  in ee:
                    #print (&#34;sub menu item&#34;, aaa)
                    sss = self._fill(aaa, bbb)
                    menu_subitem = Gtk.MenuItem.new_with_mnemonic(sss)
                    menu_subitem.connect(&#34;activate&#34;, self.rclick_action_doc, aaa, ddd )
                    self.submenu.append(menu_subitem)
                sss = self._fill(aa, bb)
                menu_item = Gtk.MenuItem.new_with_mnemonic(sss)
                menu_item.set_submenu(self.submenu)
            else:
                sss = self._fill(aa, bb)
                menu_item = Gtk.MenuItem.new_with_mnemonic(sss)
                menu_item.connect(&#34;activate&#34;, self.rclick_action_doc, aa, dd )
            menu.append(menu_item)
        return menu

    def get_size(self):
        rect = self.get_allocation()
        return rect.width, rect.height

    def get_height(self):
        rect = self.get_allocation()
        return rect.height

    def get_width(self):
        rect = self.get_allocation()
        return rect.width

    def save(self):

        #print (&#34;Saving&#34;, self.fname)
        # Always save params
        self.saveparms()
        strx = &#34;&#34;
        if not self.changed:
            strx = &#34;File is not modified.&#34;
            self.mained.update_statusbar(strx)
            return

        # Is this file named &#39;untitled&#39;?
        base, ext =  os.path.splitext(pedconfig.conf.UNTITLED)
        base1 = os.path.basename(self.fname)
        base2, ext2 =  os.path.splitext(base1)
        if base2[:len(base)] == base:
            self.file_dlg(Gtk.ResponseType.YES)
        else:
            bn = os.path.basename(self.fname)
            err = self.writeout()
            if  err[0]:
                strx = &#34;Saved &#39;{0:s}&#39;&#34;.format(self.fname)
            else:
                #strx = &#34;Not Saved &#39;{0:s}&#39; {1:s}&#34;.format(bn, err[1])
                strx = &#34;Not Saved &#34;

        if pedconfig.conf.verbose:
            print(strx)
        self.mained.update_statusbar(strx)

    def saveas(self):
        self.file_dlg(Gtk.ResponseType.YES)

    def coloring(self, flag):
        self.colflag = flag
        self.invalidate()

    def showcol(self, flag):
        self.scol = flag
        self.invalidate()

    def hexview(self, flag):
        self.hex = flag
        self.invalidate()

    def flash(self, flag):
        self.bigcaret = flag
        self.invalidate()

    def showtab(self, flag):
        self.stab = flag
        self.scol = flag
        self.invalidate()

    def closedoc(self, noprompt = False):
        #self.stopthread = True
        strx = &#34;Closing &#39;{0:s}&#39;&#34;.format(self.fname)
        if pedconfig.conf.verbose:
            print(&#34;Closing doc:&#34;, strx)
        self.mained.update_statusbar(strx)
        self.saveparms()

        rrr = self.prompt_save(noprompt)
        if not rrr:
            # Clear treestore(s)
            self.mained.update_treestore([])
            self.mained.update_treestore2([])
            # Add to accounting:
            logentry(&#34;Closed File&#34;, self.start_time, self.fname)
            self.mained.oh.add(self.fname)
        return rrr

    # --------------------------------------------------------------------

    def loadfile(self, filename, create = False, reload = True):

        &#39;&#39;&#39; Load file into this buffer, return False on failure &#39;&#39;&#39;

        if not self.second:
            if pedconfig.conf.verbose &gt; 1:
                print(&#34;Loading file&#34;, filename)

        if not reload:
            # Is it already loaded? ... activate
            nn = self.notebook.get_n_pages()
            fname2 = os.path.realpath(filename)
            for aa in range(nn):
                vcurr = self.notebook.get_nth_page(aa)
                if vcurr.area.fname == fname2:
                    if pedconfig.conf.verbose:
                        print(&#34;Already open &#39;&#34;+ fname2 + &#34;&#39;&#34;)
                    self.mained.update_statusbar(&#34;Already open, activating &#39;{0:s}&#39;&#34;.format(fname2))
                    vcurr = self.notebook.set_current_page(aa)
                    vcurr = self.notebook.get_nth_page(aa)
                    self.mained.mywin.set_focus(vcurr.vbox.area)
                    return

        if not self.second:
            self.mained.oh.add(filename)

        self.fname = filename
        self.ext = os.path.splitext(self.fname)[1].lower()

        try:
            self.stat = os.stat(self.fname)
        except:
            pass

        #pedync.message(&#34;\n   open / read file:  \n\n&#34;
        #                      &#34;      %s&#34; % self.fname)

        #print(&#34;stat&#34;, self.stat.st_mtime)
        self.start_time = time.time()
        if self.fname == &#34;&#34;:
            strx = &#34;Must specify file name.&#34;
            print(strx)
            self.mained.update_statusbar(strx)
            return False
        try:
            self.text = readfile(self.fname)
        except:
            errr = &#34;Cannot read file &#39;&#34; + self.fname + &#34;&#39;&#34; #, sys.exc_info()
            if pedconfig.conf.verbose:
                print(errr, sys.exc_info())

            #pedync.message(&#34;\n   Cannot open / read file:  \n\n&#34;
            #                  &#34;      %s&#34; % self.fname)

            print(errr)
            self.mained.update_statusbar(errr)
            usleep(10)
            return False

        #self.ularr.append((10 ,10, 20))
        mlen = self.calc_maxline()

        # Set up scroll bars
        self.set_maxlinelen(mlen, False)
        self.set_maxlines(len(self.text), False)

        # Increment and wrap backup
        if not self.second:
            hhh = hash_name(self.fname)
            self.currback  =  pedconfig.conf.sql.get_int(hhh + &#34;/bak&#34;)
            self.currback += 1
            if self.currback &gt;= 9:
                self.currback = 1
            pedconfig.conf.sql.put(hhh + &#34;/bak&#34;, self.currback)

        # File and backup related
        if not self.second:
            self.loadundo()
            self.loadparms()
            self.saveorg()
            self.savebackup()

            # Add to accounting:
            logentry(&#34;Opened File&#34;, self.start_time, self.fname)

        # Propagate main wndow ref
        pedmenu.mained = self.mained

        self.set_nocol()

        try:
            os.chdir(os.path.dirname(self.fname))
        except:
            print(&#34;Cannot change dir to file&#39;s cwd&#34;, sys.exc_info())

        # Let the system breed
        self.invalidate()
        usleep(10)

        # Color ON?
        self.set_nocol()

        # Are most of them read only?
        if not self.second:
            ro = 0
            nn = self.notebook.get_n_pages()
            for aa in range(nn):
                vcurr = self.notebook.get_nth_page(aa)
                #print(&#34;listing&#34;,  vcurr.area.fname, vcurr.area.readonly)
                if vcurr.area.readonly:
                    ro += 1
            #print(&#34;nn&#34;, nn, &#34;ro count&#34;, ro)
            if ro &gt; nn // 2:
                self.readonly = True

        return True

    def loadbuff(self, arrx):
        self.text = arrx
        usleep(1)
        # Set up scroll bars and other parameters
        mlen = self.calc_maxline()
        self.set_maxlinelen(mlen, False)
        self.set_maxlines(len(self.text), False)
        self.changed = True

    def calc_maxline(self):
        mlen = 0
        for aa in self.text:
            xlen = len(aa)
            if mlen &lt; xlen:
                mlen = xlen
        #self.maxlinelen = mlen
        return mlen

    # Load per file parms (cursor etc)
    def loadparms(self):
        hhh = hash_name(self.fname)

        self.startxxx  =  pedconfig.conf.sql.get_int(hhh + &#34;/xx&#34;)
        self.startyyy  =  pedconfig.conf.sql.get_int(hhh + &#34;/yy&#34;)
        #print(&#34;got cursor pos:&#34;, self.fname, self.startxxx, self.startyyy)
        # Note: we set cursor on first focus

    # Save per file parms (cursor, fname, etc)
    def  saveparms(self):
        hhh = hash_name(self.fname)
        pedconfig.conf.sql.put(hhh + &#34;/xx&#34;, self.xpos + self.caret[0])
        pedconfig.conf.sql.put(hhh + &#34;/yy&#34;, self.ypos + self.caret[1])
        pedconfig.conf.sql.put(hhh + &#34;/fname&#34;, self.fname)

        if self.tts:
            self.tts.haltspeak = True

        #print  &#34;saveparm&#34;, time.clock() - got_clock

    # Create org backup
    def saveorg(self):
        hhh = hash_name(self.fname) + &#34;.org&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        if not os.path.isfile(xfile):
            err =  writefile(xfile, self.text, &#34;\n&#34;)
            if not err[0]:
                print(&#34;Cannot create (org) backup file&#34;, xfile, sys.exc_info())
            # Make a log entry
            logfile = pedconfig.conf.log_dir + os.sep + &#34;backup.log&#34;
            xentry = &#34;Org &#34; + time.ctime() + &#34; &#34; + \
                self.fname + &#34; &#34; + os.path.basename(xfile)
            writefile(logfile, (xentry, &#34;&#34;), &#34;\n&#34;, &#34;a+&#34;)

   # Create backup
    def savebackup(self):

        hhh = hash_name(self.fname)
        self.startxxx  =  pedconfig.conf.sql.get_int(hhh + &#34;/xx&#34;)

        try:
            xfile = pedconfig.conf.data_dir + os.sep + hhh + &#34;_&#34; + str(self.currback) + &#34;.bak&#34;
            if pedconfig.conf.verbose &gt; 2:
                print(&#34;Saving backup: &#34;, xfile)

            try:
                writefile(xfile, self.text, &#34;\n&#34;)
            except:
                print(&#34;Cannot create backup file &#34; + xfile, sys.exc_info())
        except:
            print(&#34;Cannot back up &#34;, sys.exc_info())


    def prompt_save(self, askname = True):

        # Always save params
        self.saveparms()

        if not self.changed:
            #print &#34;not changed&#34;, self.fname
            return False

        msg = &#34;\nWould you like to save:\n\n  \&#34;%s\&#34; \n&#34; % self.fname
        rp = pedync.yes_no_cancel(&#34;pyedpro: Save File ?&#34;, msg)

        if rp == Gtk.ResponseType.YES:
            if askname:
                self.file_dlg(rp)
            else:
                self.save()
        elif rp == Gtk.ResponseType.NO:
            pass
        elif  rp == Gtk.ResponseType.CANCEL:
            return True
        else:
            print(&#34;warning: invalid response from dialog&#34;)

    def file_dlg(self, resp):
        #print &#34;File dialog&#34;
        if resp == Gtk.ResponseType.YES:
            but =   &#34;Cancel&#34;, Gtk.ResponseType.CANCEL,   \
                            &#34;Save File&#34;, Gtk.ResponseType.OK
            fc = Gtk.FileChooserDialog(&#34;Save file as ... &#34;, None,
                    Gtk.FileChooserAction.SAVE, but)
            #fc.set_do_overwrite_confirmation(True)

            fc.set_current_name(os.path.basename(self.fname))
            fc.set_current_folder(os.path.dirname(self.fname))
            fc.set_default_response(Gtk.ResponseType.OK)
            fc.connect(&#34;response&#34;, self.done_fc)
            fc.run()

    # --------------------------------------------------------------------

    def writeout(self):

        &#39;&#39;&#39; The actual savefile routine &#39;&#39;&#39;

        if pedconfig.conf.verbose:
            print(&#34;Saving &#39;&#34;+ self.fname + &#34;&#39;&#34;)

        if os.access(self.fname, os.F_OK):
            #wasread = os.access(self.fname, os.R_OK)
            #if not wasread:
            #    print(&#34;Cannot read &#39;%s&#39;&#34; % self.fname,  sys.exc_info())
            #    self.mained.update_statusbar(&#34;Cannot read &#39;%s&#39;&#34; % self.fname)
            #    return

            waswrite = os.access(self.fname, os.W_OK)
            if not waswrite:
                print(&#34;Cannot write &#39;%s&#39;&#34; % self.fname,  sys.exc_info())
                self.mained.update_statusbar(&#34;Cannot write &#39;%s&#39;&#34; % self.fname)
                self.savebackup()

                pedync.message(&#34;\n   Cannot Save file:  \n\n&#34;
                                  &#34;      &#39;%s&#39;&#34; % self.fname)
                return (False, &#34;Read only or Inaccessible file&#34;)

        err = writefile(self.fname, self.text, &#34;\n&#34;)
        #print(&#34;err writefile&#34;, err)
        if not err[0]:
            print(&#34;Cannot write &#39;%s&#39;&#34; % self.fname,  sys.exc_info())
            return

        self.set_changed(False)
        # Change access/ownership to group write
        try:
            ostat = os.stat(self.fname)
            os.chmod(self.fname, ostat.st_mode | stat.S_IWGRP)
        except:
            print(&#34;Cannot change group write on &#39;%s&#39;&#34; % self.fname,  sys.exc_info())

        self.saveundo();  self.saveparms(); self.set_tablabel()

        # Add to accounting:
        logentry(&#34;Wrote File&#34;, self.start_time, self.fname)

        # Update stat info
        self.stat = os.stat(self.fname)

        return err

    def delundo(self):
        self.undoarr = []; self.redoarr = []
        # Remove file
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        fh = open(xfile, &#34;w&#34;)
        fh.close()
        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        fh = open(xfile, &#34;w&#34;)
        fh.close()

    def saveundo(self):
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;wb&#34;)
            pickle.dump(self.undoarr, fh)
            fh.close()
        except:
            print(&#34;Cannot save undo file&#34;, sys.exc_info())
            put_exception(&#34;undo&#34;)


        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;wb&#34;)
            pickle.dump(self.redoarr, fh)
            fh.close()
        except:
            print(&#34;Cannot save redo file&#34;, sys.exc_info())

    def loadundo(self):
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;rb&#34;)
            try:
                self.undoarr = pickle.load(fh)
            except:
                pass
            fh.close()
        except:
            pass
            # Ignore it, not all files will have undo
            #print( &#34;Cannot load undo file&#34;, xfile)
        self.initial_undo_size = len(self.undoarr)

        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;rb&#34;)
            try:
                self.redoarr = pickle.load(fh)
            except:
                pass
            fh.close()
        except:
            pass
            # Ignore it, not all files will have redo
            #print( &#34;Cannot load redo file&#34;, xfile)
        self.initial_redo_size = len(self.redoarr)

    def done_fc(self, win, resp):
        #print( &#34;done_fc&#34;, win, resp)
        if resp == Gtk.ResponseType.OK:
            fname = win.get_filename()
            if not fname:
                print(&#34;Must have filename&#34;)
            else:
                if os.path.isfile(fname):
                    resp = pedync.yes_no_cancel(&#34;Overwrite File Prompt&#34;,
                                &#34;Overwrite existing file?\n &#39;%s&#39;&#34; % fname, False)
                    print(&#34;resp&#34;, resp)
                    if resp == Gtk.ResponseType.YES:
                        self.fname = fname
                        self.ext = os.path.splitext(self.fname)[1].lower()
                        self.writeout()
                        self.mained.update_statusbar(&#34;Saved under new filename &#39;%s&#39;&#34; % fname)
                    else:
                        self.mained.update_statusbar(&#34;No new file name supplied, cancelled &#39;Save As&#39;&#34;)
                else:
                    self.fname = fname
                    self.ext = os.path.splitext(self.fname)[1].lower()
                    self.writeout()

                pedconfig.conf.pedwin.mywin.set_title(&#34;pyedpro: &#34; + self.fname)

        win.destroy()

    def overwrite_done(self, win, resp, fname, win2):
        #print( &#34;overwrite done&#34;, resp)
        if resp == Gtk.ResponseType.YES:
            self.fname = fname
            self.ext = os.path.splitext(self.fname)[1].lower()
            self.writeout()
            self.set_nocol()
            win2.destroy()
        win.destroy()

    # --------------------------------------------------------------------

    def set_nocol(self):

        &#39;&#39;&#39; Turn off coloring if not python / c / sh / perl / header(s) &#39;&#39;&#39;

        colflag = False
        ext = os.path.splitext(self.fname)[1].lower()
        for aa in pedconfig.conf.color_on:
            if ext == aa:
                colflag = True
                break
        self.colflag = colflag


    def do_chores(self):
        #print( &#34;do_chores&#34;)
        if  not self.needscan:
            return
        self.needscan = False

        # Scan left pane
        pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
        pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

    def set_changed(self, flag):
        old = self.changed
        self.changed = flag
        # Exec actions:
        if old != self.changed:
            #print( &#34;Setting changed on &#34;, self.fname)
            self.set_tablabel()

    def set_tablabel(self):
        # Find me in tabs
        #print(&#34;Setting tablabels&#34;)
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            if ppp.area == self:
                self._setlabel(ppp)
                break
            cnt += 1
            #usleep(10)

    # Gdk.EventButton
    def doclabel_callb(self, widg, event):
        #print(&#34;doclabel_callb&#34;, event.button, event.type)
        if event.button == 3:
            #print(&#34;Right click&#34;, self.fname)
            self.poprclick3(event)

    def _setlabel(self, ppp):

        # Set label to tab
        ss = shortenstr(os.path.basename(self.fname), 24)
        if  self.changed:
            str2 = &#34;* &#34; + ss + &#34;  &#34;
        else:
            str2 = &#34;  &#34; + ss + &#34;  &#34;

        if  self.readonly:
            str3 = &#34;ro &#34; + str2
        else:
            str3 = &#34;  &#34; + str2

        if  self.diffmode == 1:
            str4 = &#34;Diff/Source: &#34; + str3
        elif  self.diffmode == 2:
            str4 = &#34;Diff/Target: &#34; + str3
        else:
            str4 = &#34;&#34; + str3

        label = Gtk.Label.new(str4)
        label.set_tooltip_text(self.fname)
        label.set_single_line_mode(True)

        eb = Gtk.EventBox(); eb.add(label)
        eb.connect_after(&#34;button-press-event&#34;, self.doclabel_callb)
        eb.set_above_child(True)

        image = Gtk.Image()
        image.set_from_stock(Gtk.STOCK_CLOSE, Gtk.IconSize.MENU)
        butt = Gtk.Button();  butt.add(image)
        butt.set_focus_on_click(False)
        butt.set_relief( Gtk.ReliefStyle.NONE)
        #rc = butt.get_modifier_style()
        #rc.xthickness = 1; rc.ythickness = 1
        #butt.modify_style(rc)

        butt.connect(&#34;clicked&#34;, self.close_button)
        butt.set_tooltip_text(&#34;Close &#39;%s&#39;&#34; % os.path.basename(self.fname))
        hbox = Gtk.HBox()
        hbox.pack_start(eb, 0, 0, 0)
        hbox.pack_start(butt, 0, 0, 0)
        hbox.show_all()
        self.notebook.set_tab_label(ppp, hbox)
        hbox.queue_draw()

        #usleep(10)
        #print(&#34;Setting tablabel&#34;, str4)

    def close_button(self, arg1):
        #print( &#34;close_button&#34;, arg1)
        # Select me first
        self.mained.close_document(self)

    # --------------------------------------------------------------------
    def savemacro(self):

        #print( &#34;Savemacro&#34;)

        if not self.recarr:
            print(&#34;Cannot save, nothing recorded yet.&#34;)
            pedync.message(&#34;\n   Cannot save macro: nothing recorder yet.  \n\n&#34;)
            return

        fname = &#34;untitled.mac&#34;
        xdir = pedconfig.conf.config_dir + &#34;/macros/&#34;
        xfile = pedconfig.conf.config_dir + &#34;/macros/&#34; + fname
        old = os.getcwd()
        try:
            os.chdir(os.path.dirname(xfile))
        except:
            print(&#34;No macros directory&#34;, sys.exc_info())

        warnings.simplefilter(&#34;ignore&#34;)
        buts =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Save Macro&#34;, Gtk.ButtonsType.OK
        fc = Gtk.FileChooserDialog(&#34;Save Macro&#34;, None, Gtk.FileChooserAction.SAVE, \
            buts)

        fc.set_current_folder(xdir)
        fc.set_current_name(os.path.basename(xfile))
        fc.set_default_response(Gtk.ButtonsType.OK)
        fc.connect(&#34;response&#34;, self.done_mac_fc, old)
        fc.run()
        warnings.simplefilter(&#34;default&#34;)

    def done_mac_fc(self, win, resp, old):
        #print(  &#34;done_mac_fc&#34;, resp)
        # Back to original dir
        os.chdir(os.path.dirname(old))
        if resp == Gtk.ButtonsType.OK:

            #print(&#34;saveing&#34;, self.recarr)

            try:
                fname = win.get_filename()
                if not fname:
                    print(&#34;Must have filename&#34;)
                else:
                    fh = open(fname, &#34;wb&#34;)
                    pickle.dump(self.recarr, fh)
                    fh.close()
            except:
                print(&#34;Cannot save macro file&#34;, sys.exc_info())
                self.mained.update_statusbar(&#34;Cannot save macro: &#39;%s&#39;&#34; \
                                % os.path.basename(fname))

        win.destroy()

    def loadmacro(self):
        #print( &#34;Loadmacro&#34;)

        xfile = pedconfig.conf.config_dir + &#34;/macros/&#34;
        old = os.getcwd()
        try:
            os.chdir(os.path.dirname(xfile))
        except:
            print(&#34;No macros directory&#34;, sys.exc_info())

        but =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Load Macro&#34;, Gtk.ButtonsType.OK
        fc = Gtk.FileChooserDialog(&#34;Load Macro&#34;, None, Gtk.FileChooserAction.OPEN, \
            but)

        fc.set_current_folder(xfile)
        #fc.set_current_folder(old)
        fc.set_default_response(Gtk.ButtonsType.OK)
        fc.connect(&#34;response&#34;, self.done_mac_open_fc, old)
        fc.run()

    def done_mac_open_fc(self, win, resp, old):

        #print(  &#34;done_mac_fc&#34;, resp)
        # Back to original dir
        os.chdir(os.path.dirname(old))

        if resp == Gtk.ButtonsType.OK:
            try:
                fname = win.get_filename()
                if not fname:
                    print(&#34;Must have filename&#34;)
                else:
                    fh = open(fname, &#34;rb&#34;)
                    self.recarr = pickle.load(fh)
                    fh.close()
                    #print(&#34;macro&#34;, self.recarr)

            except:
                print(&#34;Cannot load macro file&#34;, sys.exc_info())
                self.mained.update_statusbar(&#34;Cannot load macro: &#39;%s&#39;&#34; % os.path.basename(fname))

        win.destroy()

    def     find(self, dlg, flag = False):
        #print(&#34;find&#34;, dlg);
        pedfind.find(dlg, self, flag)

    # Refresh current search buffer
    def search_again(self):
        if len(self.accum) == 0:
            return

        if self.src_changed:
            self.search(self.srctxt, self.regex, self.boolcase, self.boolregex)

    # --------------------------------------------------------------------
    def search(self, srctxt, regex, boolcase, boolregex):

        # Remember old settings:
        self.srctxt = srctxt;       self.regex = regex
        self.boolcase = boolcase;   self.boolregex = boolregex
        self.src_changed = False

        self.accum = []

        curr  = self.caret[1] + self.ypos
        currx = self.caret[0] + self.xpos

        was = -1; cnt = 0; cnt2 = 0
        before = 0; after = 0
        marked = False

        for line in self.text:
            # Search one line for multiple matches
            mmm = src_line(line, cnt, srctxt, regex, boolcase, boolregex)

            # Add marker to current lin
            if cnt == curr:
                if not marked:
                    linex =  str(currx) + &#34;:&#34;  + str(cnt) +\
                         &#34;:&#34; + str(0) + &#34; &#34; +\
                             &#34;---- current cursor position ----&#34;
                    self.accum.append(linex)
                    marked = True

            # Mark the next match for the display
            if cnt &gt; curr and was == -1:
                was = cnt2
            if  mmm:
                #print(&#34;mmm&#34;, mmm);

                # Multiple counts may be there
                for sss in mmm:
                    cnt2 += 1
                    # Mark the counters
                    if cnt &lt;= curr:
                        before += 1
                    else:
                        after += 1
                    self.accum.append(sss)

            if cnt % 100 == 0:
                self.mained.update_statusbar(\
                            &#34;Searching at %d&#34; % cnt, True)
                usleep(1)
            cnt += 1

        #if not marked:
        #    self.accum.append(&#34; ---- current cursor position ---- &#34;)
        #    marked = True

        return was, cnt2, before, after

    def check_syntax(self):

        tempfile = &#34;tmp&#34;
        writefile(tempfile, self.text, &#34;\n&#34;)

        #print(&#34;Checking file&#34;, self.ext)

        if self.ext == &#34;.php&#34; or  self.ext == &#34;.inc&#34;:
            #print(&#34;Checking PHP file&#34;)
            try:
                comline = [&#34;php&#34;, &#34;-l&#34;, tempfile,]
                try:
                    ret = subprocess.Popen(comline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
                except:
                    print(&#34;Cannot check %s&#34; % str(comline), sys.exc_info())
                    pedync.message(&#34;\n   Cannot check %s \n\n&#34;  % str(comline) +
                               str(sys.exc_info()) )
                    return
                try:
                    outs, errs = ret.communicate()
                except:
                    print(&#34;Cannot communicate with %s&#34; % str(comline), sys.exc_info())
                    return

            except:
                print(&#34;Cannot execute %s&#34; % str(comline), sys.exc_info())
                pass

            #print(&#34;outs&#34;, outs, &#34;errs&#34;, errs)

            if errs == b&#34;&#34;:
                pedync.message(&#34;\n  PHP Syntax OK   \n&#34;)
                self.mained.update_statusbar(&#34;Syntax OK.&#34;)
            else:
                serr = str(errs)
                idx = serr.find(&#34;line &#34;)
                if idx:
                    print(&#34;idx&#34;, idx, &#34;line no&#34;, &#34;&#39;&#34; + serr[idx + 5:] + &#34;&#39;&#34;)
                    self.gotoxy(10, atoi(serr[idx + 5:]) - 1)

                print(&#34;Error on compile: &#39;&#34;, serr, &#34;&#39;&#34;)
                pedync.message(&#34;    &#34; + serr + &#34;    &#34;)


        elif self.ext == &#34;.py&#34;:
            try:
               py_compile.compile(&#39;tmp&#39;, doraise = True)
            except py_compile.PyCompileError as msg:

                self.mained.update_statusbar(&#34;Syntax error.&#34;)

                if sys.version_info.major &lt; 3:
                    try:
                        ln  = msg[2][1][1]; col = msg[2][1][2]
                        mmm = &#34;\n&#34; + msg[2][0] + &#34;\n\n    Ln: &#34; +  str(ln) + &#34; Col: &#34; + str(col)
                        self.gotoxy(col - 1, ln - 1)
                        pedync.message(&#34;    &#34; + mmm + &#34;    &#34;, msg[1])
                    except:
                        pedync.message(&#34; &#34; + str(msg) + &#34;  &#34;, &#34;Syntax Error&#34;)
                        #print(&#34;line&#34;, msg);
                        pass
                else:
                        print(&#34;Error on compile: &#39;&#34;, msg.args, &#34;&#39;&#34;)
                        zzz = str(msg.args[2]).split(&#34;(&#34;)
                        sss = zzz[1].split()[2].replace(&#34;)&#34;, &#34;&#34;)
                        #print (&#34;sss&#34;, sss)
                        try:
                            self.gotoxy(10, int(sss) - 1)
                        except:
                            pass
                        pedync.message(&#34;    &#34; + str(msg) + &#34;    &#34;)

            except:
                print(sys.exc_info())
            else:
                pedync.message(&#34;\n  PY Syntax OK   \n&#34;)
                self.mained.update_statusbar(&#34;Syntax OK.&#34;)
            finally:
                pass

        elif self.ext == &#34;.js&#34;:

            tempfile2 = &#34;tmp.js&#34;
            os.rename(tempfile, tempfile2)
            tempfile = tempfile2

            print(&#34;Checking JS file&#34;)
            try:
                comline = [&#34;node&#34;, &#34;--check&#34;, tempfile2,]
                try:
                    ret = subprocess.Popen(comline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
                except:
                    print(&#34;Cannot check %s&#34; % str(comline), sys.exc_info())
                    pedync.message(&#34;\n   Cannot check %s \n\n&#34;  % str(comline) +
                               str(sys.exc_info()) )
                    return
                try:
                    outs, errs = ret.communicate()
                except:
                    print(&#34;Cannot communicate with %s&#34; % str(comline), sys.exc_info())
                    return

            except:
                print(&#34;Cannot execute %s&#34; % str(comline), sys.exc_info())
                pass

            #print(&#34;outs&#34;, outs, &#34;errs&#34;, errs)

            if errs == b&#34;&#34;:
                pedync.message(&#34;\n  JS Syntax OK   \n&#34;)
                self.mained.update_statusbar(&#34;Syntax OK.&#34;)
            else:
                serr = str(errs)
                idx = serr.find(&#34;line &#34;)
                if idx:
                    #print(&#34;idx&#34;, idx, &#34;line no&#34;, &#34;&#39;&#34; + serr[idx + 5:] + &#34;&#39;&#34;)
                    self.gotoxy(10, atoi(serr[idx + 5:]) - 1)

                print(&#34;Error on compile: &#39;&#34;, serr, &#34;&#39;&#34;)
                pedync.message(&#34;    &#34; + serr + &#34;    &#34;)

        else:
            self.mained.update_statusbar(&#34;No Syntax check for this kind of file.&#34;)

        os.remove(tempfile)

# ---------------------------------------------------------------------

def run_async_time(win, arg):

    &#39;&#39;&#39;  Run this on an idle callback so the user can work
            while this is going &#39;&#39;&#39;

    global last_scanned

    #print( &#34;run_async_time enter&#34;, win.fname)

    if  last_scanned == win:
        #print(&#34;Not rescanning&#34;, win.fname)
        return

    last_scanned = win

    win.mained.start_tree()

    #print( &#34;run_sync_time&#34;, time.time())

    if not win.text:
        return

    sumw = [] ; lname = win.fname.lower()

    #print(&#34;lname&#34;, lname[-2:])

    # Added flex and yacc
    if &#34;.c&#34; in lname[-2:] or &#34;.h&#34; in lname[-2:] or &#34;.y&#34; \
        in lname[-2:] or &#34;.f&#34; in lname[-2:] or &#34;.php&#34; in lname[:-4]:
        try:
            regex = re.compile(ckeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in c func handler&#34;, sys.exc_info())
            pass

    elif &#34;.py&#34; in lname[-3:]:
        try:
            regex = re.compile(pykeywords2)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)

            regex3 = re.compile(pykeywords3)
            for line in win.text:
                res = regex3.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(&#34;    &#34; + line)
        except:
            print(&#34;Exception in py func handler&#34;, sys.exc_info())
            pass
    elif &#34;.html&#34; in lname[-5:]:
        #print(&#34;html file&#34;)
        try:
            regex = re.compile(htmlkeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in py func handler&#34;, sys.exc_info())
            pass
    elif &#34;.bas&#34; in lname[-4:]:
        try:
            regex = re.compile(basekeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in func extraction handler&#34;, sys.exc_info())
            pass
    elif &#34;.s&#34; in lname[-2:] or &#34;.asm&#34; in lname[-4:]:
        try:
            regex = re.compile(Skeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in func extraction handler&#34;, sys.exc_info())
            pass
    elif &#34;.txt&#34; in lname[-4:]:
        pass
    else:            # Default to &#39;C&#39; like syntax
        try:
            for kw in sumkeywords:
                for line in win.text:
                    if line.find(kw) &gt;= 0:
                        sumw.append(line)
        except:
            pass

        try:
            regex = re.compile(ckeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in c func handler&#34;, sys.exc_info())
            pass

    try:
        win.mained.update_treestore(sumw)
    except:
        # This is &#39;normal&#39;, ignore it
        print(&#34;run_async_time&#34;, sys.exc_info())
        pass

    #win.mained.update_statusbar(&#34;Rescan done.&#34;)

def keytime(self, arg):

    #print( &#34;keytime raw&#34;, time.ctime(), self.fired)
    #return

    if self.fired ==  1:
        #print( &#34;keytime&#34;, time.time(), self.fired)
        pedspell.spell(self, self.spellmode)
        self.walk_func()

    if self.fired:
        self.fired -= 1

    # Track this buffer
    #if self.diffmode == 2:
    #    self.mained.diffpane.area.xpos = self.xpos
    #    self.mained.diffpane.area.ypos = self.ypos
    #    self.mained.diffpane.area.set_caret(self.xpos + self.caret[0],
    #                                                self.ypos + self.caret[1], True)

    # Track pane buffer back to diff components
    if self.diffpane:
        got_src = 0; got_targ = 0
        src = &#34;&#34;; targ = &#34;&#34;
        srctxt = [] ;  targtxt = []
        dst_tab = None ; src_tab = None

        # See if diff complete, put it in motion
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            if ppp.area.diffmode == 1:
                got_src = True
                src = os.path.basename(ppp.area.fname)
                srctxt = ppp.area.text
                src_tab = ppp
            elif ppp.area.diffmode == 2:
                got_targ = True
                targ = os.path.basename(ppp.area.fname)
                targtxt = ppp.area.text
                dst_tab = ppp

            cnt += 1

        yyy = self.ypos +  self.caret[1]
        zzz = self.ypos +  self.caret[1]
        txt = &#34;&#34;
        for aa in range( self.ypos + self.caret[1]):
            try:
                txt = self.text[aa]
            except:
                pass
            if txt[:8] == &#34; --del--&#34;:
                yyy -= 1

            if txt[:8] == &#34; --ins--&#34;:
                zzz -= 1

        if got_targ:
            dst_tab.area.xpos = self.xpos
            dst_tab.area.ypos = self.ypos
            dst_tab.area.set_caret(self.xpos + self.caret[0], yyy, True)
        if got_src:
            src_tab.area.xpos = self.xpos
            src_tab.area.ypos = self.ypos
            src_tab.area.set_caret(self.xpos + self.caret[0], zzz, True)

def idle_callback(self, arg):

    &#39;&#39;&#39; Do Tasks  when the system is idle &#39;&#39;&#39;

    #print( &#34;Idle callback&#34;, self.fname)
    GLib.source_remove(self.source_id)
    try:
        # Mon 06.Sep.2021 always save
        if self.changed:
            hhh = hash_name(self.fname) + &#34;_&#34; + str(self.currback) + &#34;.sav&#34;
            xfile = pedconfig.conf.data_dir + os.sep + hhh
            err = writefile(xfile, self.text, &#34;\n&#34;)
            if err[0]:
                strx = &#34;Backed up file &#39;{0:s}&#39;&#34;.format(xfile)
                # Make a log entry
                logfile = pedconfig.conf.log_dir + os.sep + &#34;backup.log&#34;
                xentry = &#34;Sav &#34; + time.ctime() + &#34; &#34; + \
                    self.fname + &#34; &#34; + os.path.basename(xfile) + &#34;\n&#34;
                writefile(logfile, (xentry, &#34;&#34;), &#34;\n&#34;, &#34;a+&#34;)
            else:
                strx = &#34;Cannot back up file &#39;{0:s}&#39; {1:s}&#34;.format(xfile, err[1])

            self.mained.update_statusbar(strx)
    except:
        print(&#34;Exception in idle handler&#34;, sys.exc_info())

# Do Tasks2 when the system is idle

def idle_callback2(self, arg):
    #print( &#34;Idle callback2&#34;, arg)
    GLib.source_remove(self.source_id2)
    try:
        run_async_time(self, None)
    except:
        print(&#34;Exception in async handler&#34;, sys.exc_info())

# EOF</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="peddoc.idle_callback"><code class="name flex">
<span>def <span class="ident">idle_callback</span></span>(<span>self, arg)</span>
</code></dt>
<dd>
<div class="desc"><p>Do Tasks
when the system is idle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idle_callback(self, arg):

    &#39;&#39;&#39; Do Tasks  when the system is idle &#39;&#39;&#39;

    #print( &#34;Idle callback&#34;, self.fname)
    GLib.source_remove(self.source_id)
    try:
        # Mon 06.Sep.2021 always save
        if self.changed:
            hhh = hash_name(self.fname) + &#34;_&#34; + str(self.currback) + &#34;.sav&#34;
            xfile = pedconfig.conf.data_dir + os.sep + hhh
            err = writefile(xfile, self.text, &#34;\n&#34;)
            if err[0]:
                strx = &#34;Backed up file &#39;{0:s}&#39;&#34;.format(xfile)
                # Make a log entry
                logfile = pedconfig.conf.log_dir + os.sep + &#34;backup.log&#34;
                xentry = &#34;Sav &#34; + time.ctime() + &#34; &#34; + \
                    self.fname + &#34; &#34; + os.path.basename(xfile) + &#34;\n&#34;
                writefile(logfile, (xentry, &#34;&#34;), &#34;\n&#34;, &#34;a+&#34;)
            else:
                strx = &#34;Cannot back up file &#39;{0:s}&#39; {1:s}&#34;.format(xfile, err[1])

            self.mained.update_statusbar(strx)
    except:
        print(&#34;Exception in idle handler&#34;, sys.exc_info())</code></pre>
</details>
</dd>
<dt id="peddoc.idle_callback2"><code class="name flex">
<span>def <span class="ident">idle_callback2</span></span>(<span>self, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idle_callback2(self, arg):
    #print( &#34;Idle callback2&#34;, arg)
    GLib.source_remove(self.source_id2)
    try:
        run_async_time(self, None)
    except:
        print(&#34;Exception in async handler&#34;, sys.exc_info())</code></pre>
</details>
</dd>
<dt id="peddoc.keytime"><code class="name flex">
<span>def <span class="ident">keytime</span></span>(<span>self, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keytime(self, arg):

    #print( &#34;keytime raw&#34;, time.ctime(), self.fired)
    #return

    if self.fired ==  1:
        #print( &#34;keytime&#34;, time.time(), self.fired)
        pedspell.spell(self, self.spellmode)
        self.walk_func()

    if self.fired:
        self.fired -= 1

    # Track this buffer
    #if self.diffmode == 2:
    #    self.mained.diffpane.area.xpos = self.xpos
    #    self.mained.diffpane.area.ypos = self.ypos
    #    self.mained.diffpane.area.set_caret(self.xpos + self.caret[0],
    #                                                self.ypos + self.caret[1], True)

    # Track pane buffer back to diff components
    if self.diffpane:
        got_src = 0; got_targ = 0
        src = &#34;&#34;; targ = &#34;&#34;
        srctxt = [] ;  targtxt = []
        dst_tab = None ; src_tab = None

        # See if diff complete, put it in motion
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            if ppp.area.diffmode == 1:
                got_src = True
                src = os.path.basename(ppp.area.fname)
                srctxt = ppp.area.text
                src_tab = ppp
            elif ppp.area.diffmode == 2:
                got_targ = True
                targ = os.path.basename(ppp.area.fname)
                targtxt = ppp.area.text
                dst_tab = ppp

            cnt += 1

        yyy = self.ypos +  self.caret[1]
        zzz = self.ypos +  self.caret[1]
        txt = &#34;&#34;
        for aa in range( self.ypos + self.caret[1]):
            try:
                txt = self.text[aa]
            except:
                pass
            if txt[:8] == &#34; --del--&#34;:
                yyy -= 1

            if txt[:8] == &#34; --ins--&#34;:
                zzz -= 1

        if got_targ:
            dst_tab.area.xpos = self.xpos
            dst_tab.area.ypos = self.ypos
            dst_tab.area.set_caret(self.xpos + self.caret[0], yyy, True)
        if got_src:
            src_tab.area.xpos = self.xpos
            src_tab.area.ypos = self.ypos
            src_tab.area.set_caret(self.xpos + self.caret[0], zzz, True)</code></pre>
</details>
</dd>
<dt id="peddoc.run_async_time"><code class="name flex">
<span>def <span class="ident">run_async_time</span></span>(<span>win, arg)</span>
</code></dt>
<dd>
<div class="desc"><p>Run this on an idle callback so the user can work
while this is going</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_async_time(win, arg):

    &#39;&#39;&#39;  Run this on an idle callback so the user can work
            while this is going &#39;&#39;&#39;

    global last_scanned

    #print( &#34;run_async_time enter&#34;, win.fname)

    if  last_scanned == win:
        #print(&#34;Not rescanning&#34;, win.fname)
        return

    last_scanned = win

    win.mained.start_tree()

    #print( &#34;run_sync_time&#34;, time.time())

    if not win.text:
        return

    sumw = [] ; lname = win.fname.lower()

    #print(&#34;lname&#34;, lname[-2:])

    # Added flex and yacc
    if &#34;.c&#34; in lname[-2:] or &#34;.h&#34; in lname[-2:] or &#34;.y&#34; \
        in lname[-2:] or &#34;.f&#34; in lname[-2:] or &#34;.php&#34; in lname[:-4]:
        try:
            regex = re.compile(ckeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in c func handler&#34;, sys.exc_info())
            pass

    elif &#34;.py&#34; in lname[-3:]:
        try:
            regex = re.compile(pykeywords2)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)

            regex3 = re.compile(pykeywords3)
            for line in win.text:
                res = regex3.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(&#34;    &#34; + line)
        except:
            print(&#34;Exception in py func handler&#34;, sys.exc_info())
            pass
    elif &#34;.html&#34; in lname[-5:]:
        #print(&#34;html file&#34;)
        try:
            regex = re.compile(htmlkeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in py func handler&#34;, sys.exc_info())
            pass
    elif &#34;.bas&#34; in lname[-4:]:
        try:
            regex = re.compile(basekeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in func extraction handler&#34;, sys.exc_info())
            pass
    elif &#34;.s&#34; in lname[-2:] or &#34;.asm&#34; in lname[-4:]:
        try:
            regex = re.compile(Skeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in func extraction handler&#34;, sys.exc_info())
            pass
    elif &#34;.txt&#34; in lname[-4:]:
        pass
    else:            # Default to &#39;C&#39; like syntax
        try:
            for kw in sumkeywords:
                for line in win.text:
                    if line.find(kw) &gt;= 0:
                        sumw.append(line)
        except:
            pass

        try:
            regex = re.compile(ckeywords)
            for line in win.text:
                res = regex.search(line)
                if res:
                    #print( res, res.start(), res.end())
                    sumw.append(line)
        except:
            print(&#34;Exception in c func handler&#34;, sys.exc_info())
            pass

    try:
        win.mained.update_treestore(sumw)
    except:
        # This is &#39;normal&#39;, ignore it
        print(&#34;run_async_time&#34;, sys.exc_info())
        pass

    #win.mained.update_statusbar(&#34;Rescan done.&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="peddoc.pedDoc"><code class="flex name class">
<span>class <span class="ident">pedDoc</span></span>
<span>(</span><span>buff, mained, readonly=False)</span>
</code></dt>
<dd>
<div class="desc"><p>We create a custom class for display, as we want a text editor that
can take thousands of lines.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class pedDoc(Gtk.DrawingArea, peddraw.peddraw, pedxtnd.pedxtnd, pedtask.pedtask):

    &#39;&#39;&#39; We create a custom class for display, as we want a text editor that
    can take thousands of lines.
    &#39;&#39;&#39;

    def __init__(self, buff, mained, readonly = False):

        # Save params
        self.mained = mained
        self.readonly = readonly
        self.ext = &#34;&#34;
        # Gather globals
        self.keyh = pedconfig.conf.keyh
        self.acth = pedconfig.conf.acth

        self.lastkey = &#39; &#39;
        self.second = False
        self.strip = 50
        # Init vars
        self.xpos = 0; self.ypos = 0
        self.changed = False
        self.src_changed = False
        self.needscan = True
        self.record = False
        self.recarr = []                # Macros  recording
        self.undoarr = []               # Undo
        self.redoarr = []               # Redo
        self.queue = []                 # Idle tasks
        self.colsel = False
        self.oldsearch = &#34;&#34;
        self.oldgoto = &#34;&#34;
        self.oldrep = &#34;&#34;
        self.doidle = 0
        self.xsel = -1; self.ysel = -1
        self.xsel2 = -1; self.ysel2 = -1
        self.mx = -1; self.my = -1
        self.caret = []; self.caret.append(0); self.caret.append(0)
        self.focus = False
        self.insert = True
        self.startxxx = -1;  self.startyyy = -1
        self.hex = False
        self.colflag = True
        self.acorr = False
        self.scol = False
        self.accum = []
        self.tokens = []
        self.ularr = []
        self.bigcaret = False
        self.stab = False
        self.oneshot = False
        self.honeshot = False
        self.caretshot = False
        self.initial_undo_size = 0
        self.initial_redo_size = 0
        self.spell = False
        self.spellmode = False
        self.start_time = time.time()
        self.shift = False
        # Init configurables
        self.vscgap = VSCROLLGAP
        self.hscgap = HSCROLLGAP
        self.pgup  = PAGEUP
        self.tabstop = TABSTOP
        # Process buffer into list
        self.text = buff
        self.maxlinelen = 0
        self.maxlines = 0
        self.fired = 0
        self.countup = 0
        self.nokey = False
        self.newword = False
        self.scrtab = False
        self.stat = None
        self.sep = &#34;\n&#34;
        self.tts = None
        self.lastcmd = &#34;&#34;
        self.caps = False
        self.scr = False
        self.lastevent = None
        self.hhh = self.www = 0
        self.diffmode = 0
        self.diffpane = False
        self.webwin = None
        self.nomenu = False
        self.FGCOLOR    = FGCOLOR
        self.FGCOLORRO  = FGCOLORRO
        self.RFGCOLOR   = RFGCOLOR
        self.BGCOLOR    = BGCOLOR
        self.RBGCOLOR   = RBGCOLOR
        self.CBGCOLOR   = CBGCOLOR
        self.KWCOLOR    = KWCOLOR
        self.CLCOLOR    = CLCOLOR
        self.COCOLOR    = COCOLOR
        self.STCOLOR    = STCOLOR
        self.STRIPCOLOR = STRIPCOLOR
        self.currback  =  0

        self.drag = False
        self.text_fillcol = 40
        self.clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
        #self.stopthread = False

        # Parent widget
        Gtk.DrawingArea.__init__(self)
        self.set_can_focus(True)
        peddraw.peddraw.__init__(self, self)

        # Our font
        fsize  =  pedconfig.conf.sql.get_int(&#34;fsize&#34;)
        fname  =  pedconfig.conf.sql.get_str(&#34;fname&#34;)
        if fsize == 0: fsize = 20
        if fname == &#34;&#34;: fname = &#34;Monospace&#34;

        self.setfont(fname, fsize)

        if self.readonly:
            self.set_tooltip_text(&#34;Read only buffer&#34;)

        # Create scroll items
        sm = len(self.text) + self.get_height() / self.cyy + 10
        self.hadj = Gtk.Adjustment(value=0, lower=0, upper=self.maxlinelen,
                            step_increment = 1, page_increment = 15, page_size = 25)
        self.vadj = Gtk.Adjustment(value=0, lower=0, upper=sm,
                            step_increment = 1, page_increment = 15, page_size = 25)

        self.vscroll = Gtk.VScrollbar(adjustment=self.vadj)
        self.hscroll = Gtk.HScrollbar(adjustment=self.hadj)

        # We connect scrollers after construction
        self.hadj.connect(&#34;value-changed&#34;, self.hscroll_cb)
        self.vadj.connect(&#34;value-changed&#34;, self.vscroll_cb)

        self.set_events(Gdk.EventMask.ALL_EVENTS_MASK)

        #self.colormap = Gtk.widget_get_default_colormap()
        self.setcol()

        # Set default background color
        if self.readonly:
            #color = self.colormap.alloc_color(&#34;#d8d8d8&#34;)
            #self.modify_bg(Gtk.STATE_NORMAL, color)
            pass

        #self.connect(&#34;expose-event&#34;, self.area_expose_cb)
        self.connect(&#34;draw&#34;, self.draw_event)
        self.connect(&#34;motion-notify-event&#34;, self.area_motion)
        self.connect(&#34;button-press-event&#34;, self.area_button)
        self.connect(&#34;button-release-event&#34;, self.area_button)

        # This was needed as ALT-a ... ALT-b stopped working;
        # Now getting key from main window
        #self.connect(&#34;key-press-event&#34;, self.area_key)
        #self.connect(&#34;key-release-event&#34;, self.area_key)

        self.connect(&#34;focus&#34;, self.area_focus)
        self.connect(&#34;configure_event&#34;, self.configure_event)
        self.connect(&#34;size-allocate&#34;, self.size_alloc)
        self.connect(&#34;scroll-event&#34;, self.scroll_event)
        self.connect(&#34;focus-in-event&#34;, self.focus_in_cb)
        self.connect(&#34;focus-out-event&#34;, self.focus_out_cb)

        self.drag_dest_set(0, [], 0)
        self.connect(&#39;drag-motion&#39;, self.on_drag_motion)
        self.connect(&#39;drag-drop&#39;, self.on_drag_drop)
        self.connect(&#34;drag-data-received&#34;, self.on_drag_data_received)
        self.connect(&#34;drag-data-get&#34;, self.on_drag_data_get)
        self.connect(&#34;destroy&#34;, self.destroy_cb)

    def run_keytime(self):
        global last_scanned
        last_scanned = &#34;&#34;
        if not self.mained.mac:
            GLib.timeout_add(300, keytime, self, 0)
        pass

    def destroy_cb(self, arg):
        #print(&#34;dest&#34;, arg)
        #self.stopthread = True
        pass

    def on_drag_data_get(self, widget, drag_context, data, info, time):
        #print(&#34;Drag data get entry&#34;)
        if self.xsel == -1 or self.ysel == -1:
            return
        # Normalize
        xssel = min(self.xsel, self.xsel2)
        xesel = max(self.xsel, self.xsel2)
        yssel = min(self.ysel, self.ysel2)
        yesel = max(self.ysel, self.ysel2)

        cnt = yssel; cnt2 = 0; cumm = &#34;&#34;
        while True:
            if cnt &gt; yesel: break

            #self.pad_list(self, cnt)
            line = self.text[cnt]
            if self.colsel:
                frag = line[xssel:xesel]
            else :                                  # startsel - endsel
                if cnt == yssel and cnt == yesel:   # sel on the same line
                    frag = line[xssel:xesel]
                elif cnt == yssel:                  # start line
                    frag = line[xssel:]
                elif cnt == yesel:                  # end line
                    frag = line[:xesel]
                else:
                    frag = line[:]

            if cnt2: frag = &#34;\n&#34; + frag
            cumm += frag
            cnt += 1; cnt2 += 1

        data.set_text(cumm, -1)

    def on_drag_motion(self, widgt, context, c, y, time):
        Gdk.drag_status(context, Gdk.DragAction.COPY, time)
        return True

    def on_drag_drop(self, widget, context, xx, yy, time):
        #print(&#34;xy&#34;, xx // self.cxx , yy // self.cyy);
        self.set_caret(self.xpos + xx // self.cxx, self.ypos + yy // self.cyy)
        widget.drag_get_data(context, context.list_targets()[-1], time)

    def inserttext(self, xtext):

        &#39;&#39;&#39; Insert text at current point &#39;&#39;&#39;

        newtxt = xtext.split(&#34;\n&#34;) + []
        ycoord = self.ypos + self.caret[1]
        #ycoord = self.ypos + y

        xidx = self.caret[0] + self.xpos;
        yidx = self.caret[1] + self.ypos

        tmptext = self.text[:ycoord]
        self.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
        for aa in newtxt:
            self.undoarr.append((xidx, yidx, pedundo.ADDED  \
                + pedundo.CONTFLAG, aa))
            yidx += 1
            tmptext.append(aa)
        tmptext += self.text[ycoord:]
        self.text = tmptext

        self.changed = True
        self.set_caret(self.xpos + self.caret[0],
                    self.ypos + self.caret[1] + len(newtxt))

        mlen = self.calc_maxline()

        # Set up scroll bars
        self.set_maxlinelen(mlen, False)
        #self.set_maxlines(len(self.text), False)
        self.invalidate()

    def on_drag_data_received(self, widget, drag_context, x, y, data, info, time):

        &#39;&#39;&#39; Drag and drop here &#39;&#39;&#39;

        #print(&#34;Received data:&#34;, data, data.get_data_type(), x, y, info)
        if info == TARGET_ENTRY_TEXT:
            if str(data.get_data_type()) == &#34;text/plain&#34;:
                xtext = data.get_text()
                if xtext:
                    #print(&#34;Received text: %s&#34; % xtext[:48])
                    self.inserttext(xtext)

            if str(data.get_data_type()) == &#34;text/uri-list&#34;:
                xuris = data.get_uris()
                #print(&#34;got uri&#34;, xuris)
                uuu = &#34;file://&#34;
                for aa in xuris:
                    if aa[:7] != uuu:
                        continue
                    try:
                        xfname = aa[7:]
                        try:
                            xstat = os.stat(xfname)
                        except:
                            pass
                        print(&#34;drop xfname&#34;, xfname, xstat)
                        if xstat.st_size &gt; 100000:
                            pedync.message(&#34;\nDragged file is too big.\n&#34;
                                &#34;To open anyway, use the regular open function\n\n&#34;  )
                            continue

                        fp = open(xfname)
                        xtext = fp.read()
                        fp.close()
                        self.inserttext(xtext)
                    except:
                        print(&#34;Cannot open dragged file.&#34;)
                        self.mained.update_statusbar(&#34;Cannot open dragged file. &#39;%s&#39;&#34; % xfname)


        elif info ==  TARGET_ENTRY_PIXBUF:
            pixbuf = data.get_pixbuf()
            width = pixbuf.get_width()
            height = pixbuf.get_height()
            print(&#34;Received pixbuf with width %spx and height %spx&#34; % (width, height))

        Gtk.drag_finish(drag_context, True, False, time)

    def setcol(self):

        &#39;&#39;&#39; Customize your colors here &#39;&#39;&#39;

        ccc = pedconfig.conf.sql.get_str(&#34;fgcolor&#34;)
        if ccc == &#34;&#34;:
            self.fgcolor  = pedcolor.str2float(FGCOLOR)
        else:
            self.fgcolor  = pedcolor.str2float(ccc)
        #print( &#34;fgcol&#34;, self.fgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;fgcolorro&#34;)
        if ccc == &#34;&#34;:
            self.fgcolorro  = pedcolor.str2float(FGCOLORRO)
        else:
            self.fgcolorro  = pedcolor.str2float(ccc)
        #print( &#34;fgcolro&#34;, self.fgcolorro, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;rbgcolor&#34;)
        if ccc == &#34;&#34;:
            self.rbgcolor = pedcolor.str2float(RBGCOLOR)
        else:
            self.rbgcolor = pedcolor.str2float(ccc)
        #print( &#34;rgbcolor&#34;, self.rbgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;bgcolor&#34;)
        if ccc == &#34;&#34;:
            self.bgcolor = pedcolor.str2float(BGCOLOR)
        else:
            self.bgcolor = pedcolor.str2float(ccc)
        #print( &#34;bgcolor&#34;, self.bgcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;cbgcolor&#34;)
        if ccc == &#34;&#34;:
            self.cbgcolor = pedcolor.str2float(CBGCOLOR)
        else:
            self.cbgcolor = pedcolor.str2float(ccc)
        #print( &#34;cbgcolor&#34;, self.cbgcolor, ccc)

        self.stripcolor = pedcolor.str2float(STRIPCOLOR)

        ccc = pedconfig.conf.sql.get_str(&#34;kwcolor&#34;)
        if ccc == &#34;&#34;:
            self.kwcolor = pedcolor.str2float(KWCOLOR)
        else:
            self.kwcolor = pedcolor.str2float(ccc)
        #print( &#34;load kwcolor&#34;, self.kwcolor, ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;clcolor&#34;)
        if ccc == &#34;&#34;:
            self.clcolor = pedcolor.str2float(CLCOLOR)
        else:
            self.clcolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;cocolor&#34;)
        if ccc == &#34;&#34;:
            self.cocolor = pedcolor.str2float(COCOLOR)
        else:
            self.cocolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;stcolor&#34;)
        if ccc == &#34;&#34;:
            self.stcolor = pedcolor.str2float(STCOLOR)
        else:
            self.stcolor = pedcolor.str2float(ccc)

        ccc = pedconfig.conf.sql.get_str(&#34;carcolor&#34;)
        if ccc == &#34;&#34;:
            self.carcolor = pedcolor.str2float(CARCOLOR)
        else:
            self.carcolor = pedcolor.str2float(ccc)

    #def printrect(self, ttt,  rrr):
    #    print(&#34;rect&#34;, ttt, rrr.x / Pango.SCALE, rrr.y /Pango.SCALE,
    #            rrr.width / Pango.SCALE, rrr.height / Pango.SCALE)

    def setfont(self, fam, size):

        self.fd = Pango.FontDescription()

        self.fd.set_family(fam)
        # Will not wotk right on the MAC if simple set_size used
        self.fd.set_absolute_size(size * Pango.SCALE)

        self.pangolayout = self.create_pango_layout(&#34;a&#34;)
        self.pangolayout.set_font_description(self.fd)

        #print(&#34;pc&#34;, dir(PangoCairo))
        #print()
        #fm = Pango.FontMap()
        #ccc = Pango.create_context(fm)
        # Get Pango steps
        #self.cxx, self.cyy = self.pangolayout.get_pixel_size()
        (pr, lr) = self.pangolayout.get_extents()
        #self.printrect(&#34;pix&#34;, pr)
        #self.printrect(&#34;log&#34;, lr)

        self.cxx = lr.width / Pango.SCALE; self.cyy = lr.height / Pango.SCALE

        # Get Pango tabs
        self.tabarr = Pango.TabArray(80, False)
        #for aa in range(self.tabarr.get_size()):
        #    self.tabarr.set_tab(aa, Pango.TAB_LEFT, aa * TABSTOP * self.cxx * Pango.SCALE)

        self.pangolayout.set_tabs(self.tabarr)
        ts = self.pangolayout.get_tabs()

        &#39;&#39;&#39;if ts != None:
            al, self.tabstop = ts.get_tab(1)
        self.tabstop /= self.cxx * Pango.SCALE&#39;&#39;&#39;

        # Also set stip offset
        self.strip = 4 * self.cxx + 8

    def  set_maxlinelen(self, mlen = -1, ignore = True):
        if mlen == -1: self.calc_maxline()
        self.maxlinelen = mlen
        self.oneshot = ignore
        #value, lower, upper, step_increment, page_increment, page_size)
        #self.hadj.set_all(0, 0, self.maxlinelen * 2, 1, 15, 25)
        self.hadj.set_value(0)
        self.hadj.set_lower(0)
        self.hadj.set_upper(self.maxlinelen * 2)
        self.hadj.set_step_increment(1)
        self.hadj.set_page_increment(15)
        self.hadj.set_page_size(25)

    def  set_maxlines(self, lines = 0, ignore = True):
        self.maxlines = len(self.text) + self.get_height() / self.cyy + 25
        self.oneshot = ignore
        #self.vadj.set_all(0, 0, self.maxlines, 1, 15, 25)
        self.vadj.set_value(0)
        self.vadj.set_lower(0)
        self.vadj.set_upper(self.maxlines)
        self.vadj.set_step_increment(1)
        self.vadj.set_page_increment(15)
        self.vadj.set_page_size(25)

    def locate(self, xstr):
        #print( &#34;locate &#39;&#34; + xstr +&#34;&#39;&#34;)
        cnt = 0; cnt2 = 0; idx = 0; found = 0
        for line in self.text:
            if xstr == line:
                self.gotoxy(idx, cnt, len(xstr), True)
                found = 1
                break
            cnt += 1
        if not found:
            xstr2 = xstr.lstrip().replace(&#34;\t&#34;, &#34; &#34;)
            for line2 in self.text:
                idx2 = line2.find(xstr2)
                if idx2 &gt;= 0:
                    self.gotoxy(idx2, cnt2, len(xstr2), True)
                    break
                cnt2 += 1

    def focus_out_cb(self, widget, event):
        #print( &#34;focus_out_cb&#34;, widget, event)
        self.focus = False

    def focus_in_cb(self, widget, event):
        #print (&#34;focus_in_cb&#34;, self.fname)
        self.focus = True
        try:
            if os.path.isfile(self.fname):
                os.chdir(os.path.dirname(self.fname))
                xstat = os.stat(self.fname)
                if not self.readonly:
                    #print(self.fname, &#34;stat&#34;, self.stat.st_mtime, &#34;xstat&#34;, xstat.st_mtime)
                    if self.stat.st_mtime !=  xstat.st_mtime:
                        rrr = pedync.yes_no_cancel(&#34;File changed outside PyEdPro&#34;,
                            &#34;&#39;%s&#39;\n&#34; \
                            &#34;changed outside PyEdPro.&#34; \
                            &#34;Reload?&#34; % self.fname, False)
                        if rrr == Gtk.ResponseType.YES:
                            if pedconfig.conf.verbose:
                               print(&#34;Reloading&#34;, self.fname)
                            self.savebackup()
                            self.saveparms()

                            # Is it already loaded? ... close
                            #nn = self.notebook.get_n_pages()
                            #fname2 = os.path.realpath(self.fname)
                            #for aa in range(nn):
                            #    vcurr = self.notebook.get_nth_page(aa)
                            #    if vcurr.area.fname == fname2:
                            #        if pedconfig.conf.verbose:
                            #            print(&#34;Closing &#39;&#34;+ fname2 + &#34;&#39;&#34;)
                            #        #vcurr.area.closedoc(noprompt = True)
                            #        #self.mained.close_document(self)

                            #usleep(100)
                            self.loadfile(self.fname, reload = True)
                            self.loadparms()

                # Update stat info
                self.stat = xstat
        except:
            put_exception(&#34;cmp mtime&#34;)
            pass

        self.update_bar2()
        self.needscan = True
        self.do_chores()
        #self.fired = 3

    def grab_focus_cb(self, widget):
        #print( &#34;grab_focus_cb&#34;, widget)
        pass

    def area_enter(self, widget, event):
        #print( &#34;area_enter&#34;)
        pass

    def area_leave(self, widget, event):
        #print( &#34;area_leave&#34;)
        pass

    def scroll_event(self, widget, event):
        #print( &#34;scroll_event&#34;, event, event.direction)
        xidx = self.xpos + self.caret[0]
        yidx = self.ypos + self.caret[1]
        if event.direction == Gdk.ScrollDirection.SMOOTH:
            flag, directx, directy = event.get_scroll_deltas()
            if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
                yidx += 10 * int(directy)
            elif event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                yidx += 5 * int(directy)
            else:
                yidx += int(directy)
        else:
            #print( &#34;type&#34;, type(event.type))
            #print(&#34;truth&#34;, isinstance(event.type, Gdk.EventType))
            if event.direction == Gdk.ScrollDirection.UP:
                yidx -= int(self.pgup / 2)
            else:
                yidx += int(self.pgup / 2)

        self.set_caret(xidx, yidx)
        self.invalidate()

    def hscroll_cb(self, widget):
        #print( &#34;hscroll_cb&#34;, widget.get_value())

        # Skip one callback
        if self.honeshot:
            self.honeshot = False; return
        xidx = int(widget.get_value())

        #print( &#34;hscroll_cb ok&#34;, widget.get_value())
        self.set_caret(xidx, self.ypos + self.caret[1])
        self.invalidate()

        #print( &#34;vscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.oneshot:
            self.oneshot = False; return
        #print( &#34;vscroll_cb ok&#34;, widget.get_value())
        yidx = int(widget.get_value())
        self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
        self.invalidate()

    def vscroll_cb(self, widget):
        #print( &#34;vscroll_cb&#34;, widget.get_value())
        # Skip one callback
        if self.oneshot:
            self.oneshot = False; return
        #print( &#34;vscroll_cb ok&#34;, widget.get_value())
        yidx = int(widget.get_value())
        self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
        self.invalidate()

    def size_request(self, widget, req):
        #print( &#34;size_request&#34;, req)
        pass

    def size_alloc(self, widget, req):
        #print( &#34;size_alloc&#34;, req)
        pass

    def configure_event(self, widget, event):
        #print( &#34;configure_event&#34;, event)
        #self.grab_focus()
        #self.width = 0; self.height = 0
        #self.invalidate()
        #print( self, event)
        pass

    def draw_event(self, pdoc, cr):

        self.hhh = self.get_height();  self.www = self.get_width()
        self.xlen = len(self.text)

        ctx = self.get_style_context()
        fg_color = ctx.get_color(Gtk.StateFlags.NORMAL)
        #bg_color = ctx.get_background_color(Gtk..NORMAL)

        # Paint white, ignore system BG
        #cr.set_source_rgba(255, 255, 255)
        # Paint prescribed color
        if self.readonly:
            # Slightly darker / lighter
            newcol =  list(self.bgcolor)
            for aa in range(len(newcol)):
                if newcol[aa] &gt; 0.5: newcol[aa] -= .08
                else: newcol[aa] += .2
            cr.set_source_rgba(*list(newcol))
        else:
            cr.set_source_rgba(*list(self.bgcolor))

        cr.rectangle( 0, 0, self.www, self.hhh)
        cr.fill()

        cr.set_source_rgba(*list(self.stripcolor))
        cr.rectangle( 0, 0, self.strip - 2, self.hhh)
        cr.fill()

        try:
            pedplug.predraw(self, cr)
        except:
            print(&#34;plugin failed&#34;, sys.exc_info())

        # Pre set for drawing
        #cr.set_source_rgba(*list(fg_color))
        # Paint prescribed color
        cr.set_source_rgba(*list(self.fgcolor))

        cr.move_to(0, 0)
        self.layout = PangoCairo.create_layout(cr)
        self.layout.set_font_description(self.fd)

        self.draw_maintext(cr)

        if not self.hex:
            # Do the text drawing in stages ...
            try:
                self.draw_selection(cr)
                self.draw_syntax(cr)
                self.draw_clsyntax(cr)
                self.draw_comments(cr)
                self.draw_spellerr(cr)
            except:
                print(&#34;Failed to draw colors&#34;, sys.exc_info())

        if self.startxxx != -1:
            self.gotoxy(self.startxxx, self.startyyy)
            self.startxxx = -1; self.startyyy = -1

        self.draw_caret(cr)

    def idle_queue(func):
        self.queue.append(func)
        #print( queue)

    def area_button(self, area, event):

        self.lastevent = event

        #if pedconfig.conf.pgdebug &gt; 5:
        #    print( &#34;Button press  &#34;, self, event.type, &#34; x=&#34;, event.x,
        #    &#34; y=&#34;, event.y)

        event.x = int(event.x) - self.strip
        event.y = int(event.y)

        if  event.type == Gdk.EventType.BUTTON_PRESS:
            if event.button == 1:
                #print( &#34;Left Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
                self.mx = int(event.x); self.my = int(event.y)
                xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
                # Find current pos, gather tabs, adjust back
                try:
                    line = self.text[self.ypos + yyy]
                except:
                    line = &#34;&#34;
                offs = calc_tabs2(line, xxx)

                # Are we in selection?
                #print( &#34;xxx&#34;, self.xpos + xxx, &#34;yyy&#34;, self.ypos + yyy)
                #rp = xxx + self.xpos
                #print( &#34;xpos&#34;, self.xpos, &#34;xxx&#34;, xxx, &#34;rp&#34;, rp)
                #print( line)
                #print( &#34;line part&#34;, &#34;&#39;&#34; + line[rp:rp+8] + &#34;&#39;&#34;)

                # Are we in selection?
                if self.xsel != -1:
                    #print(&#34;xsel&#34;, self.xsel, &#34;ysel&#34;, self.ysel)
                    #print(&#34;xsel2&#34;, self.xsel2, &#34;ysel2&#34;, self.ysel2)

                    xssel = min(self.xsel, self.xsel2)
                    xesel = max(self.xsel, self.xsel2)
                    yssel = min(self.ysel, self.ysel2)
                    yesel = max(self.ysel, self.ysel2)

                    if (self.ypos + yyy &gt;= yssel and self.ypos + yyy &lt;= yesel) and \
                         (self.xpos + xxx &gt;= xssel and self.xpos + xxx &lt;= xesel):
                        #print(&#34;in selection&#34;)
                        self.drag = True
                    else:
                        # Erase selection, pos cursor
                        self.clearsel()
                        self.set_caret(self.xpos + xxx - (offs - xxx),
                                     self.ypos + yyy )
                else:
                    self.set_caret(self.xpos + xxx - (offs - xxx),
                                 self.ypos + yyy )

                self.fired += 1
                self.run_keytime()
                #self.mained.threads.submit_job(keytime, self, None)

            if event.button == 3:
                #print( &#34;Right Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
                flag = False; xx = 0; yy = 0; zz = 0
                if self.spell:
                    yyy = int(self.ypos + self.get_height() / self.cyy)
                    for xaa, ybb, lcc in self.ularr:
                        # Look within visible range
                        if ybb &gt;= self.ypos and ybb &lt; yyy:
                            ybb -= self.ypos
                            xaa -= self.xpos; lcc -= self.xpos
                            xaa *= self.cxx ; ybb *= self.cyy
                            lcc *= self.cxx
                            yy2 = ybb + self.cyy

                            if self.intersect(xaa, ybb, lcc, yy2, event):
                                xx = int(xaa / self.cxx + self.xpos)
                                yy = int(ybb / self.cyy + self.ypos)
                                zz = int(lcc / self.cxx + self.xpos)
                                flag = True
                if flag:
                    line = self.text[yy]
                    #print( &#34;Spell delimit: &#39;&#34; + line[xx:zz] + &#34;&#39;&#34;)
                    self.xsel = xx;
                    self.xsel2 = zz

                    self.ysel = self.ysel2 = yy
                    self.spellstr = line[int(xx):int(zz)]
                    self.popspell(area, event, self.spellstr)
                else:
                    if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                        if self.xsel == -1:
                            yyy = int(event.y / self.cyy + self.ypos)
                            xxx = int(event.x / self.cxx + self.xpos)
                            line = self.text[yyy]
                            self.xsel, self.xsel2 = selasci2(line, xxx, &#34;_-&#34;)
                            self.ysel = self.ysel2 = yyy
                        else:
                            line = self.text[self.ysel]

                        strx = line[int(self.xsel):int(self.xsel2)]
                        #print(&#34;&#39;&#34; + strx + &#34;&#39;&#34;)
                        if strx:
                            self.poprclick2(area, event, strx)
                    else:
                        self.poprclick(area, event)

        elif  event.type == Gdk.EventType.BUTTON_RELEASE:
            #print( &#34;button release&#34;, event.button)
            self.mx = -1; self.my = -1
            self.scrtab = False
            self.drag = False
            ttt = &#34;Release&#34;
            xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;
            offs = calc_tabs2(line, xxx)
            self.set_caret(self.xpos + xxx - (offs - xxx),
                                     self.ypos + yyy )

        elif  event.type == Gdk.EventType._2BUTTON_PRESS:

            if pedconfig.conf.pgdebug &gt; 2:
                print (&#34;Double click %.2f %.2f&#34; % (event.x, event.y))

            self.mx = int(event.x); self.my = int(event.y)
            xxx = int(event.x / self.cxx)
            yyy = int(event.y / self.cyy)

            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;

            # Find current pos on tabbed line
            offs = calc_tabs2(line, xxx)
            self.set_caret(self.xpos + xxx - (offs - xxx), self.ypos + yyy )
            #self.set_caret(len(xxx2), yyy)

            # Erase selection
            if self.xsel != -1:
                self.clearsel()

            # Select word
            if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
                pedconfig.conf.keyh.acth.ctrl_b(self)
            else:
                pedconfig.conf.keyh.acth.alt_v(self)
            # Copy to clip

            if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                pedconfig.conf.keyh.acth.ctrl_c(self)

        else:
            print(&#34;Unexpected mouse op.&#34;)

        self.grab_focus()
        return True

    # See if point in rect
    def intersect(self, xx, yy, xx2, yy2, event):
        # Does X intersect?
        if event.x &gt; xx and event.x &lt; xx2:
            #print( &#34;x inter&#34;, xaa, lcc)
            # Does Y intersect?
            if event.y &gt; yy and event.y &lt; yy2:
                return True
        return False

    # Normalize
    def normsel(self):
        xssel = min(self.xsel, self.xsel2)
        xesel = max(self.xsel, self.xsel2)
        yssel = min(self.ysel, self.ysel2)
        yesel = max(self.ysel, self.ysel2)

        self.xsel  = xssel;  self.ysel  = yssel
        self.xsel2 = xesel;  self.ysel2 = yesel

    def pix2xpos(self, xx):
        return int(self.xpos + (xx-self.strip) / self.cxx)

    def pix2ypos(self, yy):
        return int(self.ypos + yy / self.cyy)

    def pix2pos(self, xx, yy):
        return int(self.xpos + (xx-self.strip) / self.cxx), int(self.ypos + yy / self.cyy)

    def area_motion(self, area, event):
        #print (&#34;motion event&#34;, event.state, event.x, event.y)
        if event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
            #print( &#34;motion event butt 1&#34;, event.state, event.x, event.y)
            if self.drag:
                #print (&#34;drag motion event&#34;, event.state, event.x, event.y)
                targ = Gtk.TargetList(); targ.add_text_targets(0)
                self.drag_begin(targ, Gdk.DragAction.COPY, 0, event)
                self.drag = False
                return

            if self.xsel == -1 and self.scrtab != True:
                begsel = False
                # Horiz drag - regular sel
                if abs(event.x - self.mx) &gt; DRAGTRESH:
                    self.colsel = False; begsel = True

                if begsel:
                    self.xsel = self.xsel2 = self.xpos + self.caret[0]
                    self.ysel = self.ysel2 = self.ypos + self.caret[1]
                    #print( &#34;colsel xsel, ysel&#34;, self.colsel, self.xsel, self.ysel)
                if self.scrtab == False:
                    # Vert drag - colsel
                    if abs(event.y - self.my) &gt; DRAGTRESH:
                        self.scrtab  = True
                        self.colsel = True

            if self.scrtab  == True:
                self.xsel = self.xsel2 = self.xpos + self.caret[0]
                self.ysel = self.ysel2 = self.ypos + self.caret[1]
                xidx = self.xpos + self.caret[0]
                yidx = self.ypos + self.caret[1]
                if  event.y &gt;  self.my:
                    yidx += 1
                if  event.y &gt;  self.my:
                    yidx -= 1
                self.set_caret(xidx, yidx)
                self.my = event.y

            if self.xsel != -1:
                # Already selected, mark
                self.ysel2 = self.pix2ypos(event.y)
                if self.ysel2 &lt; self.ysel:
                    self.xsel    = self.pix2xpos(event.x)
                else:
                    self.xsel2 = self.pix2xpos(event.x)

            self.invalidate()

        if event.state &amp; Gdk.ModifierType.SHIFT_MASK and \
            event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
            #print( &#34;Shift Drag&#34;, event.x, event.y)
            pass
        pass

    def gotoxy(self, xx, yy, sel = None, mid = False):

        #print (&#34;gotoxy&#34;, xx, yy)
        #xx +=  30
        # Contain
        ylen = len(self.text)
        xx2 = max(xx, 0);  yy2 = max(yy, 0)
        xx2 = min(xx, self.maxlinelen);  yy2 = min(yy, ylen)

        if sel:
            self.xsel = xx2; self.xsel2 = xx2 + sel
            self.ysel = yy2; self.ysel2 = yy2
            self.invalidate()
        #else:
        #    self.xsel = xx2; self.xsel2 = xx2
        #    self.ysel = yy2; self.ysel2 = yy2

        if mid:
            self.set_caret_middle(xx, yy)
        else:
            self.set_caret(xx, yy)

        self.invalidate()

    # --------------------------------------------------------------------

    def set_caret_middle(self, xx, yy, sel = None, quart = 2):

        &#39;&#39;&#39;  Goto position, and place it to upper half / quarter &#39;&#39;&#39;

        xx = int(xx); yy = int(yy)

        # Needs scroll?
        #xxx, yyy = self.get_size()
        xlen = len(self.text)

        # Put it back in view:
        off = (self.get_height() / self.cyy) / quart
        if yy &gt; off:
            self.ypos = int(yy - off)
        else:
            self.ypos = 0

        self.set_caret(xx, yy)
        self.invalidate()

    # Dimenswions in character cell
    def get_height_char(self):
        return self.get_height()  / self.cyy

    def get_width_char(self):
        return self.get_width() / self.cxx

    # --------------------------------------------------------------------

    def set_caret(self, xx, yy, ignore = False):

        &#39;&#39;&#39; Goto position, put caret (cursor) back to view, [vh]scrap
            distance from ends. This function was a difficult to write. :-{
            Note the trick with comparing old cursor pos for a hint on scroll
            direction.
            xx, yy - absolute position in the text buffer
        &#39;&#39;&#39;

        if self.caretshot:
            self.caretshot = False; return
        self.caretshot = ignore

        #print( &#34;set_caret&#34;, xx, yy)
        xx = int(xx); yy = int(yy)

        # Needs scroll?
        need_inval = False
        cww = self.get_width_char()
        chh = self.get_height_char()
        xlen = len(self.text)

        # ----------------------------------------------------------------
        # Put it back in view yyy:

        off = chh - self.vscgap
        if yy - self.ypos &gt; off:
            #print( &#34;Scroll from caret down&#34;)
            if yy &gt; self.ypos + self.caret[1]:
                #print( &#34;move d&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
                self.ypos = int(yy - off)
                need_inval = True
                # Force new spell check
                self.fired += 1
                self.run_keytime()
                #self.mained.threads.submit_job(keytime, self, None)

        if yy - self.ypos &lt; self.vscgap and self.ypos:
            #print( &#34;Scroll from caret up&#34;)
            if yy &lt; self.ypos + self.caret[1]:
                #print( &#34;move u&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
                self.ypos = int(yy - self.vscgap)
                self.ypos = int(max(self.ypos, 0))
                need_inval = True
                # Force new spell check
                self.fired += 1
                self.run_keytime()
                #self.mained.threads.submit_job(keytime, self, None)

        yy -= self.ypos
        if self.ypos &lt; 0: self.ypos = 0

        # ----------------------------------------------------------------
        # Put it back in view xxx:

        xoff = cww - self.hscgap - self.strip / self.cxx
        if  xx - self.xpos  &gt; xoff:
            #print( &#34;Scroll from caret right&#34;, &#34;xx&#34;, xx, &#34;xpos&#34;, self.xpos)
            if self.xpos + self.caret[0] &lt; xx:
                #print( &#34;moved r&#34;,  xx, self.caret[0], self.xpos)
                self.xpos =  int(xx - xoff)
                self.xpos = int(max(self.xpos, 0))
                need_inval = True

        if  xx - self.xpos &lt;  self.hscgap:
            #print( &#34;Scroll from caret left &#34;, xx, self.xpos)
            if self.xpos + self.caret[0] &gt; xx:
                #print( &#34;moved l&#34;, &#34;xx&#34;, xx, &#34;caret&#34;, self.caret[0], &#34;xpos&#34;, self.xpos)
                self.xpos = int(xx - self.hscgap)
                self.xpos = int(max(self.xpos, 0))
                need_inval = True

        xx -= self.xpos
        if self.xpos &lt; 0: self.xpos = 0

        oldx = self.caret[0] * self.cxx
        oldy = self.caret[1] * self.cyy

        # Cheat - invalidate all if tab is involved at old line
        try:
            line = self.text[oldy]
        except:
            line = &#34;&#34;; need_inval = True
        if line.find(&#34;\t&#34;) &gt;= 0:
            need_inval = True

        self.caret[0] = xx; self.caret[1] = yy

        # Low limit
        if self.caret[0] &lt; 0: self.caret[0] = 0
        if self.caret[1] &lt; 0: self.caret[1] = 0

        wxx = self.caret[0] * self.cxx
        wyy = self.caret[1] * self.cyy

        # Cheat - invalidate all if tab is involoved
        try:
            line = self.text[self.ypos + self.caret[1]]
        except:
            line = &#34;&#34;; need_inval = True
        if line.find(&#34;\t&#34;) &gt;= 0:
            need_inval = True

        # Optimize cursor movement invalidation
        &#39;&#39;&#39;if  not need_inval :
            rect = Gdk.Rectangle(wxx, wyy, self.cxx * self.cxx /2, self.cyy + 1)
            self.invalidate(rect)

            rect = Gdk.Rectangle(oldx, oldy, self.cxx + self.cxx /2 , self.cyy + 1)
            self.invalidate(rect)
        &#39;&#39;&#39;
        #self.invalidate(None)

        # Update scroll bars, prevent them from sending scroll message:
        self.oneshot = True; self.vscroll.set_value(self.ypos)
        self.honeshot = True; self.hscroll.set_value(self.xpos)

        self.update_bar2()

        if  need_inval or self.bigcaret:
            self.invalidate()

    def update_bar2(self):
        clip = pedconfig.conf.keyh.acth.currclip
        self.mained.update_statusbar2(self.caret[0] + self.xpos, \
                self.caret[1] + self.ypos, self.insert, len(self.text), clip,
                    self.caps, self.scr, self.colsel)

    def clearsel(self):
        old = self.xsel
        self.xsel  =  self.ysel = -1
        self.xsel2 =  self.ysel2 = -1
        if old != -1:
            self.invalidate()

    def is_c_like(self):

        &#39;&#39;&#39; Return True if &#39;C&#39; like file
            This is fooled by non extension items; not a big deal
            colors may get turned on ...
        &#39;&#39;&#39;
        #print(&#34;c like&#34;, self.fname)
        for aa in c_like_exts:
            eee = self.fname[-(len(aa)):]
            #print(&#34;eee&#34;, eee, aa)
            if aa == eee:
                #print(&#34;C Match&#34;, self.fname)
                return True
        return False

    def walk_func(self):

        #print( &#34;walk func&#34;)

        # ts2 ---------------------------------------------------
        sumw2 = []
        if self.text:
            sline = self.caret[1] + int(self.ypos)
            sline = max(sline, 0); sline = min(sline, len(self.text))
            #print( &#34;Start point&#34;, sline, self.text[sline])

            # Walk back to last function
            if self.is_c_like():
                try:
                    aa = 0; bb = 0
                    regex = re.compile(ckeywords)
                    for aa in range(sline - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break
                    if aa &gt; 0:
                        for bb in range(aa + 1, len(self.text)):
                            line = self.text[bb]
                            res = regex.search(line)
                            if res:
                                #print( &#34;end&#34;, line, res.start(), res.end())
                                break

                        regex2 = re.compile(localkwords)
                        for cc in range(aa + 1, bb - 1):
                            line = self.text[cc]
                            res = regex2.search(line)
                            if res:
                                #print( &#34;match&#34;, line, res.start(), res.end())
                                sumw2.append(line)

                except:
                    print(&#34;Exception in c func handler&#34;, sys.exc_info())
                    pass
            if &#34;.bas&#34; in self.fname.lower():
                try:
                    regex = re.compile(basekeywords)
                    for line in win.text:
                        res = regex.search(line)
                        if res:
                            #print( res, res.start(), res.end())
                            sumw.append(line)
                except:
                    print(&#34;Exception in bas func extraction handler&#34;, sys.exc_info())
                    pass
            if &#34;.py&#34; in self.fname.lower():
                try:
                    aa = 0; bb = 0
                    regex = re.compile(&#34;class&#34;)
                    for aa in range(int(sline) - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break

                    regex = re.compile(pykeywords2)
                    for aa in range(int(sline) - 1, 0, -1):
                        line = self.text[aa]
                        res = regex.search(line)
                        if res:
                            #print( &#34;start&#34;, line, res.start(), res.end())
                            sumw2.append(line)
                            break

                    if aa &gt; 0:
                        for bb in range(aa + 1, len(self.text)):
                            line = self.text[bb]
                            res = regex.search(line)
                            if res:
                                #print( &#34;end&#34;, line, res.start(), res.end())
                                break

                        regex2 = re.compile(localpywords)
                        for cc in range(aa + 1, bb - 1):
                            line = self.text[cc]
                            res = regex2.search(line)
                            if res:
                                #print( &#34;match&#34;, line, res.start(), res.end())
                                sumw2.append(line)

                except:
                    print(&#34;Exception in py func handler&#34;, sys.exc_info())
                    raise
                    pass
            else:
                pass

            # Always show todo
            got_todo = 0
            for line in self.text:
                if &#34;TODO&#34; in line:
                    if not got_todo:
                        got_todo = 1
                        sumw2.append(&#34;----------- TODO List ----------&#34;)
                    sumw2.append(line)

        try:
            self.mained.update_treestore2(sumw2)
        except:
            # This is normal, ignore it
            print(&#34;walk2&#34;, sys.exc_info())
            pass

    # Call key handler
    def area_key(self, area, event):

        #print (&#34;peddoc area_key&#34;, event.keyval)
        #return True # TEST

        # Restart timer ticks
        pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
        pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

        # Maintain a count of events, only fire only fire on the last one
        self.fired += 1
        self.run_keytime()

        #if not self.fired:
        #    self.mained.threads.submit_job(keytime, self, None)

        # The actual key handler
        try:
            self.keyh.handle_key(self, area, event)
        except:
            print(&#34;Key handler died at key&#34;, event.keyval, sys.exc_info())
            put_exception(&#34;key handler&#34;)

        #if event.type == Gdk.KEY_RELEASE:
        #    self.source_id = GObject.idle_add(self.idle_callback)

        # We handled it
        return True

     # Invalidate current line
    def inval_line(self):
        rect = Gdk.Rectangle()
        xx = self.caret[0] * self.cxx
        yy = self.caret[1] * self.cyy
        ww = self.get_width()
        hh = self.cyy
        #self.invalidate(rect)
        xx = 0
        self.queue_draw_area(xx, yy, ww, hh)

    def invalidate(self, rect = None):
        #print( &#34;Invalidate:&#34;, rect)
        if rect == None:
            self.queue_draw()
        else:
            self.queue_draw_area(rect.x, rect.y,
                            rect.width, rect.height)

    def area_focus(self, area, event):
        #print( &#34;ped doc area focus&#34;, event)
        return False

    # Add to user dictionary:
    def addict(self, widget, string, arg):
        #print( &#34;addict&#34;, arg)
        if not pedspell.append_user_dict(self, arg):
            self.mained.update_statusbar(&#34;Cannot append to user dict&#34;)
        else:
            self.mained.update_statusbar(&#34;Added &#39;%s&#39; to user dict&#34; % arg)
            self.newword = True

        # Force new spell check
        self.fired += 1
        self.run_keytime()
        #self.mained.threads.submit_job(keytime, self, None)

    def popspell(self, widget, event, xstr):
        # Create a new menu-item with a name...
        self.menu2 = Gtk.Menu()
        self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % xstr, None))
        self.menu2.append(self.create_menuitem(&#34;Add to Dict&#34;, self.addict, xstr))

        mi = self.create_menuitem(&#34;-------------&#34;, None)
        mi.set_sensitive(False)
        self.menu2.append(mi)

        strs = &#34;Creating suggestion list for &#39;{0:s}&#39;&#34;.format(self.spellstr)
        self.mained.update_statusbar(strs)
        arr = pedspell.suggest(self, xstr)

        if len(arr) == 0:
            self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
        else:
            for aa, bb in arr:
                self.menu2.append(self.create_menuitem
                        (bb, self.menuitem_response))

        self.menu2.popup(None, None, None, None, event.button, event.time)
        #self.mained.update_statusbar(&#34;Done menu popup.&#34;)

    def set_sidetab(self, arg1, arg2, arg3):
        # reset all
        #print(&#34;set_sidetab&#34;, arg1, arg2, arg3)
        www = self.mained.get_width()
        if arg3 == 0:
            if self.mained.hpaned3.get_position() &gt; www - 20:
                self.mained.hpaned3.set_position(www - www / 3)
            self.mained.update_statusbar(&#34;Sidetab buffer switched on.&#34;)
            self.mained.diffpane.area.loadbuff(self.text)
            self.mained.diffpane.area.fname = self.fname
            self.mained.diffpane.area.readonly = True

            usleep(100)
            self.gotoxy(self.xpos + self.caret[0], self.ypos + self.caret[1])
            self.mained.diffpane.area.xpos = self.xpos
            self.mained.diffpane.area.ypos = self.ypos
            self.mained.diffpane.area.gotoxy(
                         self.xpos + self.caret[0], self.ypos + self.caret[1])
            usleep(10)
            self.mained.diffpane.area.invalidate()
            pppp = self.notebook3.get_nth_page(0)
            lab = self.mained.make_label(&#34;ro &#34; + os.path.basename(self.fname))
            lab.set_tooltip_text(self.fname)
            self.notebook3.set_tab_label(pppp, lab)
        else:
            self.mained.hpaned3.set_position(www - 10)
            self.mained.update_statusbar(&#34;Sidetab buffer switched off.&#34;)
            pass

    def set_diffs(self, arg1, arg2, arg3):
        # reset all
        if arg3 == 0:
            nn = self.notebook.get_n_pages(); cnt = 0
            while True:
                if cnt &gt;= nn: break
                ppp = self.notebook.get_nth_page(cnt)
                ppp.area.diffmode = 0
                ppp.area.set_tablabel()
                cnt += 1
            www = self.mained.get_width()
            self.mained.hpaned3.set_position(www - 10)

        else:
            self.diffmode = arg3
            self.set_tablabel()

            got_src = 0; got_targ = 0; action_page = 0;
            src = &#34;&#34;; targ = &#34;&#34;
            srctxt = [] ;  targtxt = []
            action_tab = None

            # See if diff complete, put it in motion
            nn = self.notebook.get_n_pages(); cnt = 0
            while True:
                if cnt &gt;= nn: break
                ppp = self.notebook.get_nth_page(cnt)
                #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
                if ppp.area.diffmode == 1:
                    got_src = True
                    src = os.path.basename(ppp.area.fname)
                    srctxt = ppp.area.text

                if ppp.area.diffmode == 2:
                    got_targ = True
                    targ = os.path.basename(ppp.area.fname)
                    targtxt = ppp.area.text
                    action_page = cnt
                    action_tab = ppp

                if ppp.area.diffmode == 1:
                    got_src = True
                cnt += 1

            if got_src and got_targ:
                www = self.mained.get_width()
                if self.mained.hpaned3.get_position() &gt; www - 20:
                    self.mained.hpaned3.set_position(www - www / 3)

                self.mained.update_statusbar(    \
                            &#34;Diff started.  Source: &#39;%s&#39; Target: &#39;%s&#39;&#34; % (src, targ))

                pppp = self.notebook3.get_nth_page(0)
                self.notebook3.set_tab_label(pppp,
                            self.mained.make_label(&#34;&#39;&#34; + src + &#34;&#39; --vs-- &#39;&#34; + targ + &#34;&#39;&#34;))
                self.notebook.set_current_page(action_page)
                action_tab.area.diffx(srctxt, targtxt)

    # --------------------------------------------------------------------

    def diffx(self, srctxt, targtxt):
        arrx = []; forw = 0; forw2 = 0
        diffscan = 500
        for aa in range(len(targtxt)):
            try:
                if srctxt[aa + forw2] == targtxt[aa + forw]:
                    arrx.append(targtxt[aa + forw])
                    continue
                fff = False
                # Resync forward
                try:
                    for bb in range(diffscan):
                        ttt = targtxt[aa + forw + bb]
                        if srctxt[aa + forw2] == ttt:
                            for cc in range(bb):
                                strx = &#34; --ins-- [ &#34; + targtxt[aa + forw + cc] + &#34; ] &#34;
                                arrx.append(strx)
                            arrx.append(ttt)
                            forw += bb
                            #print(&#34;forward set&#34;, forw, ttt)
                            fff = True
                            break
                except:
                    pass #print(&#34;EOB while fw&#34;, ttt)

                if fff:
                    continue

                # Resync on the other file
                try:
                    for bb in range(diffscan):
                        ttt = srctxt[aa  + forw2 + bb]
                        if ttt ==  targtxt[aa + forw]:
                            for cc in range(bb):
                                strx = &#34; --del-- [ &#34; + srctxt[aa + forw2 + cc] + &#34; ] &#34;
                                arrx.append(strx)
                            arrx.append(targtxt[aa + forw])
                            forw2 += bb
                            #print(&#34;backward set&#34;, forw, ttt)
                            fff = True
                            break
                except:
                    pass #print(&#34;EOB while other fw&#34;)

                if fff:
                    continue

                # See if diff is small
                lendiff = len(srctxt[aa + forw2]) - len(targtxt[aa + forw])
                #print (&#34;lendiff&#34;, lendiff, srctxt[aa], targtxt[aa+forw])
                if abs(lendiff) &lt; 3:
                    strx = &#34; --chg-- [ &#34; + srctxt[aa + forw2] + &#34; ] &#34;
                else:
                    strx = &#34; --ins-- [ &#34; + targtxt[aa + forw] + &#34; ] &#34;
                    forw2 -= 1   # Stand still on the other
                arrx.append(strx)
                #print(&#34;could not resync&#34;)

            except:
                #print(&#34;Buffers are different lengths&#34;, sys.exc_info())
                pass

        self.mained.diffpane.area.loadbuff(arrx)
        usleep(100)
        self.gotoxy(self.xpos + self.caret[0], self.ypos + self.caret[1])

        self.mained.diffpane.area.xpos = self.xpos
        self.mained.diffpane.area.ypos = self.ypos
        self.mained.diffpane.area.gotoxy(
                         self.xpos + self.caret[0], self.ypos + self.caret[1])
        usleep(10)
        self.mained.diffpane.area.invalidate()


    def iterdocs(self, callb, arg):
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            callb(ppp.area, arg)
            cnt += 1

    def builddoc(self, ppp):
        if ppp.area.diffmode == 1:
            got_src = True
        if ppp.area.diffmode == 2:
            got_targ = True

    def set_ro(self, arg1, arg2, arg3):
        print(&#34;set_ro&#34;)

    def re_diff(self, arg1, arg2, arg3):
        got_src = 0; got_targ = 0; action_page = 0;
        src = &#34;&#34;; targ = &#34;&#34;
        srctxt = [] ;  targtxt = []
        action_tab = None

        # See if diff complete, put it in motion
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
                src = os.path.basename(ppp.area.fname)
                srctxt = ppp.area.text

            if ppp.area.diffmode == 2:
                got_targ = True
                targ = os.path.basename(ppp.area.fname)
                targtxt = ppp.area.text
                action_page = cnt
                action_tab = ppp

            if ppp.area.diffmode == 1:
                got_src = True
            cnt += 1

        if got_src and got_targ:
            www = self.mained.get_width()
            if self.mained.hpaned3.get_position() &gt; www - 20:
                self.mained.hpaned3.set_position(www - www / 3)

            self.mained.update_statusbar(    \
                        &#34;Diff re-started.  Source: &#39;%s&#39; Target: &#39;%s&#39;&#34; % (src, targ))

            self.notebook.set_current_page(action_page)
            action_tab.area.diffx(srctxt, targtxt)


    def poprclick3(self, event):
        #print (&#34;Making shift rclick3&#34;)
        if self.nomenu: return

        got_src = 0; got_targ = 0

        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
            if ppp.area.diffmode == 2:
                got_targ = True
            cnt += 1

        # Check if there is any:
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
            if ppp.area.diffmode == 2:
                got_targ = True
            cnt += 1

        self.menu3 = Gtk.Menu()
        if not got_src:
            self.menu3.append(self.create_menuitem(&#34;Set as Diff Source&#34;, self.set_diffs, 1))
        if not got_targ:
            self.menu3.append(self.create_menuitem(&#34;Set as Diff Target&#34;, self.set_diffs, 2))
        else:
            self.menu3.append(self.create_menuitem(&#34;Re-Diff Buffers&#34;,  self.re_diff, 0))

        self.menu3.append(self.create_menuitem(&#34;Stop Diffing&#34;,  self.set_diffs, 0))
        self.menu3.append(self.create_menuitem(&#34;- - - - - - - - - - - - - - - &#34;,  None, 0))
        self.menu3.append(self.create_menuitem(&#34;Show Buffer in Sidetab&#34;,  self.set_sidetab, 0))
        self.menu3.append(self.create_menuitem(&#34;Hide Sidetab&#34;,  self.set_sidetab, 1))

        #mi = self.create_menuitem(&#34;-------------&#34;, None)
        #mi.set_sensitive(False); self.menu3.append(mi)
        #self.menu3.append(self.create_menuitem(&#34;Toggle Read Only&#34;,  self.set_ro, 0))

        self.menu3.popup(None, None, None, None, event.button, event.time)

    def poprclick2(self, widget, event, strx):
        #print (&#34;Making shift rclick2&#34;)
        if self.nomenu: return

        self.menu2 = Gtk.Menu()
        self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % strx, None))
        mi = self.create_menuitem(&#34;-------------&#34;, None)
        mi.set_sensitive(False)
        self.menu2.append(mi)
        strs = &#34;Creating class list for &#39;{0:s}&#39;&#34;.format(strx)
        self.mained.update_statusbar(strs)
        arr = pedstruct.suggest(self, strx)
        if len(arr) == 0:
            self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
        else:
            for bb in arr:
                self.menu2.append(self.create_menuitem(bb, self.menuitem_response2))

        self.menu2.popup(None, None, None, None, event.button, event.time)

    def poprclick(self, widget, event):

        if self.nomenu: return

        #print (&#34;Making rclick&#34;)
        menu = self.build_menu(self, pedmenu.rclick_menu)
        menu.show_all()

        if event:
            menu.popup(None, None, None, None, event.button, event.time)
        else:
            event = Gdk.EventButton()
            menu.popup(None, None, None, None, event.button, event.time)

    def menuitem_response2(self, widget, stringx, arg):
        #print( &#34;menuitem response2 &#39;%s&#39;&#34; % stringx)
        #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)
        disp2 = Gdk.Display()
        disp = disp2.get_default()
        clip = Gtk.Clipboard.get_default(disp)
        stringx = stringx.strip()
        clip.set_text(stringx, len(stringx))
        strs = &#34;Copied to clipboard &#39;{0:s}&#39;&#34;.format(stringx)
        self.mained.update_statusbar(strs, True)

    def menuitem_response(self, widget, stringx, arg):
        #print( &#34;menuitem response &#39;%s&#39;&#34; % stringx)
        #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)

        # See if Capitalized or UPPERCASE :
        if self.spellstr[0] in string.ascii_uppercase:
            stringx = stringx.capitalize()

        if self.spellstr.isupper():
            stringx = stringx.upper()

        pedconfig.conf.keyh.acth.clip_cb(None, stringx, self, False)

        self.fired += 1
        self.run_keytime()
        #self.mained.threads.submit_job(keytime, self, None)

    def doc_activate_action(self, action):

        print(&#34;doc_activate_action&#34;)

        dialog = Gtk.MessageDialog(self, Gtk.DIALOG_DESTROY_WITH_PARENT,
            Gtk.ButtonsType.INFO, Gtk.ButtonsType.CLOSE,
            &#39;You activated action: &#34;%s&#34; of type &#34;%s&#34;&#39; % (action.get_name(), type(action)))
        # Close dialog on user response
        dialog.connect (&#34;response&#34;, lambda d, r: d.destroy())
        dialog.show()

    def rclick_action_doc(self, action, sss, ttt):

        if pedconfig.conf.verbose:
            print( &#34;rclick_action_doc&#34;, sss, ttt)

        if ttt == 1:
            self.mained.newfile()
        elif ttt == 3:
            self.mained.open()
        elif ttt == 4:
            self.mained.save()
        elif ttt == 5:
            self.mained.save(True)
        elif ttt == 7:
            self.mained.copy()
        elif ttt == 8:
            self.mained.cut()
        elif ttt == 9:
            self.mained.paste()
        elif ttt == 11:
            self.toggle_ro()
        elif ttt == 13:
            print(&#34;menu exit&#34;)
            self.mained.activate_exit()
        elif ttt == 14:
             pedconfig.conf.pedwin.start_term()
        elif ttt == 15:
            self.start_edit(self.fname)
        elif ttt == 16:
            self.mained.tts()
        elif ttt == 17:
            pedmisc.exec_test(self, &#34;rc&#34;)
        elif ttt == 18:
            self.start_external([&#34;libreoffice&#34;, &#34;--writer&#34;],
                                        [&#34;libreoffice&#34;, &#34;--writer&#34;])
        elif ttt == 19:
            self.start_m4filter()
        elif ttt == 20:
            self.start_mdfilter()
        elif ttt == 21:
            self.start_browser(self.fname)
        elif ttt == 22:
            self.start_htmlwin(self.fname)
        elif ttt == 23:
            self.start_htmlstr()
        elif ttt == 24:
            self.start_external([&#34;thunar&#34;, &#34;.&#34;], # Caja ?
                                        [&#34;explorer&#34;, &#34;&#34;])
        elif ttt == 25:
            self.rescan()
        elif ttt == 26:
            self.find(self)
        elif ttt == 27:
            #print(&#34;Alt-Y&#34;)
            self.check_syntax()
        else:
            print(&#34;peddoc: Invalid menu item selected&#34;, ttt)

    def rescan(self):
        global last_scanned
        last_scanned = &#34;&#34;
        run_async_time(self, 0)
        self.mained.update_statusbar(&#34;Started rescan ...&#34;)

    def toggle_ro(self):
        self.readonly = not self.readonly
        self.set_tablabel()
        arrx = [&#34;OFF&#34;, &#34;ON&#34;]
        self.mained.update_statusbar(&#34;Toggled read only to %s&#34; % arrx[self.readonly])

    def create_menuitem(self, string, action, arg = None):
        rclick_menu = Gtk.MenuItem(string)
        if action:
            rclick_menu.connect(&#34;activate&#34;, action, string, arg)
        rclick_menu.show()
        return rclick_menu

        # Create the menubar and toolbar
        action_group = Gtk.ActionGroup(&#34;DocWindowActions&#34;)
        action_group.add_actions(entries)
        return action_group

    def _fill(self, aa,  bb):
        ttt = str(bb).replace(&#34;&lt;control&gt;&#34;, &#34;CTRL+&#34;)
        ttt = str(ttt).replace(&#34;&lt;alt&gt;&#34;,     &#34;ALT+&#34;)
        ttt = str(ttt).replace(&#34;&lt;shift&gt;&#34;,   &#34;SHIFT+&#34;)
        fff = &#34; &#34; * (15 - len(aa))
        sss = aa + &#34;%s\t%s&#34; % (fff, ttt)
        return sss

    def build_menu(self, window, items):

        menu =  Gtk.Menu()
        for aa, bb, cc, dd, ee  in items:
            #print (&#34;menu item&#34;, aa)
            if ee == &#34;&lt;Separator&gt;&#34;:
                menu_item = Gtk.MenuItem.new_with_mnemonic(
                            &#34;----------------------------&#34;)
                menu_item.set_sensitive(False)
                menu_item.set_size_request(-1, 10)
                pass
            elif type(ee) == type(()):
                self.submenu =  Gtk.Menu()
                for aaa, bbb, ccc, ddd, eee  in ee:
                    #print (&#34;sub menu item&#34;, aaa)
                    sss = self._fill(aaa, bbb)
                    menu_subitem = Gtk.MenuItem.new_with_mnemonic(sss)
                    menu_subitem.connect(&#34;activate&#34;, self.rclick_action_doc, aaa, ddd )
                    self.submenu.append(menu_subitem)
                sss = self._fill(aa, bb)
                menu_item = Gtk.MenuItem.new_with_mnemonic(sss)
                menu_item.set_submenu(self.submenu)
            else:
                sss = self._fill(aa, bb)
                menu_item = Gtk.MenuItem.new_with_mnemonic(sss)
                menu_item.connect(&#34;activate&#34;, self.rclick_action_doc, aa, dd )
            menu.append(menu_item)
        return menu

    def get_size(self):
        rect = self.get_allocation()
        return rect.width, rect.height

    def get_height(self):
        rect = self.get_allocation()
        return rect.height

    def get_width(self):
        rect = self.get_allocation()
        return rect.width

    def save(self):

        #print (&#34;Saving&#34;, self.fname)
        # Always save params
        self.saveparms()
        strx = &#34;&#34;
        if not self.changed:
            strx = &#34;File is not modified.&#34;
            self.mained.update_statusbar(strx)
            return

        # Is this file named &#39;untitled&#39;?
        base, ext =  os.path.splitext(pedconfig.conf.UNTITLED)
        base1 = os.path.basename(self.fname)
        base2, ext2 =  os.path.splitext(base1)
        if base2[:len(base)] == base:
            self.file_dlg(Gtk.ResponseType.YES)
        else:
            bn = os.path.basename(self.fname)
            err = self.writeout()
            if  err[0]:
                strx = &#34;Saved &#39;{0:s}&#39;&#34;.format(self.fname)
            else:
                #strx = &#34;Not Saved &#39;{0:s}&#39; {1:s}&#34;.format(bn, err[1])
                strx = &#34;Not Saved &#34;

        if pedconfig.conf.verbose:
            print(strx)
        self.mained.update_statusbar(strx)

    def saveas(self):
        self.file_dlg(Gtk.ResponseType.YES)

    def coloring(self, flag):
        self.colflag = flag
        self.invalidate()

    def showcol(self, flag):
        self.scol = flag
        self.invalidate()

    def hexview(self, flag):
        self.hex = flag
        self.invalidate()

    def flash(self, flag):
        self.bigcaret = flag
        self.invalidate()

    def showtab(self, flag):
        self.stab = flag
        self.scol = flag
        self.invalidate()

    def closedoc(self, noprompt = False):
        #self.stopthread = True
        strx = &#34;Closing &#39;{0:s}&#39;&#34;.format(self.fname)
        if pedconfig.conf.verbose:
            print(&#34;Closing doc:&#34;, strx)
        self.mained.update_statusbar(strx)
        self.saveparms()

        rrr = self.prompt_save(noprompt)
        if not rrr:
            # Clear treestore(s)
            self.mained.update_treestore([])
            self.mained.update_treestore2([])
            # Add to accounting:
            logentry(&#34;Closed File&#34;, self.start_time, self.fname)
            self.mained.oh.add(self.fname)
        return rrr

    # --------------------------------------------------------------------

    def loadfile(self, filename, create = False, reload = True):

        &#39;&#39;&#39; Load file into this buffer, return False on failure &#39;&#39;&#39;

        if not self.second:
            if pedconfig.conf.verbose &gt; 1:
                print(&#34;Loading file&#34;, filename)

        if not reload:
            # Is it already loaded? ... activate
            nn = self.notebook.get_n_pages()
            fname2 = os.path.realpath(filename)
            for aa in range(nn):
                vcurr = self.notebook.get_nth_page(aa)
                if vcurr.area.fname == fname2:
                    if pedconfig.conf.verbose:
                        print(&#34;Already open &#39;&#34;+ fname2 + &#34;&#39;&#34;)
                    self.mained.update_statusbar(&#34;Already open, activating &#39;{0:s}&#39;&#34;.format(fname2))
                    vcurr = self.notebook.set_current_page(aa)
                    vcurr = self.notebook.get_nth_page(aa)
                    self.mained.mywin.set_focus(vcurr.vbox.area)
                    return

        if not self.second:
            self.mained.oh.add(filename)

        self.fname = filename
        self.ext = os.path.splitext(self.fname)[1].lower()

        try:
            self.stat = os.stat(self.fname)
        except:
            pass

        #pedync.message(&#34;\n   open / read file:  \n\n&#34;
        #                      &#34;      %s&#34; % self.fname)

        #print(&#34;stat&#34;, self.stat.st_mtime)
        self.start_time = time.time()
        if self.fname == &#34;&#34;:
            strx = &#34;Must specify file name.&#34;
            print(strx)
            self.mained.update_statusbar(strx)
            return False
        try:
            self.text = readfile(self.fname)
        except:
            errr = &#34;Cannot read file &#39;&#34; + self.fname + &#34;&#39;&#34; #, sys.exc_info()
            if pedconfig.conf.verbose:
                print(errr, sys.exc_info())

            #pedync.message(&#34;\n   Cannot open / read file:  \n\n&#34;
            #                  &#34;      %s&#34; % self.fname)

            print(errr)
            self.mained.update_statusbar(errr)
            usleep(10)
            return False

        #self.ularr.append((10 ,10, 20))
        mlen = self.calc_maxline()

        # Set up scroll bars
        self.set_maxlinelen(mlen, False)
        self.set_maxlines(len(self.text), False)

        # Increment and wrap backup
        if not self.second:
            hhh = hash_name(self.fname)
            self.currback  =  pedconfig.conf.sql.get_int(hhh + &#34;/bak&#34;)
            self.currback += 1
            if self.currback &gt;= 9:
                self.currback = 1
            pedconfig.conf.sql.put(hhh + &#34;/bak&#34;, self.currback)

        # File and backup related
        if not self.second:
            self.loadundo()
            self.loadparms()
            self.saveorg()
            self.savebackup()

            # Add to accounting:
            logentry(&#34;Opened File&#34;, self.start_time, self.fname)

        # Propagate main wndow ref
        pedmenu.mained = self.mained

        self.set_nocol()

        try:
            os.chdir(os.path.dirname(self.fname))
        except:
            print(&#34;Cannot change dir to file&#39;s cwd&#34;, sys.exc_info())

        # Let the system breed
        self.invalidate()
        usleep(10)

        # Color ON?
        self.set_nocol()

        # Are most of them read only?
        if not self.second:
            ro = 0
            nn = self.notebook.get_n_pages()
            for aa in range(nn):
                vcurr = self.notebook.get_nth_page(aa)
                #print(&#34;listing&#34;,  vcurr.area.fname, vcurr.area.readonly)
                if vcurr.area.readonly:
                    ro += 1
            #print(&#34;nn&#34;, nn, &#34;ro count&#34;, ro)
            if ro &gt; nn // 2:
                self.readonly = True

        return True

    def loadbuff(self, arrx):
        self.text = arrx
        usleep(1)
        # Set up scroll bars and other parameters
        mlen = self.calc_maxline()
        self.set_maxlinelen(mlen, False)
        self.set_maxlines(len(self.text), False)
        self.changed = True

    def calc_maxline(self):
        mlen = 0
        for aa in self.text:
            xlen = len(aa)
            if mlen &lt; xlen:
                mlen = xlen
        #self.maxlinelen = mlen
        return mlen

    # Load per file parms (cursor etc)
    def loadparms(self):
        hhh = hash_name(self.fname)

        self.startxxx  =  pedconfig.conf.sql.get_int(hhh + &#34;/xx&#34;)
        self.startyyy  =  pedconfig.conf.sql.get_int(hhh + &#34;/yy&#34;)
        #print(&#34;got cursor pos:&#34;, self.fname, self.startxxx, self.startyyy)
        # Note: we set cursor on first focus

    # Save per file parms (cursor, fname, etc)
    def  saveparms(self):
        hhh = hash_name(self.fname)
        pedconfig.conf.sql.put(hhh + &#34;/xx&#34;, self.xpos + self.caret[0])
        pedconfig.conf.sql.put(hhh + &#34;/yy&#34;, self.ypos + self.caret[1])
        pedconfig.conf.sql.put(hhh + &#34;/fname&#34;, self.fname)

        if self.tts:
            self.tts.haltspeak = True

        #print  &#34;saveparm&#34;, time.clock() - got_clock

    # Create org backup
    def saveorg(self):
        hhh = hash_name(self.fname) + &#34;.org&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        if not os.path.isfile(xfile):
            err =  writefile(xfile, self.text, &#34;\n&#34;)
            if not err[0]:
                print(&#34;Cannot create (org) backup file&#34;, xfile, sys.exc_info())
            # Make a log entry
            logfile = pedconfig.conf.log_dir + os.sep + &#34;backup.log&#34;
            xentry = &#34;Org &#34; + time.ctime() + &#34; &#34; + \
                self.fname + &#34; &#34; + os.path.basename(xfile)
            writefile(logfile, (xentry, &#34;&#34;), &#34;\n&#34;, &#34;a+&#34;)

   # Create backup
    def savebackup(self):

        hhh = hash_name(self.fname)
        self.startxxx  =  pedconfig.conf.sql.get_int(hhh + &#34;/xx&#34;)

        try:
            xfile = pedconfig.conf.data_dir + os.sep + hhh + &#34;_&#34; + str(self.currback) + &#34;.bak&#34;
            if pedconfig.conf.verbose &gt; 2:
                print(&#34;Saving backup: &#34;, xfile)

            try:
                writefile(xfile, self.text, &#34;\n&#34;)
            except:
                print(&#34;Cannot create backup file &#34; + xfile, sys.exc_info())
        except:
            print(&#34;Cannot back up &#34;, sys.exc_info())


    def prompt_save(self, askname = True):

        # Always save params
        self.saveparms()

        if not self.changed:
            #print &#34;not changed&#34;, self.fname
            return False

        msg = &#34;\nWould you like to save:\n\n  \&#34;%s\&#34; \n&#34; % self.fname
        rp = pedync.yes_no_cancel(&#34;pyedpro: Save File ?&#34;, msg)

        if rp == Gtk.ResponseType.YES:
            if askname:
                self.file_dlg(rp)
            else:
                self.save()
        elif rp == Gtk.ResponseType.NO:
            pass
        elif  rp == Gtk.ResponseType.CANCEL:
            return True
        else:
            print(&#34;warning: invalid response from dialog&#34;)

    def file_dlg(self, resp):
        #print &#34;File dialog&#34;
        if resp == Gtk.ResponseType.YES:
            but =   &#34;Cancel&#34;, Gtk.ResponseType.CANCEL,   \
                            &#34;Save File&#34;, Gtk.ResponseType.OK
            fc = Gtk.FileChooserDialog(&#34;Save file as ... &#34;, None,
                    Gtk.FileChooserAction.SAVE, but)
            #fc.set_do_overwrite_confirmation(True)

            fc.set_current_name(os.path.basename(self.fname))
            fc.set_current_folder(os.path.dirname(self.fname))
            fc.set_default_response(Gtk.ResponseType.OK)
            fc.connect(&#34;response&#34;, self.done_fc)
            fc.run()

    # --------------------------------------------------------------------

    def writeout(self):

        &#39;&#39;&#39; The actual savefile routine &#39;&#39;&#39;

        if pedconfig.conf.verbose:
            print(&#34;Saving &#39;&#34;+ self.fname + &#34;&#39;&#34;)

        if os.access(self.fname, os.F_OK):
            #wasread = os.access(self.fname, os.R_OK)
            #if not wasread:
            #    print(&#34;Cannot read &#39;%s&#39;&#34; % self.fname,  sys.exc_info())
            #    self.mained.update_statusbar(&#34;Cannot read &#39;%s&#39;&#34; % self.fname)
            #    return

            waswrite = os.access(self.fname, os.W_OK)
            if not waswrite:
                print(&#34;Cannot write &#39;%s&#39;&#34; % self.fname,  sys.exc_info())
                self.mained.update_statusbar(&#34;Cannot write &#39;%s&#39;&#34; % self.fname)
                self.savebackup()

                pedync.message(&#34;\n   Cannot Save file:  \n\n&#34;
                                  &#34;      &#39;%s&#39;&#34; % self.fname)
                return (False, &#34;Read only or Inaccessible file&#34;)

        err = writefile(self.fname, self.text, &#34;\n&#34;)
        #print(&#34;err writefile&#34;, err)
        if not err[0]:
            print(&#34;Cannot write &#39;%s&#39;&#34; % self.fname,  sys.exc_info())
            return

        self.set_changed(False)
        # Change access/ownership to group write
        try:
            ostat = os.stat(self.fname)
            os.chmod(self.fname, ostat.st_mode | stat.S_IWGRP)
        except:
            print(&#34;Cannot change group write on &#39;%s&#39;&#34; % self.fname,  sys.exc_info())

        self.saveundo();  self.saveparms(); self.set_tablabel()

        # Add to accounting:
        logentry(&#34;Wrote File&#34;, self.start_time, self.fname)

        # Update stat info
        self.stat = os.stat(self.fname)

        return err

    def delundo(self):
        self.undoarr = []; self.redoarr = []
        # Remove file
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        fh = open(xfile, &#34;w&#34;)
        fh.close()
        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        fh = open(xfile, &#34;w&#34;)
        fh.close()

    def saveundo(self):
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;wb&#34;)
            pickle.dump(self.undoarr, fh)
            fh.close()
        except:
            print(&#34;Cannot save undo file&#34;, sys.exc_info())
            put_exception(&#34;undo&#34;)


        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;wb&#34;)
            pickle.dump(self.redoarr, fh)
            fh.close()
        except:
            print(&#34;Cannot save redo file&#34;, sys.exc_info())

    def loadundo(self):
        hhh = hash_name(self.fname) + &#34;.udo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;rb&#34;)
            try:
                self.undoarr = pickle.load(fh)
            except:
                pass
            fh.close()
        except:
            pass
            # Ignore it, not all files will have undo
            #print( &#34;Cannot load undo file&#34;, xfile)
        self.initial_undo_size = len(self.undoarr)

        hhh = hash_name(self.fname) + &#34;.rdo&#34;
        xfile = pedconfig.conf.data_dir + os.sep + hhh
        try:
            fh = open(xfile, &#34;rb&#34;)
            try:
                self.redoarr = pickle.load(fh)
            except:
                pass
            fh.close()
        except:
            pass
            # Ignore it, not all files will have redo
            #print( &#34;Cannot load redo file&#34;, xfile)
        self.initial_redo_size = len(self.redoarr)

    def done_fc(self, win, resp):
        #print( &#34;done_fc&#34;, win, resp)
        if resp == Gtk.ResponseType.OK:
            fname = win.get_filename()
            if not fname:
                print(&#34;Must have filename&#34;)
            else:
                if os.path.isfile(fname):
                    resp = pedync.yes_no_cancel(&#34;Overwrite File Prompt&#34;,
                                &#34;Overwrite existing file?\n &#39;%s&#39;&#34; % fname, False)
                    print(&#34;resp&#34;, resp)
                    if resp == Gtk.ResponseType.YES:
                        self.fname = fname
                        self.ext = os.path.splitext(self.fname)[1].lower()
                        self.writeout()
                        self.mained.update_statusbar(&#34;Saved under new filename &#39;%s&#39;&#34; % fname)
                    else:
                        self.mained.update_statusbar(&#34;No new file name supplied, cancelled &#39;Save As&#39;&#34;)
                else:
                    self.fname = fname
                    self.ext = os.path.splitext(self.fname)[1].lower()
                    self.writeout()

                pedconfig.conf.pedwin.mywin.set_title(&#34;pyedpro: &#34; + self.fname)

        win.destroy()

    def overwrite_done(self, win, resp, fname, win2):
        #print( &#34;overwrite done&#34;, resp)
        if resp == Gtk.ResponseType.YES:
            self.fname = fname
            self.ext = os.path.splitext(self.fname)[1].lower()
            self.writeout()
            self.set_nocol()
            win2.destroy()
        win.destroy()

    # --------------------------------------------------------------------

    def set_nocol(self):

        &#39;&#39;&#39; Turn off coloring if not python / c / sh / perl / header(s) &#39;&#39;&#39;

        colflag = False
        ext = os.path.splitext(self.fname)[1].lower()
        for aa in pedconfig.conf.color_on:
            if ext == aa:
                colflag = True
                break
        self.colflag = colflag


    def do_chores(self):
        #print( &#34;do_chores&#34;)
        if  not self.needscan:
            return
        self.needscan = False

        # Scan left pane
        pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
        pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

    def set_changed(self, flag):
        old = self.changed
        self.changed = flag
        # Exec actions:
        if old != self.changed:
            #print( &#34;Setting changed on &#34;, self.fname)
            self.set_tablabel()

    def set_tablabel(self):
        # Find me in tabs
        #print(&#34;Setting tablabels&#34;)
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            if ppp.area == self:
                self._setlabel(ppp)
                break
            cnt += 1
            #usleep(10)

    # Gdk.EventButton
    def doclabel_callb(self, widg, event):
        #print(&#34;doclabel_callb&#34;, event.button, event.type)
        if event.button == 3:
            #print(&#34;Right click&#34;, self.fname)
            self.poprclick3(event)

    def _setlabel(self, ppp):

        # Set label to tab
        ss = shortenstr(os.path.basename(self.fname), 24)
        if  self.changed:
            str2 = &#34;* &#34; + ss + &#34;  &#34;
        else:
            str2 = &#34;  &#34; + ss + &#34;  &#34;

        if  self.readonly:
            str3 = &#34;ro &#34; + str2
        else:
            str3 = &#34;  &#34; + str2

        if  self.diffmode == 1:
            str4 = &#34;Diff/Source: &#34; + str3
        elif  self.diffmode == 2:
            str4 = &#34;Diff/Target: &#34; + str3
        else:
            str4 = &#34;&#34; + str3

        label = Gtk.Label.new(str4)
        label.set_tooltip_text(self.fname)
        label.set_single_line_mode(True)

        eb = Gtk.EventBox(); eb.add(label)
        eb.connect_after(&#34;button-press-event&#34;, self.doclabel_callb)
        eb.set_above_child(True)

        image = Gtk.Image()
        image.set_from_stock(Gtk.STOCK_CLOSE, Gtk.IconSize.MENU)
        butt = Gtk.Button();  butt.add(image)
        butt.set_focus_on_click(False)
        butt.set_relief( Gtk.ReliefStyle.NONE)
        #rc = butt.get_modifier_style()
        #rc.xthickness = 1; rc.ythickness = 1
        #butt.modify_style(rc)

        butt.connect(&#34;clicked&#34;, self.close_button)
        butt.set_tooltip_text(&#34;Close &#39;%s&#39;&#34; % os.path.basename(self.fname))
        hbox = Gtk.HBox()
        hbox.pack_start(eb, 0, 0, 0)
        hbox.pack_start(butt, 0, 0, 0)
        hbox.show_all()
        self.notebook.set_tab_label(ppp, hbox)
        hbox.queue_draw()

        #usleep(10)
        #print(&#34;Setting tablabel&#34;, str4)

    def close_button(self, arg1):
        #print( &#34;close_button&#34;, arg1)
        # Select me first
        self.mained.close_document(self)

    # --------------------------------------------------------------------
    def savemacro(self):

        #print( &#34;Savemacro&#34;)

        if not self.recarr:
            print(&#34;Cannot save, nothing recorded yet.&#34;)
            pedync.message(&#34;\n   Cannot save macro: nothing recorder yet.  \n\n&#34;)
            return

        fname = &#34;untitled.mac&#34;
        xdir = pedconfig.conf.config_dir + &#34;/macros/&#34;
        xfile = pedconfig.conf.config_dir + &#34;/macros/&#34; + fname
        old = os.getcwd()
        try:
            os.chdir(os.path.dirname(xfile))
        except:
            print(&#34;No macros directory&#34;, sys.exc_info())

        warnings.simplefilter(&#34;ignore&#34;)
        buts =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Save Macro&#34;, Gtk.ButtonsType.OK
        fc = Gtk.FileChooserDialog(&#34;Save Macro&#34;, None, Gtk.FileChooserAction.SAVE, \
            buts)

        fc.set_current_folder(xdir)
        fc.set_current_name(os.path.basename(xfile))
        fc.set_default_response(Gtk.ButtonsType.OK)
        fc.connect(&#34;response&#34;, self.done_mac_fc, old)
        fc.run()
        warnings.simplefilter(&#34;default&#34;)

    def done_mac_fc(self, win, resp, old):
        #print(  &#34;done_mac_fc&#34;, resp)
        # Back to original dir
        os.chdir(os.path.dirname(old))
        if resp == Gtk.ButtonsType.OK:

            #print(&#34;saveing&#34;, self.recarr)

            try:
                fname = win.get_filename()
                if not fname:
                    print(&#34;Must have filename&#34;)
                else:
                    fh = open(fname, &#34;wb&#34;)
                    pickle.dump(self.recarr, fh)
                    fh.close()
            except:
                print(&#34;Cannot save macro file&#34;, sys.exc_info())
                self.mained.update_statusbar(&#34;Cannot save macro: &#39;%s&#39;&#34; \
                                % os.path.basename(fname))

        win.destroy()

    def loadmacro(self):
        #print( &#34;Loadmacro&#34;)

        xfile = pedconfig.conf.config_dir + &#34;/macros/&#34;
        old = os.getcwd()
        try:
            os.chdir(os.path.dirname(xfile))
        except:
            print(&#34;No macros directory&#34;, sys.exc_info())

        but =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Load Macro&#34;, Gtk.ButtonsType.OK
        fc = Gtk.FileChooserDialog(&#34;Load Macro&#34;, None, Gtk.FileChooserAction.OPEN, \
            but)

        fc.set_current_folder(xfile)
        #fc.set_current_folder(old)
        fc.set_default_response(Gtk.ButtonsType.OK)
        fc.connect(&#34;response&#34;, self.done_mac_open_fc, old)
        fc.run()

    def done_mac_open_fc(self, win, resp, old):

        #print(  &#34;done_mac_fc&#34;, resp)
        # Back to original dir
        os.chdir(os.path.dirname(old))

        if resp == Gtk.ButtonsType.OK:
            try:
                fname = win.get_filename()
                if not fname:
                    print(&#34;Must have filename&#34;)
                else:
                    fh = open(fname, &#34;rb&#34;)
                    self.recarr = pickle.load(fh)
                    fh.close()
                    #print(&#34;macro&#34;, self.recarr)

            except:
                print(&#34;Cannot load macro file&#34;, sys.exc_info())
                self.mained.update_statusbar(&#34;Cannot load macro: &#39;%s&#39;&#34; % os.path.basename(fname))

        win.destroy()

    def     find(self, dlg, flag = False):
        #print(&#34;find&#34;, dlg);
        pedfind.find(dlg, self, flag)

    # Refresh current search buffer
    def search_again(self):
        if len(self.accum) == 0:
            return

        if self.src_changed:
            self.search(self.srctxt, self.regex, self.boolcase, self.boolregex)

    # --------------------------------------------------------------------
    def search(self, srctxt, regex, boolcase, boolregex):

        # Remember old settings:
        self.srctxt = srctxt;       self.regex = regex
        self.boolcase = boolcase;   self.boolregex = boolregex
        self.src_changed = False

        self.accum = []

        curr  = self.caret[1] + self.ypos
        currx = self.caret[0] + self.xpos

        was = -1; cnt = 0; cnt2 = 0
        before = 0; after = 0
        marked = False

        for line in self.text:
            # Search one line for multiple matches
            mmm = src_line(line, cnt, srctxt, regex, boolcase, boolregex)

            # Add marker to current lin
            if cnt == curr:
                if not marked:
                    linex =  str(currx) + &#34;:&#34;  + str(cnt) +\
                         &#34;:&#34; + str(0) + &#34; &#34; +\
                             &#34;---- current cursor position ----&#34;
                    self.accum.append(linex)
                    marked = True

            # Mark the next match for the display
            if cnt &gt; curr and was == -1:
                was = cnt2
            if  mmm:
                #print(&#34;mmm&#34;, mmm);

                # Multiple counts may be there
                for sss in mmm:
                    cnt2 += 1
                    # Mark the counters
                    if cnt &lt;= curr:
                        before += 1
                    else:
                        after += 1
                    self.accum.append(sss)

            if cnt % 100 == 0:
                self.mained.update_statusbar(\
                            &#34;Searching at %d&#34; % cnt, True)
                usleep(1)
            cnt += 1

        #if not marked:
        #    self.accum.append(&#34; ---- current cursor position ---- &#34;)
        #    marked = True

        return was, cnt2, before, after

    def check_syntax(self):

        tempfile = &#34;tmp&#34;
        writefile(tempfile, self.text, &#34;\n&#34;)

        #print(&#34;Checking file&#34;, self.ext)

        if self.ext == &#34;.php&#34; or  self.ext == &#34;.inc&#34;:
            #print(&#34;Checking PHP file&#34;)
            try:
                comline = [&#34;php&#34;, &#34;-l&#34;, tempfile,]
                try:
                    ret = subprocess.Popen(comline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
                except:
                    print(&#34;Cannot check %s&#34; % str(comline), sys.exc_info())
                    pedync.message(&#34;\n   Cannot check %s \n\n&#34;  % str(comline) +
                               str(sys.exc_info()) )
                    return
                try:
                    outs, errs = ret.communicate()
                except:
                    print(&#34;Cannot communicate with %s&#34; % str(comline), sys.exc_info())
                    return

            except:
                print(&#34;Cannot execute %s&#34; % str(comline), sys.exc_info())
                pass

            #print(&#34;outs&#34;, outs, &#34;errs&#34;, errs)

            if errs == b&#34;&#34;:
                pedync.message(&#34;\n  PHP Syntax OK   \n&#34;)
                self.mained.update_statusbar(&#34;Syntax OK.&#34;)
            else:
                serr = str(errs)
                idx = serr.find(&#34;line &#34;)
                if idx:
                    print(&#34;idx&#34;, idx, &#34;line no&#34;, &#34;&#39;&#34; + serr[idx + 5:] + &#34;&#39;&#34;)
                    self.gotoxy(10, atoi(serr[idx + 5:]) - 1)

                print(&#34;Error on compile: &#39;&#34;, serr, &#34;&#39;&#34;)
                pedync.message(&#34;    &#34; + serr + &#34;    &#34;)


        elif self.ext == &#34;.py&#34;:
            try:
               py_compile.compile(&#39;tmp&#39;, doraise = True)
            except py_compile.PyCompileError as msg:

                self.mained.update_statusbar(&#34;Syntax error.&#34;)

                if sys.version_info.major &lt; 3:
                    try:
                        ln  = msg[2][1][1]; col = msg[2][1][2]
                        mmm = &#34;\n&#34; + msg[2][0] + &#34;\n\n    Ln: &#34; +  str(ln) + &#34; Col: &#34; + str(col)
                        self.gotoxy(col - 1, ln - 1)
                        pedync.message(&#34;    &#34; + mmm + &#34;    &#34;, msg[1])
                    except:
                        pedync.message(&#34; &#34; + str(msg) + &#34;  &#34;, &#34;Syntax Error&#34;)
                        #print(&#34;line&#34;, msg);
                        pass
                else:
                        print(&#34;Error on compile: &#39;&#34;, msg.args, &#34;&#39;&#34;)
                        zzz = str(msg.args[2]).split(&#34;(&#34;)
                        sss = zzz[1].split()[2].replace(&#34;)&#34;, &#34;&#34;)
                        #print (&#34;sss&#34;, sss)
                        try:
                            self.gotoxy(10, int(sss) - 1)
                        except:
                            pass
                        pedync.message(&#34;    &#34; + str(msg) + &#34;    &#34;)

            except:
                print(sys.exc_info())
            else:
                pedync.message(&#34;\n  PY Syntax OK   \n&#34;)
                self.mained.update_statusbar(&#34;Syntax OK.&#34;)
            finally:
                pass

        elif self.ext == &#34;.js&#34;:

            tempfile2 = &#34;tmp.js&#34;
            os.rename(tempfile, tempfile2)
            tempfile = tempfile2

            print(&#34;Checking JS file&#34;)
            try:
                comline = [&#34;node&#34;, &#34;--check&#34;, tempfile2,]
                try:
                    ret = subprocess.Popen(comline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
                except:
                    print(&#34;Cannot check %s&#34; % str(comline), sys.exc_info())
                    pedync.message(&#34;\n   Cannot check %s \n\n&#34;  % str(comline) +
                               str(sys.exc_info()) )
                    return
                try:
                    outs, errs = ret.communicate()
                except:
                    print(&#34;Cannot communicate with %s&#34; % str(comline), sys.exc_info())
                    return

            except:
                print(&#34;Cannot execute %s&#34; % str(comline), sys.exc_info())
                pass

            #print(&#34;outs&#34;, outs, &#34;errs&#34;, errs)

            if errs == b&#34;&#34;:
                pedync.message(&#34;\n  JS Syntax OK   \n&#34;)
                self.mained.update_statusbar(&#34;Syntax OK.&#34;)
            else:
                serr = str(errs)
                idx = serr.find(&#34;line &#34;)
                if idx:
                    #print(&#34;idx&#34;, idx, &#34;line no&#34;, &#34;&#39;&#34; + serr[idx + 5:] + &#34;&#39;&#34;)
                    self.gotoxy(10, atoi(serr[idx + 5:]) - 1)

                print(&#34;Error on compile: &#39;&#34;, serr, &#34;&#39;&#34;)
                pedync.message(&#34;    &#34; + serr + &#34;    &#34;)

        else:
            self.mained.update_statusbar(&#34;No Syntax check for this kind of file.&#34;)

        os.remove(tempfile)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>gi.repository.Gtk.DrawingArea</li>
<li>gi.overrides.Gtk.Widget</li>
<li>gi.repository.Gtk.Widget</li>
<li>gi.repository.GObject.InitiallyUnowned</li>
<li>gi.overrides.GObject.Object</li>
<li>gi.repository.GObject.Object</li>
<li>gi._gi.GObject</li>
<li>gi.repository.Atk.ImplementorIface</li>
<li>gi.repository.Gtk.Buildable</li>
<li>gobject.GInterface</li>
<li>pedlib.peddraw.peddraw</li>
<li>pedlib.pedxtnd.pedxtnd</li>
<li>pedlib.pedtask.pedtask</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="peddoc.pedDoc.addict"><code class="name flex">
<span>def <span class="ident">addict</span></span>(<span>self, widget, string, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addict(self, widget, string, arg):
    #print( &#34;addict&#34;, arg)
    if not pedspell.append_user_dict(self, arg):
        self.mained.update_statusbar(&#34;Cannot append to user dict&#34;)
    else:
        self.mained.update_statusbar(&#34;Added &#39;%s&#39; to user dict&#34; % arg)
        self.newword = True

    # Force new spell check
    self.fired += 1
    self.run_keytime()
    #self.mained.threads.submit_job(keytime, self, None)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.area_button"><code class="name flex">
<span>def <span class="ident">area_button</span></span>(<span>self, area, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_button(self, area, event):

    self.lastevent = event

    #if pedconfig.conf.pgdebug &gt; 5:
    #    print( &#34;Button press  &#34;, self, event.type, &#34; x=&#34;, event.x,
    #    &#34; y=&#34;, event.y)

    event.x = int(event.x) - self.strip
    event.y = int(event.y)

    if  event.type == Gdk.EventType.BUTTON_PRESS:
        if event.button == 1:
            #print( &#34;Left Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
            self.mx = int(event.x); self.my = int(event.y)
            xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
            # Find current pos, gather tabs, adjust back
            try:
                line = self.text[self.ypos + yyy]
            except:
                line = &#34;&#34;
            offs = calc_tabs2(line, xxx)

            # Are we in selection?
            #print( &#34;xxx&#34;, self.xpos + xxx, &#34;yyy&#34;, self.ypos + yyy)
            #rp = xxx + self.xpos
            #print( &#34;xpos&#34;, self.xpos, &#34;xxx&#34;, xxx, &#34;rp&#34;, rp)
            #print( line)
            #print( &#34;line part&#34;, &#34;&#39;&#34; + line[rp:rp+8] + &#34;&#39;&#34;)

            # Are we in selection?
            if self.xsel != -1:
                #print(&#34;xsel&#34;, self.xsel, &#34;ysel&#34;, self.ysel)
                #print(&#34;xsel2&#34;, self.xsel2, &#34;ysel2&#34;, self.ysel2)

                xssel = min(self.xsel, self.xsel2)
                xesel = max(self.xsel, self.xsel2)
                yssel = min(self.ysel, self.ysel2)
                yesel = max(self.ysel, self.ysel2)

                if (self.ypos + yyy &gt;= yssel and self.ypos + yyy &lt;= yesel) and \
                     (self.xpos + xxx &gt;= xssel and self.xpos + xxx &lt;= xesel):
                    #print(&#34;in selection&#34;)
                    self.drag = True
                else:
                    # Erase selection, pos cursor
                    self.clearsel()
                    self.set_caret(self.xpos + xxx - (offs - xxx),
                                 self.ypos + yyy )
            else:
                self.set_caret(self.xpos + xxx - (offs - xxx),
                             self.ypos + yyy )

            self.fired += 1
            self.run_keytime()
            #self.mained.threads.submit_job(keytime, self, None)

        if event.button == 3:
            #print( &#34;Right Click at x=&#34;, event.x, &#34;y=&#34;, event.y)
            flag = False; xx = 0; yy = 0; zz = 0
            if self.spell:
                yyy = int(self.ypos + self.get_height() / self.cyy)
                for xaa, ybb, lcc in self.ularr:
                    # Look within visible range
                    if ybb &gt;= self.ypos and ybb &lt; yyy:
                        ybb -= self.ypos
                        xaa -= self.xpos; lcc -= self.xpos
                        xaa *= self.cxx ; ybb *= self.cyy
                        lcc *= self.cxx
                        yy2 = ybb + self.cyy

                        if self.intersect(xaa, ybb, lcc, yy2, event):
                            xx = int(xaa / self.cxx + self.xpos)
                            yy = int(ybb / self.cyy + self.ypos)
                            zz = int(lcc / self.cxx + self.xpos)
                            flag = True
            if flag:
                line = self.text[yy]
                #print( &#34;Spell delimit: &#39;&#34; + line[xx:zz] + &#34;&#39;&#34;)
                self.xsel = xx;
                self.xsel2 = zz

                self.ysel = self.ysel2 = yy
                self.spellstr = line[int(xx):int(zz)]
                self.popspell(area, event, self.spellstr)
            else:
                if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
                    if self.xsel == -1:
                        yyy = int(event.y / self.cyy + self.ypos)
                        xxx = int(event.x / self.cxx + self.xpos)
                        line = self.text[yyy]
                        self.xsel, self.xsel2 = selasci2(line, xxx, &#34;_-&#34;)
                        self.ysel = self.ysel2 = yyy
                    else:
                        line = self.text[self.ysel]

                    strx = line[int(self.xsel):int(self.xsel2)]
                    #print(&#34;&#39;&#34; + strx + &#34;&#39;&#34;)
                    if strx:
                        self.poprclick2(area, event, strx)
                else:
                    self.poprclick(area, event)

    elif  event.type == Gdk.EventType.BUTTON_RELEASE:
        #print( &#34;button release&#34;, event.button)
        self.mx = -1; self.my = -1
        self.scrtab = False
        self.drag = False
        ttt = &#34;Release&#34;
        xxx = int(event.x / self.cxx); yyy = int(event.y / self.cyy)
        # Find current pos, gather tabs, adjust back
        try:
            line = self.text[self.ypos + yyy]
        except:
            line = &#34;&#34;
        offs = calc_tabs2(line, xxx)
        self.set_caret(self.xpos + xxx - (offs - xxx),
                                 self.ypos + yyy )

    elif  event.type == Gdk.EventType._2BUTTON_PRESS:

        if pedconfig.conf.pgdebug &gt; 2:
            print (&#34;Double click %.2f %.2f&#34; % (event.x, event.y))

        self.mx = int(event.x); self.my = int(event.y)
        xxx = int(event.x / self.cxx)
        yyy = int(event.y / self.cyy)

        # Find current pos, gather tabs, adjust back
        try:
            line = self.text[self.ypos + yyy]
        except:
            line = &#34;&#34;

        # Find current pos on tabbed line
        offs = calc_tabs2(line, xxx)
        self.set_caret(self.xpos + xxx - (offs - xxx), self.ypos + yyy )
        #self.set_caret(len(xxx2), yyy)

        # Erase selection
        if self.xsel != -1:
            self.clearsel()

        # Select word
        if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
            pedconfig.conf.keyh.acth.ctrl_b(self)
        else:
            pedconfig.conf.keyh.acth.alt_v(self)
        # Copy to clip

        if event.state &amp; Gdk.ModifierType.SHIFT_MASK:
            pedconfig.conf.keyh.acth.ctrl_c(self)

    else:
        print(&#34;Unexpected mouse op.&#34;)

    self.grab_focus()
    return True</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.area_enter"><code class="name flex">
<span>def <span class="ident">area_enter</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_enter(self, widget, event):
    #print( &#34;area_enter&#34;)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.area_focus"><code class="name flex">
<span>def <span class="ident">area_focus</span></span>(<span>self, area, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_focus(self, area, event):
    #print( &#34;ped doc area focus&#34;, event)
    return False</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.area_key"><code class="name flex">
<span>def <span class="ident">area_key</span></span>(<span>self, area, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_key(self, area, event):

    #print (&#34;peddoc area_key&#34;, event.keyval)
    #return True # TEST

    # Restart timer ticks
    pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
    pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT

    # Maintain a count of events, only fire only fire on the last one
    self.fired += 1
    self.run_keytime()

    #if not self.fired:
    #    self.mained.threads.submit_job(keytime, self, None)

    # The actual key handler
    try:
        self.keyh.handle_key(self, area, event)
    except:
        print(&#34;Key handler died at key&#34;, event.keyval, sys.exc_info())
        put_exception(&#34;key handler&#34;)

    #if event.type == Gdk.KEY_RELEASE:
    #    self.source_id = GObject.idle_add(self.idle_callback)

    # We handled it
    return True</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.area_leave"><code class="name flex">
<span>def <span class="ident">area_leave</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_leave(self, widget, event):
    #print( &#34;area_leave&#34;)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.area_motion"><code class="name flex">
<span>def <span class="ident">area_motion</span></span>(<span>self, area, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area_motion(self, area, event):
    #print (&#34;motion event&#34;, event.state, event.x, event.y)
    if event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
        #print( &#34;motion event butt 1&#34;, event.state, event.x, event.y)
        if self.drag:
            #print (&#34;drag motion event&#34;, event.state, event.x, event.y)
            targ = Gtk.TargetList(); targ.add_text_targets(0)
            self.drag_begin(targ, Gdk.DragAction.COPY, 0, event)
            self.drag = False
            return

        if self.xsel == -1 and self.scrtab != True:
            begsel = False
            # Horiz drag - regular sel
            if abs(event.x - self.mx) &gt; DRAGTRESH:
                self.colsel = False; begsel = True

            if begsel:
                self.xsel = self.xsel2 = self.xpos + self.caret[0]
                self.ysel = self.ysel2 = self.ypos + self.caret[1]
                #print( &#34;colsel xsel, ysel&#34;, self.colsel, self.xsel, self.ysel)
            if self.scrtab == False:
                # Vert drag - colsel
                if abs(event.y - self.my) &gt; DRAGTRESH:
                    self.scrtab  = True
                    self.colsel = True

        if self.scrtab  == True:
            self.xsel = self.xsel2 = self.xpos + self.caret[0]
            self.ysel = self.ysel2 = self.ypos + self.caret[1]
            xidx = self.xpos + self.caret[0]
            yidx = self.ypos + self.caret[1]
            if  event.y &gt;  self.my:
                yidx += 1
            if  event.y &gt;  self.my:
                yidx -= 1
            self.set_caret(xidx, yidx)
            self.my = event.y

        if self.xsel != -1:
            # Already selected, mark
            self.ysel2 = self.pix2ypos(event.y)
            if self.ysel2 &lt; self.ysel:
                self.xsel    = self.pix2xpos(event.x)
            else:
                self.xsel2 = self.pix2xpos(event.x)

        self.invalidate()

    if event.state &amp; Gdk.ModifierType.SHIFT_MASK and \
        event.state &amp; Gdk.ModifierType.BUTTON1_MASK:
        #print( &#34;Shift Drag&#34;, event.x, event.y)
        pass
    pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.build_menu"><code class="name flex">
<span>def <span class="ident">build_menu</span></span>(<span>self, window, items)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_menu(self, window, items):

    menu =  Gtk.Menu()
    for aa, bb, cc, dd, ee  in items:
        #print (&#34;menu item&#34;, aa)
        if ee == &#34;&lt;Separator&gt;&#34;:
            menu_item = Gtk.MenuItem.new_with_mnemonic(
                        &#34;----------------------------&#34;)
            menu_item.set_sensitive(False)
            menu_item.set_size_request(-1, 10)
            pass
        elif type(ee) == type(()):
            self.submenu =  Gtk.Menu()
            for aaa, bbb, ccc, ddd, eee  in ee:
                #print (&#34;sub menu item&#34;, aaa)
                sss = self._fill(aaa, bbb)
                menu_subitem = Gtk.MenuItem.new_with_mnemonic(sss)
                menu_subitem.connect(&#34;activate&#34;, self.rclick_action_doc, aaa, ddd )
                self.submenu.append(menu_subitem)
            sss = self._fill(aa, bb)
            menu_item = Gtk.MenuItem.new_with_mnemonic(sss)
            menu_item.set_submenu(self.submenu)
        else:
            sss = self._fill(aa, bb)
            menu_item = Gtk.MenuItem.new_with_mnemonic(sss)
            menu_item.connect(&#34;activate&#34;, self.rclick_action_doc, aa, dd )
        menu.append(menu_item)
    return menu</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.builddoc"><code class="name flex">
<span>def <span class="ident">builddoc</span></span>(<span>self, ppp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def builddoc(self, ppp):
    if ppp.area.diffmode == 1:
        got_src = True
    if ppp.area.diffmode == 2:
        got_targ = True</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.calc_maxline"><code class="name flex">
<span>def <span class="ident">calc_maxline</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_maxline(self):
    mlen = 0
    for aa in self.text:
        xlen = len(aa)
        if mlen &lt; xlen:
            mlen = xlen
    #self.maxlinelen = mlen
    return mlen</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.check_syntax"><code class="name flex">
<span>def <span class="ident">check_syntax</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_syntax(self):

    tempfile = &#34;tmp&#34;
    writefile(tempfile, self.text, &#34;\n&#34;)

    #print(&#34;Checking file&#34;, self.ext)

    if self.ext == &#34;.php&#34; or  self.ext == &#34;.inc&#34;:
        #print(&#34;Checking PHP file&#34;)
        try:
            comline = [&#34;php&#34;, &#34;-l&#34;, tempfile,]
            try:
                ret = subprocess.Popen(comline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
            except:
                print(&#34;Cannot check %s&#34; % str(comline), sys.exc_info())
                pedync.message(&#34;\n   Cannot check %s \n\n&#34;  % str(comline) +
                           str(sys.exc_info()) )
                return
            try:
                outs, errs = ret.communicate()
            except:
                print(&#34;Cannot communicate with %s&#34; % str(comline), sys.exc_info())
                return

        except:
            print(&#34;Cannot execute %s&#34; % str(comline), sys.exc_info())
            pass

        #print(&#34;outs&#34;, outs, &#34;errs&#34;, errs)

        if errs == b&#34;&#34;:
            pedync.message(&#34;\n  PHP Syntax OK   \n&#34;)
            self.mained.update_statusbar(&#34;Syntax OK.&#34;)
        else:
            serr = str(errs)
            idx = serr.find(&#34;line &#34;)
            if idx:
                print(&#34;idx&#34;, idx, &#34;line no&#34;, &#34;&#39;&#34; + serr[idx + 5:] + &#34;&#39;&#34;)
                self.gotoxy(10, atoi(serr[idx + 5:]) - 1)

            print(&#34;Error on compile: &#39;&#34;, serr, &#34;&#39;&#34;)
            pedync.message(&#34;    &#34; + serr + &#34;    &#34;)


    elif self.ext == &#34;.py&#34;:
        try:
           py_compile.compile(&#39;tmp&#39;, doraise = True)
        except py_compile.PyCompileError as msg:

            self.mained.update_statusbar(&#34;Syntax error.&#34;)

            if sys.version_info.major &lt; 3:
                try:
                    ln  = msg[2][1][1]; col = msg[2][1][2]
                    mmm = &#34;\n&#34; + msg[2][0] + &#34;\n\n    Ln: &#34; +  str(ln) + &#34; Col: &#34; + str(col)
                    self.gotoxy(col - 1, ln - 1)
                    pedync.message(&#34;    &#34; + mmm + &#34;    &#34;, msg[1])
                except:
                    pedync.message(&#34; &#34; + str(msg) + &#34;  &#34;, &#34;Syntax Error&#34;)
                    #print(&#34;line&#34;, msg);
                    pass
            else:
                    print(&#34;Error on compile: &#39;&#34;, msg.args, &#34;&#39;&#34;)
                    zzz = str(msg.args[2]).split(&#34;(&#34;)
                    sss = zzz[1].split()[2].replace(&#34;)&#34;, &#34;&#34;)
                    #print (&#34;sss&#34;, sss)
                    try:
                        self.gotoxy(10, int(sss) - 1)
                    except:
                        pass
                    pedync.message(&#34;    &#34; + str(msg) + &#34;    &#34;)

        except:
            print(sys.exc_info())
        else:
            pedync.message(&#34;\n  PY Syntax OK   \n&#34;)
            self.mained.update_statusbar(&#34;Syntax OK.&#34;)
        finally:
            pass

    elif self.ext == &#34;.js&#34;:

        tempfile2 = &#34;tmp.js&#34;
        os.rename(tempfile, tempfile2)
        tempfile = tempfile2

        print(&#34;Checking JS file&#34;)
        try:
            comline = [&#34;node&#34;, &#34;--check&#34;, tempfile2,]
            try:
                ret = subprocess.Popen(comline, stderr=subprocess.PIPE, stdout=subprocess.PIPE)
            except:
                print(&#34;Cannot check %s&#34; % str(comline), sys.exc_info())
                pedync.message(&#34;\n   Cannot check %s \n\n&#34;  % str(comline) +
                           str(sys.exc_info()) )
                return
            try:
                outs, errs = ret.communicate()
            except:
                print(&#34;Cannot communicate with %s&#34; % str(comline), sys.exc_info())
                return

        except:
            print(&#34;Cannot execute %s&#34; % str(comline), sys.exc_info())
            pass

        #print(&#34;outs&#34;, outs, &#34;errs&#34;, errs)

        if errs == b&#34;&#34;:
            pedync.message(&#34;\n  JS Syntax OK   \n&#34;)
            self.mained.update_statusbar(&#34;Syntax OK.&#34;)
        else:
            serr = str(errs)
            idx = serr.find(&#34;line &#34;)
            if idx:
                #print(&#34;idx&#34;, idx, &#34;line no&#34;, &#34;&#39;&#34; + serr[idx + 5:] + &#34;&#39;&#34;)
                self.gotoxy(10, atoi(serr[idx + 5:]) - 1)

            print(&#34;Error on compile: &#39;&#34;, serr, &#34;&#39;&#34;)
            pedync.message(&#34;    &#34; + serr + &#34;    &#34;)

    else:
        self.mained.update_statusbar(&#34;No Syntax check for this kind of file.&#34;)

    os.remove(tempfile)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.clearsel"><code class="name flex">
<span>def <span class="ident">clearsel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clearsel(self):
    old = self.xsel
    self.xsel  =  self.ysel = -1
    self.xsel2 =  self.ysel2 = -1
    if old != -1:
        self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.close_button"><code class="name flex">
<span>def <span class="ident">close_button</span></span>(<span>self, arg1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_button(self, arg1):
    #print( &#34;close_button&#34;, arg1)
    # Select me first
    self.mained.close_document(self)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.closedoc"><code class="name flex">
<span>def <span class="ident">closedoc</span></span>(<span>self, noprompt=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def closedoc(self, noprompt = False):
    #self.stopthread = True
    strx = &#34;Closing &#39;{0:s}&#39;&#34;.format(self.fname)
    if pedconfig.conf.verbose:
        print(&#34;Closing doc:&#34;, strx)
    self.mained.update_statusbar(strx)
    self.saveparms()

    rrr = self.prompt_save(noprompt)
    if not rrr:
        # Clear treestore(s)
        self.mained.update_treestore([])
        self.mained.update_treestore2([])
        # Add to accounting:
        logentry(&#34;Closed File&#34;, self.start_time, self.fname)
        self.mained.oh.add(self.fname)
    return rrr</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.coloring"><code class="name flex">
<span>def <span class="ident">coloring</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coloring(self, flag):
    self.colflag = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.configure_event"><code class="name flex">
<span>def <span class="ident">configure_event</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure_event(self, widget, event):
    #print( &#34;configure_event&#34;, event)
    #self.grab_focus()
    #self.width = 0; self.height = 0
    #self.invalidate()
    #print( self, event)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.create_menuitem"><code class="name flex">
<span>def <span class="ident">create_menuitem</span></span>(<span>self, string, action, arg=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_menuitem(self, string, action, arg = None):
    rclick_menu = Gtk.MenuItem(string)
    if action:
        rclick_menu.connect(&#34;activate&#34;, action, string, arg)
    rclick_menu.show()
    return rclick_menu

    # Create the menubar and toolbar
    action_group = Gtk.ActionGroup(&#34;DocWindowActions&#34;)
    action_group.add_actions(entries)
    return action_group</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.delundo"><code class="name flex">
<span>def <span class="ident">delundo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delundo(self):
    self.undoarr = []; self.redoarr = []
    # Remove file
    hhh = hash_name(self.fname) + &#34;.udo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    fh = open(xfile, &#34;w&#34;)
    fh.close()
    hhh = hash_name(self.fname) + &#34;.rdo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    fh = open(xfile, &#34;w&#34;)
    fh.close()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.destroy_cb"><code class="name flex">
<span>def <span class="ident">destroy_cb</span></span>(<span>self, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy_cb(self, arg):
    #print(&#34;dest&#34;, arg)
    #self.stopthread = True
    pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.diffx"><code class="name flex">
<span>def <span class="ident">diffx</span></span>(<span>self, srctxt, targtxt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diffx(self, srctxt, targtxt):
    arrx = []; forw = 0; forw2 = 0
    diffscan = 500
    for aa in range(len(targtxt)):
        try:
            if srctxt[aa + forw2] == targtxt[aa + forw]:
                arrx.append(targtxt[aa + forw])
                continue
            fff = False
            # Resync forward
            try:
                for bb in range(diffscan):
                    ttt = targtxt[aa + forw + bb]
                    if srctxt[aa + forw2] == ttt:
                        for cc in range(bb):
                            strx = &#34; --ins-- [ &#34; + targtxt[aa + forw + cc] + &#34; ] &#34;
                            arrx.append(strx)
                        arrx.append(ttt)
                        forw += bb
                        #print(&#34;forward set&#34;, forw, ttt)
                        fff = True
                        break
            except:
                pass #print(&#34;EOB while fw&#34;, ttt)

            if fff:
                continue

            # Resync on the other file
            try:
                for bb in range(diffscan):
                    ttt = srctxt[aa  + forw2 + bb]
                    if ttt ==  targtxt[aa + forw]:
                        for cc in range(bb):
                            strx = &#34; --del-- [ &#34; + srctxt[aa + forw2 + cc] + &#34; ] &#34;
                            arrx.append(strx)
                        arrx.append(targtxt[aa + forw])
                        forw2 += bb
                        #print(&#34;backward set&#34;, forw, ttt)
                        fff = True
                        break
            except:
                pass #print(&#34;EOB while other fw&#34;)

            if fff:
                continue

            # See if diff is small
            lendiff = len(srctxt[aa + forw2]) - len(targtxt[aa + forw])
            #print (&#34;lendiff&#34;, lendiff, srctxt[aa], targtxt[aa+forw])
            if abs(lendiff) &lt; 3:
                strx = &#34; --chg-- [ &#34; + srctxt[aa + forw2] + &#34; ] &#34;
            else:
                strx = &#34; --ins-- [ &#34; + targtxt[aa + forw] + &#34; ] &#34;
                forw2 -= 1   # Stand still on the other
            arrx.append(strx)
            #print(&#34;could not resync&#34;)

        except:
            #print(&#34;Buffers are different lengths&#34;, sys.exc_info())
            pass

    self.mained.diffpane.area.loadbuff(arrx)
    usleep(100)
    self.gotoxy(self.xpos + self.caret[0], self.ypos + self.caret[1])

    self.mained.diffpane.area.xpos = self.xpos
    self.mained.diffpane.area.ypos = self.ypos
    self.mained.diffpane.area.gotoxy(
                     self.xpos + self.caret[0], self.ypos + self.caret[1])
    usleep(10)
    self.mained.diffpane.area.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.do_chores"><code class="name flex">
<span>def <span class="ident">do_chores</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_chores(self):
    #print( &#34;do_chores&#34;)
    if  not self.needscan:
        return
    self.needscan = False

    # Scan left pane
    pedconfig.conf.idle = pedconfig.conf.IDLE_TIMEOUT
    pedconfig.conf.syncidle = pedconfig.conf.SYNCIDLE_TIMEOUT</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.doc_activate_action"><code class="name flex">
<span>def <span class="ident">doc_activate_action</span></span>(<span>self, action)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doc_activate_action(self, action):

    print(&#34;doc_activate_action&#34;)

    dialog = Gtk.MessageDialog(self, Gtk.DIALOG_DESTROY_WITH_PARENT,
        Gtk.ButtonsType.INFO, Gtk.ButtonsType.CLOSE,
        &#39;You activated action: &#34;%s&#34; of type &#34;%s&#34;&#39; % (action.get_name(), type(action)))
    # Close dialog on user response
    dialog.connect (&#34;response&#34;, lambda d, r: d.destroy())
    dialog.show()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.doclabel_callb"><code class="name flex">
<span>def <span class="ident">doclabel_callb</span></span>(<span>self, widg, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doclabel_callb(self, widg, event):
    #print(&#34;doclabel_callb&#34;, event.button, event.type)
    if event.button == 3:
        #print(&#34;Right click&#34;, self.fname)
        self.poprclick3(event)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.done_fc"><code class="name flex">
<span>def <span class="ident">done_fc</span></span>(<span>self, win, resp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done_fc(self, win, resp):
    #print( &#34;done_fc&#34;, win, resp)
    if resp == Gtk.ResponseType.OK:
        fname = win.get_filename()
        if not fname:
            print(&#34;Must have filename&#34;)
        else:
            if os.path.isfile(fname):
                resp = pedync.yes_no_cancel(&#34;Overwrite File Prompt&#34;,
                            &#34;Overwrite existing file?\n &#39;%s&#39;&#34; % fname, False)
                print(&#34;resp&#34;, resp)
                if resp == Gtk.ResponseType.YES:
                    self.fname = fname
                    self.ext = os.path.splitext(self.fname)[1].lower()
                    self.writeout()
                    self.mained.update_statusbar(&#34;Saved under new filename &#39;%s&#39;&#34; % fname)
                else:
                    self.mained.update_statusbar(&#34;No new file name supplied, cancelled &#39;Save As&#39;&#34;)
            else:
                self.fname = fname
                self.ext = os.path.splitext(self.fname)[1].lower()
                self.writeout()

            pedconfig.conf.pedwin.mywin.set_title(&#34;pyedpro: &#34; + self.fname)

    win.destroy()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.done_mac_fc"><code class="name flex">
<span>def <span class="ident">done_mac_fc</span></span>(<span>self, win, resp, old)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done_mac_fc(self, win, resp, old):
    #print(  &#34;done_mac_fc&#34;, resp)
    # Back to original dir
    os.chdir(os.path.dirname(old))
    if resp == Gtk.ButtonsType.OK:

        #print(&#34;saveing&#34;, self.recarr)

        try:
            fname = win.get_filename()
            if not fname:
                print(&#34;Must have filename&#34;)
            else:
                fh = open(fname, &#34;wb&#34;)
                pickle.dump(self.recarr, fh)
                fh.close()
        except:
            print(&#34;Cannot save macro file&#34;, sys.exc_info())
            self.mained.update_statusbar(&#34;Cannot save macro: &#39;%s&#39;&#34; \
                            % os.path.basename(fname))

    win.destroy()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.done_mac_open_fc"><code class="name flex">
<span>def <span class="ident">done_mac_open_fc</span></span>(<span>self, win, resp, old)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def done_mac_open_fc(self, win, resp, old):

    #print(  &#34;done_mac_fc&#34;, resp)
    # Back to original dir
    os.chdir(os.path.dirname(old))

    if resp == Gtk.ButtonsType.OK:
        try:
            fname = win.get_filename()
            if not fname:
                print(&#34;Must have filename&#34;)
            else:
                fh = open(fname, &#34;rb&#34;)
                self.recarr = pickle.load(fh)
                fh.close()
                #print(&#34;macro&#34;, self.recarr)

        except:
            print(&#34;Cannot load macro file&#34;, sys.exc_info())
            self.mained.update_statusbar(&#34;Cannot load macro: &#39;%s&#39;&#34; % os.path.basename(fname))

    win.destroy()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.draw_event"><code class="name flex">
<span>def <span class="ident">draw_event</span></span>(<span>self, pdoc, cr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_event(self, pdoc, cr):

    self.hhh = self.get_height();  self.www = self.get_width()
    self.xlen = len(self.text)

    ctx = self.get_style_context()
    fg_color = ctx.get_color(Gtk.StateFlags.NORMAL)
    #bg_color = ctx.get_background_color(Gtk..NORMAL)

    # Paint white, ignore system BG
    #cr.set_source_rgba(255, 255, 255)
    # Paint prescribed color
    if self.readonly:
        # Slightly darker / lighter
        newcol =  list(self.bgcolor)
        for aa in range(len(newcol)):
            if newcol[aa] &gt; 0.5: newcol[aa] -= .08
            else: newcol[aa] += .2
        cr.set_source_rgba(*list(newcol))
    else:
        cr.set_source_rgba(*list(self.bgcolor))

    cr.rectangle( 0, 0, self.www, self.hhh)
    cr.fill()

    cr.set_source_rgba(*list(self.stripcolor))
    cr.rectangle( 0, 0, self.strip - 2, self.hhh)
    cr.fill()

    try:
        pedplug.predraw(self, cr)
    except:
        print(&#34;plugin failed&#34;, sys.exc_info())

    # Pre set for drawing
    #cr.set_source_rgba(*list(fg_color))
    # Paint prescribed color
    cr.set_source_rgba(*list(self.fgcolor))

    cr.move_to(0, 0)
    self.layout = PangoCairo.create_layout(cr)
    self.layout.set_font_description(self.fd)

    self.draw_maintext(cr)

    if not self.hex:
        # Do the text drawing in stages ...
        try:
            self.draw_selection(cr)
            self.draw_syntax(cr)
            self.draw_clsyntax(cr)
            self.draw_comments(cr)
            self.draw_spellerr(cr)
        except:
            print(&#34;Failed to draw colors&#34;, sys.exc_info())

    if self.startxxx != -1:
        self.gotoxy(self.startxxx, self.startyyy)
        self.startxxx = -1; self.startyyy = -1

    self.draw_caret(cr)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.file_dlg"><code class="name flex">
<span>def <span class="ident">file_dlg</span></span>(<span>self, resp)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_dlg(self, resp):
    #print &#34;File dialog&#34;
    if resp == Gtk.ResponseType.YES:
        but =   &#34;Cancel&#34;, Gtk.ResponseType.CANCEL,   \
                        &#34;Save File&#34;, Gtk.ResponseType.OK
        fc = Gtk.FileChooserDialog(&#34;Save file as ... &#34;, None,
                Gtk.FileChooserAction.SAVE, but)
        #fc.set_do_overwrite_confirmation(True)

        fc.set_current_name(os.path.basename(self.fname))
        fc.set_current_folder(os.path.dirname(self.fname))
        fc.set_default_response(Gtk.ResponseType.OK)
        fc.connect(&#34;response&#34;, self.done_fc)
        fc.run()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, dlg, flag=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def     find(self, dlg, flag = False):
    #print(&#34;find&#34;, dlg);
    pedfind.find(dlg, self, flag)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.flash"><code class="name flex">
<span>def <span class="ident">flash</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flash(self, flag):
    self.bigcaret = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.focus_in_cb"><code class="name flex">
<span>def <span class="ident">focus_in_cb</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus_in_cb(self, widget, event):
    #print (&#34;focus_in_cb&#34;, self.fname)
    self.focus = True
    try:
        if os.path.isfile(self.fname):
            os.chdir(os.path.dirname(self.fname))
            xstat = os.stat(self.fname)
            if not self.readonly:
                #print(self.fname, &#34;stat&#34;, self.stat.st_mtime, &#34;xstat&#34;, xstat.st_mtime)
                if self.stat.st_mtime !=  xstat.st_mtime:
                    rrr = pedync.yes_no_cancel(&#34;File changed outside PyEdPro&#34;,
                        &#34;&#39;%s&#39;\n&#34; \
                        &#34;changed outside PyEdPro.&#34; \
                        &#34;Reload?&#34; % self.fname, False)
                    if rrr == Gtk.ResponseType.YES:
                        if pedconfig.conf.verbose:
                           print(&#34;Reloading&#34;, self.fname)
                        self.savebackup()
                        self.saveparms()

                        # Is it already loaded? ... close
                        #nn = self.notebook.get_n_pages()
                        #fname2 = os.path.realpath(self.fname)
                        #for aa in range(nn):
                        #    vcurr = self.notebook.get_nth_page(aa)
                        #    if vcurr.area.fname == fname2:
                        #        if pedconfig.conf.verbose:
                        #            print(&#34;Closing &#39;&#34;+ fname2 + &#34;&#39;&#34;)
                        #        #vcurr.area.closedoc(noprompt = True)
                        #        #self.mained.close_document(self)

                        #usleep(100)
                        self.loadfile(self.fname, reload = True)
                        self.loadparms()

            # Update stat info
            self.stat = xstat
    except:
        put_exception(&#34;cmp mtime&#34;)
        pass

    self.update_bar2()
    self.needscan = True
    self.do_chores()
    #self.fired = 3</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.focus_out_cb"><code class="name flex">
<span>def <span class="ident">focus_out_cb</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def focus_out_cb(self, widget, event):
    #print( &#34;focus_out_cb&#34;, widget, event)
    self.focus = False</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.get_height"><code class="name flex">
<span>def <span class="ident">get_height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_height(self):
    rect = self.get_allocation()
    return rect.height</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.get_height_char"><code class="name flex">
<span>def <span class="ident">get_height_char</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_height_char(self):
    return self.get_height()  / self.cyy</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.get_size"><code class="name flex">
<span>def <span class="ident">get_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_size(self):
    rect = self.get_allocation()
    return rect.width, rect.height</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.get_width"><code class="name flex">
<span>def <span class="ident">get_width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width(self):
    rect = self.get_allocation()
    return rect.width</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.get_width_char"><code class="name flex">
<span>def <span class="ident">get_width_char</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_width_char(self):
    return self.get_width() / self.cxx</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.gotoxy"><code class="name flex">
<span>def <span class="ident">gotoxy</span></span>(<span>self, xx, yy, sel=None, mid=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gotoxy(self, xx, yy, sel = None, mid = False):

    #print (&#34;gotoxy&#34;, xx, yy)
    #xx +=  30
    # Contain
    ylen = len(self.text)
    xx2 = max(xx, 0);  yy2 = max(yy, 0)
    xx2 = min(xx, self.maxlinelen);  yy2 = min(yy, ylen)

    if sel:
        self.xsel = xx2; self.xsel2 = xx2 + sel
        self.ysel = yy2; self.ysel2 = yy2
        self.invalidate()
    #else:
    #    self.xsel = xx2; self.xsel2 = xx2
    #    self.ysel = yy2; self.ysel2 = yy2

    if mid:
        self.set_caret_middle(xx, yy)
    else:
        self.set_caret(xx, yy)

    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.grab_focus_cb"><code class="name flex">
<span>def <span class="ident">grab_focus_cb</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grab_focus_cb(self, widget):
    #print( &#34;grab_focus_cb&#34;, widget)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.hexview"><code class="name flex">
<span>def <span class="ident">hexview</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hexview(self, flag):
    self.hex = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.hscroll_cb"><code class="name flex">
<span>def <span class="ident">hscroll_cb</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hscroll_cb(self, widget):
    #print( &#34;hscroll_cb&#34;, widget.get_value())

    # Skip one callback
    if self.honeshot:
        self.honeshot = False; return
    xidx = int(widget.get_value())

    #print( &#34;hscroll_cb ok&#34;, widget.get_value())
    self.set_caret(xidx, self.ypos + self.caret[1])
    self.invalidate()

    #print( &#34;vscroll_cb&#34;, widget.get_value())
    # Skip one callback
    if self.oneshot:
        self.oneshot = False; return
    #print( &#34;vscroll_cb ok&#34;, widget.get_value())
    yidx = int(widget.get_value())
    self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.idle_queue"><code class="name flex">
<span>def <span class="ident">idle_queue</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def idle_queue(func):
    self.queue.append(func)
    #print( queue)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.inserttext"><code class="name flex">
<span>def <span class="ident">inserttext</span></span>(<span>self, xtext)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert text at current point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inserttext(self, xtext):

    &#39;&#39;&#39; Insert text at current point &#39;&#39;&#39;

    newtxt = xtext.split(&#34;\n&#34;) + []
    ycoord = self.ypos + self.caret[1]
    #ycoord = self.ypos + y

    xidx = self.caret[0] + self.xpos;
    yidx = self.caret[1] + self.ypos

    tmptext = self.text[:ycoord]
    self.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
    for aa in newtxt:
        self.undoarr.append((xidx, yidx, pedundo.ADDED  \
            + pedundo.CONTFLAG, aa))
        yidx += 1
        tmptext.append(aa)
    tmptext += self.text[ycoord:]
    self.text = tmptext

    self.changed = True
    self.set_caret(self.xpos + self.caret[0],
                self.ypos + self.caret[1] + len(newtxt))

    mlen = self.calc_maxline()

    # Set up scroll bars
    self.set_maxlinelen(mlen, False)
    #self.set_maxlines(len(self.text), False)
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.intersect"><code class="name flex">
<span>def <span class="ident">intersect</span></span>(<span>self, xx, yy, xx2, yy2, event)</span>
</code></dt>
<dd>
<div class="desc"><p>intersect(self, area:Gdk.Rectangle) -&gt; bool, intersection:Gdk.Rectangle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect(self, xx, yy, xx2, yy2, event):
    # Does X intersect?
    if event.x &gt; xx and event.x &lt; xx2:
        #print( &#34;x inter&#34;, xaa, lcc)
        # Does Y intersect?
        if event.y &gt; yy and event.y &lt; yy2:
            return True
    return False</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.inval_line"><code class="name flex">
<span>def <span class="ident">inval_line</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inval_line(self):
    rect = Gdk.Rectangle()
    xx = self.caret[0] * self.cxx
    yy = self.caret[1] * self.cyy
    ww = self.get_width()
    hh = self.cyy
    #self.invalidate(rect)
    xx = 0
    self.queue_draw_area(xx, yy, ww, hh)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.invalidate"><code class="name flex">
<span>def <span class="ident">invalidate</span></span>(<span>self, rect=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invalidate(self, rect = None):
    #print( &#34;Invalidate:&#34;, rect)
    if rect == None:
        self.queue_draw()
    else:
        self.queue_draw_area(rect.x, rect.y,
                        rect.width, rect.height)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.is_c_like"><code class="name flex">
<span>def <span class="ident">is_c_like</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if 'C' like file
This is fooled by non extension items; not a big deal
colors may get turned on &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_c_like(self):

    &#39;&#39;&#39; Return True if &#39;C&#39; like file
        This is fooled by non extension items; not a big deal
        colors may get turned on ...
    &#39;&#39;&#39;
    #print(&#34;c like&#34;, self.fname)
    for aa in c_like_exts:
        eee = self.fname[-(len(aa)):]
        #print(&#34;eee&#34;, eee, aa)
        if aa == eee:
            #print(&#34;C Match&#34;, self.fname)
            return True
    return False</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.iterdocs"><code class="name flex">
<span>def <span class="ident">iterdocs</span></span>(<span>self, callb, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterdocs(self, callb, arg):
    nn = self.notebook.get_n_pages(); cnt = 0
    while True:
        if cnt &gt;= nn: break
        ppp = self.notebook.get_nth_page(cnt)
        #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
        callb(ppp.area, arg)
        cnt += 1</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.loadbuff"><code class="name flex">
<span>def <span class="ident">loadbuff</span></span>(<span>self, arrx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadbuff(self, arrx):
    self.text = arrx
    usleep(1)
    # Set up scroll bars and other parameters
    mlen = self.calc_maxline()
    self.set_maxlinelen(mlen, False)
    self.set_maxlines(len(self.text), False)
    self.changed = True</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.loadfile"><code class="name flex">
<span>def <span class="ident">loadfile</span></span>(<span>self, filename, create=False, reload=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load file into this buffer, return False on failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadfile(self, filename, create = False, reload = True):

    &#39;&#39;&#39; Load file into this buffer, return False on failure &#39;&#39;&#39;

    if not self.second:
        if pedconfig.conf.verbose &gt; 1:
            print(&#34;Loading file&#34;, filename)

    if not reload:
        # Is it already loaded? ... activate
        nn = self.notebook.get_n_pages()
        fname2 = os.path.realpath(filename)
        for aa in range(nn):
            vcurr = self.notebook.get_nth_page(aa)
            if vcurr.area.fname == fname2:
                if pedconfig.conf.verbose:
                    print(&#34;Already open &#39;&#34;+ fname2 + &#34;&#39;&#34;)
                self.mained.update_statusbar(&#34;Already open, activating &#39;{0:s}&#39;&#34;.format(fname2))
                vcurr = self.notebook.set_current_page(aa)
                vcurr = self.notebook.get_nth_page(aa)
                self.mained.mywin.set_focus(vcurr.vbox.area)
                return

    if not self.second:
        self.mained.oh.add(filename)

    self.fname = filename
    self.ext = os.path.splitext(self.fname)[1].lower()

    try:
        self.stat = os.stat(self.fname)
    except:
        pass

    #pedync.message(&#34;\n   open / read file:  \n\n&#34;
    #                      &#34;      %s&#34; % self.fname)

    #print(&#34;stat&#34;, self.stat.st_mtime)
    self.start_time = time.time()
    if self.fname == &#34;&#34;:
        strx = &#34;Must specify file name.&#34;
        print(strx)
        self.mained.update_statusbar(strx)
        return False
    try:
        self.text = readfile(self.fname)
    except:
        errr = &#34;Cannot read file &#39;&#34; + self.fname + &#34;&#39;&#34; #, sys.exc_info()
        if pedconfig.conf.verbose:
            print(errr, sys.exc_info())

        #pedync.message(&#34;\n   Cannot open / read file:  \n\n&#34;
        #                  &#34;      %s&#34; % self.fname)

        print(errr)
        self.mained.update_statusbar(errr)
        usleep(10)
        return False

    #self.ularr.append((10 ,10, 20))
    mlen = self.calc_maxline()

    # Set up scroll bars
    self.set_maxlinelen(mlen, False)
    self.set_maxlines(len(self.text), False)

    # Increment and wrap backup
    if not self.second:
        hhh = hash_name(self.fname)
        self.currback  =  pedconfig.conf.sql.get_int(hhh + &#34;/bak&#34;)
        self.currback += 1
        if self.currback &gt;= 9:
            self.currback = 1
        pedconfig.conf.sql.put(hhh + &#34;/bak&#34;, self.currback)

    # File and backup related
    if not self.second:
        self.loadundo()
        self.loadparms()
        self.saveorg()
        self.savebackup()

        # Add to accounting:
        logentry(&#34;Opened File&#34;, self.start_time, self.fname)

    # Propagate main wndow ref
    pedmenu.mained = self.mained

    self.set_nocol()

    try:
        os.chdir(os.path.dirname(self.fname))
    except:
        print(&#34;Cannot change dir to file&#39;s cwd&#34;, sys.exc_info())

    # Let the system breed
    self.invalidate()
    usleep(10)

    # Color ON?
    self.set_nocol()

    # Are most of them read only?
    if not self.second:
        ro = 0
        nn = self.notebook.get_n_pages()
        for aa in range(nn):
            vcurr = self.notebook.get_nth_page(aa)
            #print(&#34;listing&#34;,  vcurr.area.fname, vcurr.area.readonly)
            if vcurr.area.readonly:
                ro += 1
        #print(&#34;nn&#34;, nn, &#34;ro count&#34;, ro)
        if ro &gt; nn // 2:
            self.readonly = True

    return True</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.loadmacro"><code class="name flex">
<span>def <span class="ident">loadmacro</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadmacro(self):
    #print( &#34;Loadmacro&#34;)

    xfile = pedconfig.conf.config_dir + &#34;/macros/&#34;
    old = os.getcwd()
    try:
        os.chdir(os.path.dirname(xfile))
    except:
        print(&#34;No macros directory&#34;, sys.exc_info())

    but =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Load Macro&#34;, Gtk.ButtonsType.OK
    fc = Gtk.FileChooserDialog(&#34;Load Macro&#34;, None, Gtk.FileChooserAction.OPEN, \
        but)

    fc.set_current_folder(xfile)
    #fc.set_current_folder(old)
    fc.set_default_response(Gtk.ButtonsType.OK)
    fc.connect(&#34;response&#34;, self.done_mac_open_fc, old)
    fc.run()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.loadparms"><code class="name flex">
<span>def <span class="ident">loadparms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadparms(self):
    hhh = hash_name(self.fname)

    self.startxxx  =  pedconfig.conf.sql.get_int(hhh + &#34;/xx&#34;)
    self.startyyy  =  pedconfig.conf.sql.get_int(hhh + &#34;/yy&#34;)
    #print(&#34;got cursor pos:&#34;, self.fname, self.startxxx, self.startyyy)
    # Note: we set cursor on first focus</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.loadundo"><code class="name flex">
<span>def <span class="ident">loadundo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadundo(self):
    hhh = hash_name(self.fname) + &#34;.udo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    try:
        fh = open(xfile, &#34;rb&#34;)
        try:
            self.undoarr = pickle.load(fh)
        except:
            pass
        fh.close()
    except:
        pass
        # Ignore it, not all files will have undo
        #print( &#34;Cannot load undo file&#34;, xfile)
    self.initial_undo_size = len(self.undoarr)

    hhh = hash_name(self.fname) + &#34;.rdo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    try:
        fh = open(xfile, &#34;rb&#34;)
        try:
            self.redoarr = pickle.load(fh)
        except:
            pass
        fh.close()
    except:
        pass
        # Ignore it, not all files will have redo
        #print( &#34;Cannot load redo file&#34;, xfile)
    self.initial_redo_size = len(self.redoarr)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.locate"><code class="name flex">
<span>def <span class="ident">locate</span></span>(<span>self, xstr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def locate(self, xstr):
    #print( &#34;locate &#39;&#34; + xstr +&#34;&#39;&#34;)
    cnt = 0; cnt2 = 0; idx = 0; found = 0
    for line in self.text:
        if xstr == line:
            self.gotoxy(idx, cnt, len(xstr), True)
            found = 1
            break
        cnt += 1
    if not found:
        xstr2 = xstr.lstrip().replace(&#34;\t&#34;, &#34; &#34;)
        for line2 in self.text:
            idx2 = line2.find(xstr2)
            if idx2 &gt;= 0:
                self.gotoxy(idx2, cnt2, len(xstr2), True)
                break
            cnt2 += 1</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.menuitem_response"><code class="name flex">
<span>def <span class="ident">menuitem_response</span></span>(<span>self, widget, stringx, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def menuitem_response(self, widget, stringx, arg):
    #print( &#34;menuitem response &#39;%s&#39;&#34; % stringx)
    #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)

    # See if Capitalized or UPPERCASE :
    if self.spellstr[0] in string.ascii_uppercase:
        stringx = stringx.capitalize()

    if self.spellstr.isupper():
        stringx = stringx.upper()

    pedconfig.conf.keyh.acth.clip_cb(None, stringx, self, False)

    self.fired += 1
    self.run_keytime()
    #self.mained.threads.submit_job(keytime, self, None)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.menuitem_response2"><code class="name flex">
<span>def <span class="ident">menuitem_response2</span></span>(<span>self, widget, stringx, arg)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def menuitem_response2(self, widget, stringx, arg):
    #print( &#34;menuitem response2 &#39;%s&#39;&#34; % stringx)
    #print( &#34;Original str &#39;%s&#39;&#34; % self.spellstr)
    disp2 = Gdk.Display()
    disp = disp2.get_default()
    clip = Gtk.Clipboard.get_default(disp)
    stringx = stringx.strip()
    clip.set_text(stringx, len(stringx))
    strs = &#34;Copied to clipboard &#39;{0:s}&#39;&#34;.format(stringx)
    self.mained.update_statusbar(strs, True)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.normsel"><code class="name flex">
<span>def <span class="ident">normsel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normsel(self):
    xssel = min(self.xsel, self.xsel2)
    xesel = max(self.xsel, self.xsel2)
    yssel = min(self.ysel, self.ysel2)
    yesel = max(self.ysel, self.ysel2)

    self.xsel  = xssel;  self.ysel  = yssel
    self.xsel2 = xesel;  self.ysel2 = yesel</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.on_drag_data_get"><code class="name flex">
<span>def <span class="ident">on_drag_data_get</span></span>(<span>self, widget, drag_context, data, info, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_drag_data_get(self, widget, drag_context, data, info, time):
    #print(&#34;Drag data get entry&#34;)
    if self.xsel == -1 or self.ysel == -1:
        return
    # Normalize
    xssel = min(self.xsel, self.xsel2)
    xesel = max(self.xsel, self.xsel2)
    yssel = min(self.ysel, self.ysel2)
    yesel = max(self.ysel, self.ysel2)

    cnt = yssel; cnt2 = 0; cumm = &#34;&#34;
    while True:
        if cnt &gt; yesel: break

        #self.pad_list(self, cnt)
        line = self.text[cnt]
        if self.colsel:
            frag = line[xssel:xesel]
        else :                                  # startsel - endsel
            if cnt == yssel and cnt == yesel:   # sel on the same line
                frag = line[xssel:xesel]
            elif cnt == yssel:                  # start line
                frag = line[xssel:]
            elif cnt == yesel:                  # end line
                frag = line[:xesel]
            else:
                frag = line[:]

        if cnt2: frag = &#34;\n&#34; + frag
        cumm += frag
        cnt += 1; cnt2 += 1

    data.set_text(cumm, -1)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.on_drag_data_received"><code class="name flex">
<span>def <span class="ident">on_drag_data_received</span></span>(<span>self, widget, drag_context, x, y, data, info, time)</span>
</code></dt>
<dd>
<div class="desc"><p>Drag and drop here</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_drag_data_received(self, widget, drag_context, x, y, data, info, time):

    &#39;&#39;&#39; Drag and drop here &#39;&#39;&#39;

    #print(&#34;Received data:&#34;, data, data.get_data_type(), x, y, info)
    if info == TARGET_ENTRY_TEXT:
        if str(data.get_data_type()) == &#34;text/plain&#34;:
            xtext = data.get_text()
            if xtext:
                #print(&#34;Received text: %s&#34; % xtext[:48])
                self.inserttext(xtext)

        if str(data.get_data_type()) == &#34;text/uri-list&#34;:
            xuris = data.get_uris()
            #print(&#34;got uri&#34;, xuris)
            uuu = &#34;file://&#34;
            for aa in xuris:
                if aa[:7] != uuu:
                    continue
                try:
                    xfname = aa[7:]
                    try:
                        xstat = os.stat(xfname)
                    except:
                        pass
                    print(&#34;drop xfname&#34;, xfname, xstat)
                    if xstat.st_size &gt; 100000:
                        pedync.message(&#34;\nDragged file is too big.\n&#34;
                            &#34;To open anyway, use the regular open function\n\n&#34;  )
                        continue

                    fp = open(xfname)
                    xtext = fp.read()
                    fp.close()
                    self.inserttext(xtext)
                except:
                    print(&#34;Cannot open dragged file.&#34;)
                    self.mained.update_statusbar(&#34;Cannot open dragged file. &#39;%s&#39;&#34; % xfname)


    elif info ==  TARGET_ENTRY_PIXBUF:
        pixbuf = data.get_pixbuf()
        width = pixbuf.get_width()
        height = pixbuf.get_height()
        print(&#34;Received pixbuf with width %spx and height %spx&#34; % (width, height))

    Gtk.drag_finish(drag_context, True, False, time)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.on_drag_drop"><code class="name flex">
<span>def <span class="ident">on_drag_drop</span></span>(<span>self, widget, context, xx, yy, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_drag_drop(self, widget, context, xx, yy, time):
    #print(&#34;xy&#34;, xx // self.cxx , yy // self.cyy);
    self.set_caret(self.xpos + xx // self.cxx, self.ypos + yy // self.cyy)
    widget.drag_get_data(context, context.list_targets()[-1], time)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.on_drag_motion"><code class="name flex">
<span>def <span class="ident">on_drag_motion</span></span>(<span>self, widgt, context, c, y, time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_drag_motion(self, widgt, context, c, y, time):
    Gdk.drag_status(context, Gdk.DragAction.COPY, time)
    return True</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.overwrite_done"><code class="name flex">
<span>def <span class="ident">overwrite_done</span></span>(<span>self, win, resp, fname, win2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overwrite_done(self, win, resp, fname, win2):
    #print( &#34;overwrite done&#34;, resp)
    if resp == Gtk.ResponseType.YES:
        self.fname = fname
        self.ext = os.path.splitext(self.fname)[1].lower()
        self.writeout()
        self.set_nocol()
        win2.destroy()
    win.destroy()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.pix2pos"><code class="name flex">
<span>def <span class="ident">pix2pos</span></span>(<span>self, xx, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pix2pos(self, xx, yy):
    return int(self.xpos + (xx-self.strip) / self.cxx), int(self.ypos + yy / self.cyy)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.pix2xpos"><code class="name flex">
<span>def <span class="ident">pix2xpos</span></span>(<span>self, xx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pix2xpos(self, xx):
    return int(self.xpos + (xx-self.strip) / self.cxx)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.pix2ypos"><code class="name flex">
<span>def <span class="ident">pix2ypos</span></span>(<span>self, yy)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pix2ypos(self, yy):
    return int(self.ypos + yy / self.cyy)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.poprclick"><code class="name flex">
<span>def <span class="ident">poprclick</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poprclick(self, widget, event):

    if self.nomenu: return

    #print (&#34;Making rclick&#34;)
    menu = self.build_menu(self, pedmenu.rclick_menu)
    menu.show_all()

    if event:
        menu.popup(None, None, None, None, event.button, event.time)
    else:
        event = Gdk.EventButton()
        menu.popup(None, None, None, None, event.button, event.time)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.poprclick2"><code class="name flex">
<span>def <span class="ident">poprclick2</span></span>(<span>self, widget, event, strx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poprclick2(self, widget, event, strx):
    #print (&#34;Making shift rclick2&#34;)
    if self.nomenu: return

    self.menu2 = Gtk.Menu()
    self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % strx, None))
    mi = self.create_menuitem(&#34;-------------&#34;, None)
    mi.set_sensitive(False)
    self.menu2.append(mi)
    strs = &#34;Creating class list for &#39;{0:s}&#39;&#34;.format(strx)
    self.mained.update_statusbar(strs)
    arr = pedstruct.suggest(self, strx)
    if len(arr) == 0:
        self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
    else:
        for bb in arr:
            self.menu2.append(self.create_menuitem(bb, self.menuitem_response2))

    self.menu2.popup(None, None, None, None, event.button, event.time)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.poprclick3"><code class="name flex">
<span>def <span class="ident">poprclick3</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def poprclick3(self, event):
    #print (&#34;Making shift rclick3&#34;)
    if self.nomenu: return

    got_src = 0; got_targ = 0

    nn = self.notebook.get_n_pages(); cnt = 0
    while True:
        if cnt &gt;= nn: break
        ppp = self.notebook.get_nth_page(cnt)
        #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
        if ppp.area.diffmode == 1:
            got_src = True
        if ppp.area.diffmode == 2:
            got_targ = True
        cnt += 1

    # Check if there is any:
    nn = self.notebook.get_n_pages(); cnt = 0
    while True:
        if cnt &gt;= nn: break
        ppp = self.notebook.get_nth_page(cnt)
        #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
        if ppp.area.diffmode == 1:
            got_src = True
        if ppp.area.diffmode == 2:
            got_targ = True
        cnt += 1

    self.menu3 = Gtk.Menu()
    if not got_src:
        self.menu3.append(self.create_menuitem(&#34;Set as Diff Source&#34;, self.set_diffs, 1))
    if not got_targ:
        self.menu3.append(self.create_menuitem(&#34;Set as Diff Target&#34;, self.set_diffs, 2))
    else:
        self.menu3.append(self.create_menuitem(&#34;Re-Diff Buffers&#34;,  self.re_diff, 0))

    self.menu3.append(self.create_menuitem(&#34;Stop Diffing&#34;,  self.set_diffs, 0))
    self.menu3.append(self.create_menuitem(&#34;- - - - - - - - - - - - - - - &#34;,  None, 0))
    self.menu3.append(self.create_menuitem(&#34;Show Buffer in Sidetab&#34;,  self.set_sidetab, 0))
    self.menu3.append(self.create_menuitem(&#34;Hide Sidetab&#34;,  self.set_sidetab, 1))

    #mi = self.create_menuitem(&#34;-------------&#34;, None)
    #mi.set_sensitive(False); self.menu3.append(mi)
    #self.menu3.append(self.create_menuitem(&#34;Toggle Read Only&#34;,  self.set_ro, 0))

    self.menu3.popup(None, None, None, None, event.button, event.time)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.popspell"><code class="name flex">
<span>def <span class="ident">popspell</span></span>(<span>self, widget, event, xstr)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popspell(self, widget, event, xstr):
    # Create a new menu-item with a name...
    self.menu2 = Gtk.Menu()
    self.menu2.append(self.create_menuitem(&#34;Checking &#39;%s&#39;&#34; % xstr, None))
    self.menu2.append(self.create_menuitem(&#34;Add to Dict&#34;, self.addict, xstr))

    mi = self.create_menuitem(&#34;-------------&#34;, None)
    mi.set_sensitive(False)
    self.menu2.append(mi)

    strs = &#34;Creating suggestion list for &#39;{0:s}&#39;&#34;.format(self.spellstr)
    self.mained.update_statusbar(strs)
    arr = pedspell.suggest(self, xstr)

    if len(arr) == 0:
        self.menu2.append(self.create_menuitem(&#34;No Matches&#34;, None))
    else:
        for aa, bb in arr:
            self.menu2.append(self.create_menuitem
                    (bb, self.menuitem_response))

    self.menu2.popup(None, None, None, None, event.button, event.time)
    #self.mained.update_statusbar(&#34;Done menu popup.&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.prompt_save"><code class="name flex">
<span>def <span class="ident">prompt_save</span></span>(<span>self, askname=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prompt_save(self, askname = True):

    # Always save params
    self.saveparms()

    if not self.changed:
        #print &#34;not changed&#34;, self.fname
        return False

    msg = &#34;\nWould you like to save:\n\n  \&#34;%s\&#34; \n&#34; % self.fname
    rp = pedync.yes_no_cancel(&#34;pyedpro: Save File ?&#34;, msg)

    if rp == Gtk.ResponseType.YES:
        if askname:
            self.file_dlg(rp)
        else:
            self.save()
    elif rp == Gtk.ResponseType.NO:
        pass
    elif  rp == Gtk.ResponseType.CANCEL:
        return True
    else:
        print(&#34;warning: invalid response from dialog&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.rclick_action_doc"><code class="name flex">
<span>def <span class="ident">rclick_action_doc</span></span>(<span>self, action, sss, ttt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rclick_action_doc(self, action, sss, ttt):

    if pedconfig.conf.verbose:
        print( &#34;rclick_action_doc&#34;, sss, ttt)

    if ttt == 1:
        self.mained.newfile()
    elif ttt == 3:
        self.mained.open()
    elif ttt == 4:
        self.mained.save()
    elif ttt == 5:
        self.mained.save(True)
    elif ttt == 7:
        self.mained.copy()
    elif ttt == 8:
        self.mained.cut()
    elif ttt == 9:
        self.mained.paste()
    elif ttt == 11:
        self.toggle_ro()
    elif ttt == 13:
        print(&#34;menu exit&#34;)
        self.mained.activate_exit()
    elif ttt == 14:
         pedconfig.conf.pedwin.start_term()
    elif ttt == 15:
        self.start_edit(self.fname)
    elif ttt == 16:
        self.mained.tts()
    elif ttt == 17:
        pedmisc.exec_test(self, &#34;rc&#34;)
    elif ttt == 18:
        self.start_external([&#34;libreoffice&#34;, &#34;--writer&#34;],
                                    [&#34;libreoffice&#34;, &#34;--writer&#34;])
    elif ttt == 19:
        self.start_m4filter()
    elif ttt == 20:
        self.start_mdfilter()
    elif ttt == 21:
        self.start_browser(self.fname)
    elif ttt == 22:
        self.start_htmlwin(self.fname)
    elif ttt == 23:
        self.start_htmlstr()
    elif ttt == 24:
        self.start_external([&#34;thunar&#34;, &#34;.&#34;], # Caja ?
                                    [&#34;explorer&#34;, &#34;&#34;])
    elif ttt == 25:
        self.rescan()
    elif ttt == 26:
        self.find(self)
    elif ttt == 27:
        #print(&#34;Alt-Y&#34;)
        self.check_syntax()
    else:
        print(&#34;peddoc: Invalid menu item selected&#34;, ttt)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.re_diff"><code class="name flex">
<span>def <span class="ident">re_diff</span></span>(<span>self, arg1, arg2, arg3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def re_diff(self, arg1, arg2, arg3):
    got_src = 0; got_targ = 0; action_page = 0;
    src = &#34;&#34;; targ = &#34;&#34;
    srctxt = [] ;  targtxt = []
    action_tab = None

    # See if diff complete, put it in motion
    nn = self.notebook.get_n_pages(); cnt = 0
    while True:
        if cnt &gt;= nn: break
        ppp = self.notebook.get_nth_page(cnt)
        #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
        if ppp.area.diffmode == 1:
            got_src = True
            src = os.path.basename(ppp.area.fname)
            srctxt = ppp.area.text

        if ppp.area.diffmode == 2:
            got_targ = True
            targ = os.path.basename(ppp.area.fname)
            targtxt = ppp.area.text
            action_page = cnt
            action_tab = ppp

        if ppp.area.diffmode == 1:
            got_src = True
        cnt += 1

    if got_src and got_targ:
        www = self.mained.get_width()
        if self.mained.hpaned3.get_position() &gt; www - 20:
            self.mained.hpaned3.set_position(www - www / 3)

        self.mained.update_statusbar(    \
                    &#34;Diff re-started.  Source: &#39;%s&#39; Target: &#39;%s&#39;&#34; % (src, targ))

        self.notebook.set_current_page(action_page)
        action_tab.area.diffx(srctxt, targtxt)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.rescan"><code class="name flex">
<span>def <span class="ident">rescan</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rescan(self):
    global last_scanned
    last_scanned = &#34;&#34;
    run_async_time(self, 0)
    self.mained.update_statusbar(&#34;Started rescan ...&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.run_keytime"><code class="name flex">
<span>def <span class="ident">run_keytime</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_keytime(self):
    global last_scanned
    last_scanned = &#34;&#34;
    if not self.mained.mac:
        GLib.timeout_add(300, keytime, self, 0)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):

    #print (&#34;Saving&#34;, self.fname)
    # Always save params
    self.saveparms()
    strx = &#34;&#34;
    if not self.changed:
        strx = &#34;File is not modified.&#34;
        self.mained.update_statusbar(strx)
        return

    # Is this file named &#39;untitled&#39;?
    base, ext =  os.path.splitext(pedconfig.conf.UNTITLED)
    base1 = os.path.basename(self.fname)
    base2, ext2 =  os.path.splitext(base1)
    if base2[:len(base)] == base:
        self.file_dlg(Gtk.ResponseType.YES)
    else:
        bn = os.path.basename(self.fname)
        err = self.writeout()
        if  err[0]:
            strx = &#34;Saved &#39;{0:s}&#39;&#34;.format(self.fname)
        else:
            #strx = &#34;Not Saved &#39;{0:s}&#39; {1:s}&#34;.format(bn, err[1])
            strx = &#34;Not Saved &#34;

    if pedconfig.conf.verbose:
        print(strx)
    self.mained.update_statusbar(strx)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.saveas"><code class="name flex">
<span>def <span class="ident">saveas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveas(self):
    self.file_dlg(Gtk.ResponseType.YES)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.savebackup"><code class="name flex">
<span>def <span class="ident">savebackup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savebackup(self):

    hhh = hash_name(self.fname)
    self.startxxx  =  pedconfig.conf.sql.get_int(hhh + &#34;/xx&#34;)

    try:
        xfile = pedconfig.conf.data_dir + os.sep + hhh + &#34;_&#34; + str(self.currback) + &#34;.bak&#34;
        if pedconfig.conf.verbose &gt; 2:
            print(&#34;Saving backup: &#34;, xfile)

        try:
            writefile(xfile, self.text, &#34;\n&#34;)
        except:
            print(&#34;Cannot create backup file &#34; + xfile, sys.exc_info())
    except:
        print(&#34;Cannot back up &#34;, sys.exc_info())</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.savemacro"><code class="name flex">
<span>def <span class="ident">savemacro</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def savemacro(self):

    #print( &#34;Savemacro&#34;)

    if not self.recarr:
        print(&#34;Cannot save, nothing recorded yet.&#34;)
        pedync.message(&#34;\n   Cannot save macro: nothing recorder yet.  \n\n&#34;)
        return

    fname = &#34;untitled.mac&#34;
    xdir = pedconfig.conf.config_dir + &#34;/macros/&#34;
    xfile = pedconfig.conf.config_dir + &#34;/macros/&#34; + fname
    old = os.getcwd()
    try:
        os.chdir(os.path.dirname(xfile))
    except:
        print(&#34;No macros directory&#34;, sys.exc_info())

    warnings.simplefilter(&#34;ignore&#34;)
    buts =   &#34;Cancel&#34;, Gtk.ButtonsType.CANCEL, &#34;Save Macro&#34;, Gtk.ButtonsType.OK
    fc = Gtk.FileChooserDialog(&#34;Save Macro&#34;, None, Gtk.FileChooserAction.SAVE, \
        buts)

    fc.set_current_folder(xdir)
    fc.set_current_name(os.path.basename(xfile))
    fc.set_default_response(Gtk.ButtonsType.OK)
    fc.connect(&#34;response&#34;, self.done_mac_fc, old)
    fc.run()
    warnings.simplefilter(&#34;default&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.saveorg"><code class="name flex">
<span>def <span class="ident">saveorg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveorg(self):
    hhh = hash_name(self.fname) + &#34;.org&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    if not os.path.isfile(xfile):
        err =  writefile(xfile, self.text, &#34;\n&#34;)
        if not err[0]:
            print(&#34;Cannot create (org) backup file&#34;, xfile, sys.exc_info())
        # Make a log entry
        logfile = pedconfig.conf.log_dir + os.sep + &#34;backup.log&#34;
        xentry = &#34;Org &#34; + time.ctime() + &#34; &#34; + \
            self.fname + &#34; &#34; + os.path.basename(xfile)
        writefile(logfile, (xentry, &#34;&#34;), &#34;\n&#34;, &#34;a+&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.saveparms"><code class="name flex">
<span>def <span class="ident">saveparms</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  saveparms(self):
    hhh = hash_name(self.fname)
    pedconfig.conf.sql.put(hhh + &#34;/xx&#34;, self.xpos + self.caret[0])
    pedconfig.conf.sql.put(hhh + &#34;/yy&#34;, self.ypos + self.caret[1])
    pedconfig.conf.sql.put(hhh + &#34;/fname&#34;, self.fname)

    if self.tts:
        self.tts.haltspeak = True

    #print  &#34;saveparm&#34;, time.clock() - got_clock</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.saveundo"><code class="name flex">
<span>def <span class="ident">saveundo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saveundo(self):
    hhh = hash_name(self.fname) + &#34;.udo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    try:
        fh = open(xfile, &#34;wb&#34;)
        pickle.dump(self.undoarr, fh)
        fh.close()
    except:
        print(&#34;Cannot save undo file&#34;, sys.exc_info())
        put_exception(&#34;undo&#34;)


    hhh = hash_name(self.fname) + &#34;.rdo&#34;
    xfile = pedconfig.conf.data_dir + os.sep + hhh
    try:
        fh = open(xfile, &#34;wb&#34;)
        pickle.dump(self.redoarr, fh)
        fh.close()
    except:
        print(&#34;Cannot save redo file&#34;, sys.exc_info())</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.scroll_event"><code class="name flex">
<span>def <span class="ident">scroll_event</span></span>(<span>self, widget, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scroll_event(self, widget, event):
    #print( &#34;scroll_event&#34;, event, event.direction)
    xidx = self.xpos + self.caret[0]
    yidx = self.ypos + self.caret[1]
    if event.direction == Gdk.ScrollDirection.SMOOTH:
        flag, directx, directy = event.get_scroll_deltas()
        if event.state &amp; Gdk.ModifierType.CONTROL_MASK:
            yidx += 10 * int(directy)
        elif event.state &amp; Gdk.ModifierType.SHIFT_MASK:
            yidx += 5 * int(directy)
        else:
            yidx += int(directy)
    else:
        #print( &#34;type&#34;, type(event.type))
        #print(&#34;truth&#34;, isinstance(event.type, Gdk.EventType))
        if event.direction == Gdk.ScrollDirection.UP:
            yidx -= int(self.pgup / 2)
        else:
            yidx += int(self.pgup / 2)

    self.set_caret(xidx, yidx)
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, srctxt, regex, boolcase, boolregex)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search(self, srctxt, regex, boolcase, boolregex):

    # Remember old settings:
    self.srctxt = srctxt;       self.regex = regex
    self.boolcase = boolcase;   self.boolregex = boolregex
    self.src_changed = False

    self.accum = []

    curr  = self.caret[1] + self.ypos
    currx = self.caret[0] + self.xpos

    was = -1; cnt = 0; cnt2 = 0
    before = 0; after = 0
    marked = False

    for line in self.text:
        # Search one line for multiple matches
        mmm = src_line(line, cnt, srctxt, regex, boolcase, boolregex)

        # Add marker to current lin
        if cnt == curr:
            if not marked:
                linex =  str(currx) + &#34;:&#34;  + str(cnt) +\
                     &#34;:&#34; + str(0) + &#34; &#34; +\
                         &#34;---- current cursor position ----&#34;
                self.accum.append(linex)
                marked = True

        # Mark the next match for the display
        if cnt &gt; curr and was == -1:
            was = cnt2
        if  mmm:
            #print(&#34;mmm&#34;, mmm);

            # Multiple counts may be there
            for sss in mmm:
                cnt2 += 1
                # Mark the counters
                if cnt &lt;= curr:
                    before += 1
                else:
                    after += 1
                self.accum.append(sss)

        if cnt % 100 == 0:
            self.mained.update_statusbar(\
                        &#34;Searching at %d&#34; % cnt, True)
            usleep(1)
        cnt += 1

    #if not marked:
    #    self.accum.append(&#34; ---- current cursor position ---- &#34;)
    #    marked = True

    return was, cnt2, before, after</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.search_again"><code class="name flex">
<span>def <span class="ident">search_again</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def search_again(self):
    if len(self.accum) == 0:
        return

    if self.src_changed:
        self.search(self.srctxt, self.regex, self.boolcase, self.boolregex)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_caret"><code class="name flex">
<span>def <span class="ident">set_caret</span></span>(<span>self, xx, yy, ignore=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Goto position, put caret (cursor) back to view, [vh]scrap
distance from ends. This function was a difficult to write. :-{
Note the trick with comparing old cursor pos for a hint on scroll
direction.
xx, yy - absolute position in the text buffer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_caret(self, xx, yy, ignore = False):

    &#39;&#39;&#39; Goto position, put caret (cursor) back to view, [vh]scrap
        distance from ends. This function was a difficult to write. :-{
        Note the trick with comparing old cursor pos for a hint on scroll
        direction.
        xx, yy - absolute position in the text buffer
    &#39;&#39;&#39;

    if self.caretshot:
        self.caretshot = False; return
    self.caretshot = ignore

    #print( &#34;set_caret&#34;, xx, yy)
    xx = int(xx); yy = int(yy)

    # Needs scroll?
    need_inval = False
    cww = self.get_width_char()
    chh = self.get_height_char()
    xlen = len(self.text)

    # ----------------------------------------------------------------
    # Put it back in view yyy:

    off = chh - self.vscgap
    if yy - self.ypos &gt; off:
        #print( &#34;Scroll from caret down&#34;)
        if yy &gt; self.ypos + self.caret[1]:
            #print( &#34;move d&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
            self.ypos = int(yy - off)
            need_inval = True
            # Force new spell check
            self.fired += 1
            self.run_keytime()
            #self.mained.threads.submit_job(keytime, self, None)

    if yy - self.ypos &lt; self.vscgap and self.ypos:
        #print( &#34;Scroll from caret up&#34;)
        if yy &lt; self.ypos + self.caret[1]:
            #print( &#34;move u&#34;, &#34;ypos&#34;, self.ypos, &#34;yy&#34;, yy)
            self.ypos = int(yy - self.vscgap)
            self.ypos = int(max(self.ypos, 0))
            need_inval = True
            # Force new spell check
            self.fired += 1
            self.run_keytime()
            #self.mained.threads.submit_job(keytime, self, None)

    yy -= self.ypos
    if self.ypos &lt; 0: self.ypos = 0

    # ----------------------------------------------------------------
    # Put it back in view xxx:

    xoff = cww - self.hscgap - self.strip / self.cxx
    if  xx - self.xpos  &gt; xoff:
        #print( &#34;Scroll from caret right&#34;, &#34;xx&#34;, xx, &#34;xpos&#34;, self.xpos)
        if self.xpos + self.caret[0] &lt; xx:
            #print( &#34;moved r&#34;,  xx, self.caret[0], self.xpos)
            self.xpos =  int(xx - xoff)
            self.xpos = int(max(self.xpos, 0))
            need_inval = True

    if  xx - self.xpos &lt;  self.hscgap:
        #print( &#34;Scroll from caret left &#34;, xx, self.xpos)
        if self.xpos + self.caret[0] &gt; xx:
            #print( &#34;moved l&#34;, &#34;xx&#34;, xx, &#34;caret&#34;, self.caret[0], &#34;xpos&#34;, self.xpos)
            self.xpos = int(xx - self.hscgap)
            self.xpos = int(max(self.xpos, 0))
            need_inval = True

    xx -= self.xpos
    if self.xpos &lt; 0: self.xpos = 0

    oldx = self.caret[0] * self.cxx
    oldy = self.caret[1] * self.cyy

    # Cheat - invalidate all if tab is involved at old line
    try:
        line = self.text[oldy]
    except:
        line = &#34;&#34;; need_inval = True
    if line.find(&#34;\t&#34;) &gt;= 0:
        need_inval = True

    self.caret[0] = xx; self.caret[1] = yy

    # Low limit
    if self.caret[0] &lt; 0: self.caret[0] = 0
    if self.caret[1] &lt; 0: self.caret[1] = 0

    wxx = self.caret[0] * self.cxx
    wyy = self.caret[1] * self.cyy

    # Cheat - invalidate all if tab is involoved
    try:
        line = self.text[self.ypos + self.caret[1]]
    except:
        line = &#34;&#34;; need_inval = True
    if line.find(&#34;\t&#34;) &gt;= 0:
        need_inval = True

    # Optimize cursor movement invalidation
    &#39;&#39;&#39;if  not need_inval :
        rect = Gdk.Rectangle(wxx, wyy, self.cxx * self.cxx /2, self.cyy + 1)
        self.invalidate(rect)

        rect = Gdk.Rectangle(oldx, oldy, self.cxx + self.cxx /2 , self.cyy + 1)
        self.invalidate(rect)
    &#39;&#39;&#39;
    #self.invalidate(None)

    # Update scroll bars, prevent them from sending scroll message:
    self.oneshot = True; self.vscroll.set_value(self.ypos)
    self.honeshot = True; self.hscroll.set_value(self.xpos)

    self.update_bar2()

    if  need_inval or self.bigcaret:
        self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_caret_middle"><code class="name flex">
<span>def <span class="ident">set_caret_middle</span></span>(<span>self, xx, yy, sel=None, quart=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Goto position, and place it to upper half / quarter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_caret_middle(self, xx, yy, sel = None, quart = 2):

    &#39;&#39;&#39;  Goto position, and place it to upper half / quarter &#39;&#39;&#39;

    xx = int(xx); yy = int(yy)

    # Needs scroll?
    #xxx, yyy = self.get_size()
    xlen = len(self.text)

    # Put it back in view:
    off = (self.get_height() / self.cyy) / quart
    if yy &gt; off:
        self.ypos = int(yy - off)
    else:
        self.ypos = 0

    self.set_caret(xx, yy)
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_changed"><code class="name flex">
<span>def <span class="ident">set_changed</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_changed(self, flag):
    old = self.changed
    self.changed = flag
    # Exec actions:
    if old != self.changed:
        #print( &#34;Setting changed on &#34;, self.fname)
        self.set_tablabel()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_diffs"><code class="name flex">
<span>def <span class="ident">set_diffs</span></span>(<span>self, arg1, arg2, arg3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_diffs(self, arg1, arg2, arg3):
    # reset all
    if arg3 == 0:
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            ppp.area.diffmode = 0
            ppp.area.set_tablabel()
            cnt += 1
        www = self.mained.get_width()
        self.mained.hpaned3.set_position(www - 10)

    else:
        self.diffmode = arg3
        self.set_tablabel()

        got_src = 0; got_targ = 0; action_page = 0;
        src = &#34;&#34;; targ = &#34;&#34;
        srctxt = [] ;  targtxt = []
        action_tab = None

        # See if diff complete, put it in motion
        nn = self.notebook.get_n_pages(); cnt = 0
        while True:
            if cnt &gt;= nn: break
            ppp = self.notebook.get_nth_page(cnt)
            #print(&#34;Area&#34;, ppp.area.fname, ppp.area.diffmode)
            if ppp.area.diffmode == 1:
                got_src = True
                src = os.path.basename(ppp.area.fname)
                srctxt = ppp.area.text

            if ppp.area.diffmode == 2:
                got_targ = True
                targ = os.path.basename(ppp.area.fname)
                targtxt = ppp.area.text
                action_page = cnt
                action_tab = ppp

            if ppp.area.diffmode == 1:
                got_src = True
            cnt += 1

        if got_src and got_targ:
            www = self.mained.get_width()
            if self.mained.hpaned3.get_position() &gt; www - 20:
                self.mained.hpaned3.set_position(www - www / 3)

            self.mained.update_statusbar(    \
                        &#34;Diff started.  Source: &#39;%s&#39; Target: &#39;%s&#39;&#34; % (src, targ))

            pppp = self.notebook3.get_nth_page(0)
            self.notebook3.set_tab_label(pppp,
                        self.mained.make_label(&#34;&#39;&#34; + src + &#34;&#39; --vs-- &#39;&#34; + targ + &#34;&#39;&#34;))
            self.notebook.set_current_page(action_page)
            action_tab.area.diffx(srctxt, targtxt)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_maxlinelen"><code class="name flex">
<span>def <span class="ident">set_maxlinelen</span></span>(<span>self, mlen=-1, ignore=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  set_maxlinelen(self, mlen = -1, ignore = True):
    if mlen == -1: self.calc_maxline()
    self.maxlinelen = mlen
    self.oneshot = ignore
    #value, lower, upper, step_increment, page_increment, page_size)
    #self.hadj.set_all(0, 0, self.maxlinelen * 2, 1, 15, 25)
    self.hadj.set_value(0)
    self.hadj.set_lower(0)
    self.hadj.set_upper(self.maxlinelen * 2)
    self.hadj.set_step_increment(1)
    self.hadj.set_page_increment(15)
    self.hadj.set_page_size(25)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_maxlines"><code class="name flex">
<span>def <span class="ident">set_maxlines</span></span>(<span>self, lines=0, ignore=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def  set_maxlines(self, lines = 0, ignore = True):
    self.maxlines = len(self.text) + self.get_height() / self.cyy + 25
    self.oneshot = ignore
    #self.vadj.set_all(0, 0, self.maxlines, 1, 15, 25)
    self.vadj.set_value(0)
    self.vadj.set_lower(0)
    self.vadj.set_upper(self.maxlines)
    self.vadj.set_step_increment(1)
    self.vadj.set_page_increment(15)
    self.vadj.set_page_size(25)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_nocol"><code class="name flex">
<span>def <span class="ident">set_nocol</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn off coloring if not python / c / sh / perl / header(s)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_nocol(self):

    &#39;&#39;&#39; Turn off coloring if not python / c / sh / perl / header(s) &#39;&#39;&#39;

    colflag = False
    ext = os.path.splitext(self.fname)[1].lower()
    for aa in pedconfig.conf.color_on:
        if ext == aa:
            colflag = True
            break
    self.colflag = colflag</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_ro"><code class="name flex">
<span>def <span class="ident">set_ro</span></span>(<span>self, arg1, arg2, arg3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_ro(self, arg1, arg2, arg3):
    print(&#34;set_ro&#34;)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_sidetab"><code class="name flex">
<span>def <span class="ident">set_sidetab</span></span>(<span>self, arg1, arg2, arg3)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_sidetab(self, arg1, arg2, arg3):
    # reset all
    #print(&#34;set_sidetab&#34;, arg1, arg2, arg3)
    www = self.mained.get_width()
    if arg3 == 0:
        if self.mained.hpaned3.get_position() &gt; www - 20:
            self.mained.hpaned3.set_position(www - www / 3)
        self.mained.update_statusbar(&#34;Sidetab buffer switched on.&#34;)
        self.mained.diffpane.area.loadbuff(self.text)
        self.mained.diffpane.area.fname = self.fname
        self.mained.diffpane.area.readonly = True

        usleep(100)
        self.gotoxy(self.xpos + self.caret[0], self.ypos + self.caret[1])
        self.mained.diffpane.area.xpos = self.xpos
        self.mained.diffpane.area.ypos = self.ypos
        self.mained.diffpane.area.gotoxy(
                     self.xpos + self.caret[0], self.ypos + self.caret[1])
        usleep(10)
        self.mained.diffpane.area.invalidate()
        pppp = self.notebook3.get_nth_page(0)
        lab = self.mained.make_label(&#34;ro &#34; + os.path.basename(self.fname))
        lab.set_tooltip_text(self.fname)
        self.notebook3.set_tab_label(pppp, lab)
    else:
        self.mained.hpaned3.set_position(www - 10)
        self.mained.update_statusbar(&#34;Sidetab buffer switched off.&#34;)
        pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.set_tablabel"><code class="name flex">
<span>def <span class="ident">set_tablabel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_tablabel(self):
    # Find me in tabs
    #print(&#34;Setting tablabels&#34;)
    nn = self.notebook.get_n_pages(); cnt = 0
    while True:
        if cnt &gt;= nn: break
        ppp = self.notebook.get_nth_page(cnt)
        if ppp.area == self:
            self._setlabel(ppp)
            break
        cnt += 1
        #usleep(10)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.setcol"><code class="name flex">
<span>def <span class="ident">setcol</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Customize your colors here</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setcol(self):

    &#39;&#39;&#39; Customize your colors here &#39;&#39;&#39;

    ccc = pedconfig.conf.sql.get_str(&#34;fgcolor&#34;)
    if ccc == &#34;&#34;:
        self.fgcolor  = pedcolor.str2float(FGCOLOR)
    else:
        self.fgcolor  = pedcolor.str2float(ccc)
    #print( &#34;fgcol&#34;, self.fgcolor, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;fgcolorro&#34;)
    if ccc == &#34;&#34;:
        self.fgcolorro  = pedcolor.str2float(FGCOLORRO)
    else:
        self.fgcolorro  = pedcolor.str2float(ccc)
    #print( &#34;fgcolro&#34;, self.fgcolorro, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;rbgcolor&#34;)
    if ccc == &#34;&#34;:
        self.rbgcolor = pedcolor.str2float(RBGCOLOR)
    else:
        self.rbgcolor = pedcolor.str2float(ccc)
    #print( &#34;rgbcolor&#34;, self.rbgcolor, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;bgcolor&#34;)
    if ccc == &#34;&#34;:
        self.bgcolor = pedcolor.str2float(BGCOLOR)
    else:
        self.bgcolor = pedcolor.str2float(ccc)
    #print( &#34;bgcolor&#34;, self.bgcolor, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;cbgcolor&#34;)
    if ccc == &#34;&#34;:
        self.cbgcolor = pedcolor.str2float(CBGCOLOR)
    else:
        self.cbgcolor = pedcolor.str2float(ccc)
    #print( &#34;cbgcolor&#34;, self.cbgcolor, ccc)

    self.stripcolor = pedcolor.str2float(STRIPCOLOR)

    ccc = pedconfig.conf.sql.get_str(&#34;kwcolor&#34;)
    if ccc == &#34;&#34;:
        self.kwcolor = pedcolor.str2float(KWCOLOR)
    else:
        self.kwcolor = pedcolor.str2float(ccc)
    #print( &#34;load kwcolor&#34;, self.kwcolor, ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;clcolor&#34;)
    if ccc == &#34;&#34;:
        self.clcolor = pedcolor.str2float(CLCOLOR)
    else:
        self.clcolor = pedcolor.str2float(ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;cocolor&#34;)
    if ccc == &#34;&#34;:
        self.cocolor = pedcolor.str2float(COCOLOR)
    else:
        self.cocolor = pedcolor.str2float(ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;stcolor&#34;)
    if ccc == &#34;&#34;:
        self.stcolor = pedcolor.str2float(STCOLOR)
    else:
        self.stcolor = pedcolor.str2float(ccc)

    ccc = pedconfig.conf.sql.get_str(&#34;carcolor&#34;)
    if ccc == &#34;&#34;:
        self.carcolor = pedcolor.str2float(CARCOLOR)
    else:
        self.carcolor = pedcolor.str2float(ccc)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.setfont"><code class="name flex">
<span>def <span class="ident">setfont</span></span>(<span>self, fam, size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setfont(self, fam, size):

    self.fd = Pango.FontDescription()

    self.fd.set_family(fam)
    # Will not wotk right on the MAC if simple set_size used
    self.fd.set_absolute_size(size * Pango.SCALE)

    self.pangolayout = self.create_pango_layout(&#34;a&#34;)
    self.pangolayout.set_font_description(self.fd)

    #print(&#34;pc&#34;, dir(PangoCairo))
    #print()
    #fm = Pango.FontMap()
    #ccc = Pango.create_context(fm)
    # Get Pango steps
    #self.cxx, self.cyy = self.pangolayout.get_pixel_size()
    (pr, lr) = self.pangolayout.get_extents()
    #self.printrect(&#34;pix&#34;, pr)
    #self.printrect(&#34;log&#34;, lr)

    self.cxx = lr.width / Pango.SCALE; self.cyy = lr.height / Pango.SCALE

    # Get Pango tabs
    self.tabarr = Pango.TabArray(80, False)
    #for aa in range(self.tabarr.get_size()):
    #    self.tabarr.set_tab(aa, Pango.TAB_LEFT, aa * TABSTOP * self.cxx * Pango.SCALE)

    self.pangolayout.set_tabs(self.tabarr)
    ts = self.pangolayout.get_tabs()

    &#39;&#39;&#39;if ts != None:
        al, self.tabstop = ts.get_tab(1)
    self.tabstop /= self.cxx * Pango.SCALE&#39;&#39;&#39;

    # Also set stip offset
    self.strip = 4 * self.cxx + 8</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.showcol"><code class="name flex">
<span>def <span class="ident">showcol</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showcol(self, flag):
    self.scol = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.showtab"><code class="name flex">
<span>def <span class="ident">showtab</span></span>(<span>self, flag)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showtab(self, flag):
    self.stab = flag
    self.scol = flag
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.size_alloc"><code class="name flex">
<span>def <span class="ident">size_alloc</span></span>(<span>self, widget, req)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_alloc(self, widget, req):
    #print( &#34;size_alloc&#34;, req)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.size_request"><code class="name flex">
<span>def <span class="ident">size_request</span></span>(<span>self, widget, req)</span>
</code></dt>
<dd>
<div class="desc"><p>size_request(self) -&gt; requisition:Gtk.Requisition</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def size_request(self, widget, req):
    #print( &#34;size_request&#34;, req)
    pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.toggle_ro"><code class="name flex">
<span>def <span class="ident">toggle_ro</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_ro(self):
    self.readonly = not self.readonly
    self.set_tablabel()
    arrx = [&#34;OFF&#34;, &#34;ON&#34;]
    self.mained.update_statusbar(&#34;Toggled read only to %s&#34; % arrx[self.readonly])</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.update_bar2"><code class="name flex">
<span>def <span class="ident">update_bar2</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_bar2(self):
    clip = pedconfig.conf.keyh.acth.currclip
    self.mained.update_statusbar2(self.caret[0] + self.xpos, \
            self.caret[1] + self.ypos, self.insert, len(self.text), clip,
                self.caps, self.scr, self.colsel)</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.vscroll_cb"><code class="name flex">
<span>def <span class="ident">vscroll_cb</span></span>(<span>self, widget)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vscroll_cb(self, widget):
    #print( &#34;vscroll_cb&#34;, widget.get_value())
    # Skip one callback
    if self.oneshot:
        self.oneshot = False; return
    #print( &#34;vscroll_cb ok&#34;, widget.get_value())
    yidx = int(widget.get_value())
    self.set_caret(self.xpos + self.caret[0], yidx + self.caret[1])
    self.invalidate()</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.walk_func"><code class="name flex">
<span>def <span class="ident">walk_func</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk_func(self):

    #print( &#34;walk func&#34;)

    # ts2 ---------------------------------------------------
    sumw2 = []
    if self.text:
        sline = self.caret[1] + int(self.ypos)
        sline = max(sline, 0); sline = min(sline, len(self.text))
        #print( &#34;Start point&#34;, sline, self.text[sline])

        # Walk back to last function
        if self.is_c_like():
            try:
                aa = 0; bb = 0
                regex = re.compile(ckeywords)
                for aa in range(sline - 1, 0, -1):
                    line = self.text[aa]
                    res = regex.search(line)
                    if res:
                        #print( &#34;start&#34;, line, res.start(), res.end())
                        sumw2.append(line)
                        break
                if aa &gt; 0:
                    for bb in range(aa + 1, len(self.text)):
                        line = self.text[bb]
                        res = regex.search(line)
                        if res:
                            #print( &#34;end&#34;, line, res.start(), res.end())
                            break

                    regex2 = re.compile(localkwords)
                    for cc in range(aa + 1, bb - 1):
                        line = self.text[cc]
                        res = regex2.search(line)
                        if res:
                            #print( &#34;match&#34;, line, res.start(), res.end())
                            sumw2.append(line)

            except:
                print(&#34;Exception in c func handler&#34;, sys.exc_info())
                pass
        if &#34;.bas&#34; in self.fname.lower():
            try:
                regex = re.compile(basekeywords)
                for line in win.text:
                    res = regex.search(line)
                    if res:
                        #print( res, res.start(), res.end())
                        sumw.append(line)
            except:
                print(&#34;Exception in bas func extraction handler&#34;, sys.exc_info())
                pass
        if &#34;.py&#34; in self.fname.lower():
            try:
                aa = 0; bb = 0
                regex = re.compile(&#34;class&#34;)
                for aa in range(int(sline) - 1, 0, -1):
                    line = self.text[aa]
                    res = regex.search(line)
                    if res:
                        #print( &#34;start&#34;, line, res.start(), res.end())
                        sumw2.append(line)
                        break

                regex = re.compile(pykeywords2)
                for aa in range(int(sline) - 1, 0, -1):
                    line = self.text[aa]
                    res = regex.search(line)
                    if res:
                        #print( &#34;start&#34;, line, res.start(), res.end())
                        sumw2.append(line)
                        break

                if aa &gt; 0:
                    for bb in range(aa + 1, len(self.text)):
                        line = self.text[bb]
                        res = regex.search(line)
                        if res:
                            #print( &#34;end&#34;, line, res.start(), res.end())
                            break

                    regex2 = re.compile(localpywords)
                    for cc in range(aa + 1, bb - 1):
                        line = self.text[cc]
                        res = regex2.search(line)
                        if res:
                            #print( &#34;match&#34;, line, res.start(), res.end())
                            sumw2.append(line)

            except:
                print(&#34;Exception in py func handler&#34;, sys.exc_info())
                raise
                pass
        else:
            pass

        # Always show todo
        got_todo = 0
        for line in self.text:
            if &#34;TODO&#34; in line:
                if not got_todo:
                    got_todo = 1
                    sumw2.append(&#34;----------- TODO List ----------&#34;)
                sumw2.append(line)

    try:
        self.mained.update_treestore2(sumw2)
    except:
        # This is normal, ignore it
        print(&#34;walk2&#34;, sys.exc_info())
        pass</code></pre>
</details>
</dd>
<dt id="peddoc.pedDoc.writeout"><code class="name flex">
<span>def <span class="ident">writeout</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The actual savefile routine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeout(self):

    &#39;&#39;&#39; The actual savefile routine &#39;&#39;&#39;

    if pedconfig.conf.verbose:
        print(&#34;Saving &#39;&#34;+ self.fname + &#34;&#39;&#34;)

    if os.access(self.fname, os.F_OK):
        #wasread = os.access(self.fname, os.R_OK)
        #if not wasread:
        #    print(&#34;Cannot read &#39;%s&#39;&#34; % self.fname,  sys.exc_info())
        #    self.mained.update_statusbar(&#34;Cannot read &#39;%s&#39;&#34; % self.fname)
        #    return

        waswrite = os.access(self.fname, os.W_OK)
        if not waswrite:
            print(&#34;Cannot write &#39;%s&#39;&#34; % self.fname,  sys.exc_info())
            self.mained.update_statusbar(&#34;Cannot write &#39;%s&#39;&#34; % self.fname)
            self.savebackup()

            pedync.message(&#34;\n   Cannot Save file:  \n\n&#34;
                              &#34;      &#39;%s&#39;&#34; % self.fname)
            return (False, &#34;Read only or Inaccessible file&#34;)

    err = writefile(self.fname, self.text, &#34;\n&#34;)
    #print(&#34;err writefile&#34;, err)
    if not err[0]:
        print(&#34;Cannot write &#39;%s&#39;&#34; % self.fname,  sys.exc_info())
        return

    self.set_changed(False)
    # Change access/ownership to group write
    try:
        ostat = os.stat(self.fname)
        os.chmod(self.fname, ostat.st_mode | stat.S_IWGRP)
    except:
        print(&#34;Cannot change group write on &#39;%s&#39;&#34; % self.fname,  sys.exc_info())

    self.saveundo();  self.saveparms(); self.set_tablabel()

    # Add to accounting:
    logentry(&#34;Wrote File&#34;, self.start_time, self.fname)

    # Update stat info
    self.stat = os.stat(self.fname)

    return err</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="peddoc.idle_callback" href="#peddoc.idle_callback">idle_callback</a></code></li>
<li><code><a title="peddoc.idle_callback2" href="#peddoc.idle_callback2">idle_callback2</a></code></li>
<li><code><a title="peddoc.keytime" href="#peddoc.keytime">keytime</a></code></li>
<li><code><a title="peddoc.run_async_time" href="#peddoc.run_async_time">run_async_time</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="peddoc.pedDoc" href="#peddoc.pedDoc">pedDoc</a></code></h4>
<ul class="">
<li><code><a title="peddoc.pedDoc.addict" href="#peddoc.pedDoc.addict">addict</a></code></li>
<li><code><a title="peddoc.pedDoc.area_button" href="#peddoc.pedDoc.area_button">area_button</a></code></li>
<li><code><a title="peddoc.pedDoc.area_enter" href="#peddoc.pedDoc.area_enter">area_enter</a></code></li>
<li><code><a title="peddoc.pedDoc.area_focus" href="#peddoc.pedDoc.area_focus">area_focus</a></code></li>
<li><code><a title="peddoc.pedDoc.area_key" href="#peddoc.pedDoc.area_key">area_key</a></code></li>
<li><code><a title="peddoc.pedDoc.area_leave" href="#peddoc.pedDoc.area_leave">area_leave</a></code></li>
<li><code><a title="peddoc.pedDoc.area_motion" href="#peddoc.pedDoc.area_motion">area_motion</a></code></li>
<li><code><a title="peddoc.pedDoc.build_menu" href="#peddoc.pedDoc.build_menu">build_menu</a></code></li>
<li><code><a title="peddoc.pedDoc.builddoc" href="#peddoc.pedDoc.builddoc">builddoc</a></code></li>
<li><code><a title="peddoc.pedDoc.calc_maxline" href="#peddoc.pedDoc.calc_maxline">calc_maxline</a></code></li>
<li><code><a title="peddoc.pedDoc.check_syntax" href="#peddoc.pedDoc.check_syntax">check_syntax</a></code></li>
<li><code><a title="peddoc.pedDoc.clearsel" href="#peddoc.pedDoc.clearsel">clearsel</a></code></li>
<li><code><a title="peddoc.pedDoc.close_button" href="#peddoc.pedDoc.close_button">close_button</a></code></li>
<li><code><a title="peddoc.pedDoc.closedoc" href="#peddoc.pedDoc.closedoc">closedoc</a></code></li>
<li><code><a title="peddoc.pedDoc.coloring" href="#peddoc.pedDoc.coloring">coloring</a></code></li>
<li><code><a title="peddoc.pedDoc.configure_event" href="#peddoc.pedDoc.configure_event">configure_event</a></code></li>
<li><code><a title="peddoc.pedDoc.create_menuitem" href="#peddoc.pedDoc.create_menuitem">create_menuitem</a></code></li>
<li><code><a title="peddoc.pedDoc.delundo" href="#peddoc.pedDoc.delundo">delundo</a></code></li>
<li><code><a title="peddoc.pedDoc.destroy_cb" href="#peddoc.pedDoc.destroy_cb">destroy_cb</a></code></li>
<li><code><a title="peddoc.pedDoc.diffx" href="#peddoc.pedDoc.diffx">diffx</a></code></li>
<li><code><a title="peddoc.pedDoc.do_chores" href="#peddoc.pedDoc.do_chores">do_chores</a></code></li>
<li><code><a title="peddoc.pedDoc.doc_activate_action" href="#peddoc.pedDoc.doc_activate_action">doc_activate_action</a></code></li>
<li><code><a title="peddoc.pedDoc.doclabel_callb" href="#peddoc.pedDoc.doclabel_callb">doclabel_callb</a></code></li>
<li><code><a title="peddoc.pedDoc.done_fc" href="#peddoc.pedDoc.done_fc">done_fc</a></code></li>
<li><code><a title="peddoc.pedDoc.done_mac_fc" href="#peddoc.pedDoc.done_mac_fc">done_mac_fc</a></code></li>
<li><code><a title="peddoc.pedDoc.done_mac_open_fc" href="#peddoc.pedDoc.done_mac_open_fc">done_mac_open_fc</a></code></li>
<li><code><a title="peddoc.pedDoc.draw_event" href="#peddoc.pedDoc.draw_event">draw_event</a></code></li>
<li><code><a title="peddoc.pedDoc.file_dlg" href="#peddoc.pedDoc.file_dlg">file_dlg</a></code></li>
<li><code><a title="peddoc.pedDoc.find" href="#peddoc.pedDoc.find">find</a></code></li>
<li><code><a title="peddoc.pedDoc.flash" href="#peddoc.pedDoc.flash">flash</a></code></li>
<li><code><a title="peddoc.pedDoc.focus_in_cb" href="#peddoc.pedDoc.focus_in_cb">focus_in_cb</a></code></li>
<li><code><a title="peddoc.pedDoc.focus_out_cb" href="#peddoc.pedDoc.focus_out_cb">focus_out_cb</a></code></li>
<li><code><a title="peddoc.pedDoc.get_height" href="#peddoc.pedDoc.get_height">get_height</a></code></li>
<li><code><a title="peddoc.pedDoc.get_height_char" href="#peddoc.pedDoc.get_height_char">get_height_char</a></code></li>
<li><code><a title="peddoc.pedDoc.get_size" href="#peddoc.pedDoc.get_size">get_size</a></code></li>
<li><code><a title="peddoc.pedDoc.get_width" href="#peddoc.pedDoc.get_width">get_width</a></code></li>
<li><code><a title="peddoc.pedDoc.get_width_char" href="#peddoc.pedDoc.get_width_char">get_width_char</a></code></li>
<li><code><a title="peddoc.pedDoc.gotoxy" href="#peddoc.pedDoc.gotoxy">gotoxy</a></code></li>
<li><code><a title="peddoc.pedDoc.grab_focus_cb" href="#peddoc.pedDoc.grab_focus_cb">grab_focus_cb</a></code></li>
<li><code><a title="peddoc.pedDoc.hexview" href="#peddoc.pedDoc.hexview">hexview</a></code></li>
<li><code><a title="peddoc.pedDoc.hscroll_cb" href="#peddoc.pedDoc.hscroll_cb">hscroll_cb</a></code></li>
<li><code><a title="peddoc.pedDoc.idle_queue" href="#peddoc.pedDoc.idle_queue">idle_queue</a></code></li>
<li><code><a title="peddoc.pedDoc.inserttext" href="#peddoc.pedDoc.inserttext">inserttext</a></code></li>
<li><code><a title="peddoc.pedDoc.intersect" href="#peddoc.pedDoc.intersect">intersect</a></code></li>
<li><code><a title="peddoc.pedDoc.inval_line" href="#peddoc.pedDoc.inval_line">inval_line</a></code></li>
<li><code><a title="peddoc.pedDoc.invalidate" href="#peddoc.pedDoc.invalidate">invalidate</a></code></li>
<li><code><a title="peddoc.pedDoc.is_c_like" href="#peddoc.pedDoc.is_c_like">is_c_like</a></code></li>
<li><code><a title="peddoc.pedDoc.iterdocs" href="#peddoc.pedDoc.iterdocs">iterdocs</a></code></li>
<li><code><a title="peddoc.pedDoc.loadbuff" href="#peddoc.pedDoc.loadbuff">loadbuff</a></code></li>
<li><code><a title="peddoc.pedDoc.loadfile" href="#peddoc.pedDoc.loadfile">loadfile</a></code></li>
<li><code><a title="peddoc.pedDoc.loadmacro" href="#peddoc.pedDoc.loadmacro">loadmacro</a></code></li>
<li><code><a title="peddoc.pedDoc.loadparms" href="#peddoc.pedDoc.loadparms">loadparms</a></code></li>
<li><code><a title="peddoc.pedDoc.loadundo" href="#peddoc.pedDoc.loadundo">loadundo</a></code></li>
<li><code><a title="peddoc.pedDoc.locate" href="#peddoc.pedDoc.locate">locate</a></code></li>
<li><code><a title="peddoc.pedDoc.menuitem_response" href="#peddoc.pedDoc.menuitem_response">menuitem_response</a></code></li>
<li><code><a title="peddoc.pedDoc.menuitem_response2" href="#peddoc.pedDoc.menuitem_response2">menuitem_response2</a></code></li>
<li><code><a title="peddoc.pedDoc.normsel" href="#peddoc.pedDoc.normsel">normsel</a></code></li>
<li><code><a title="peddoc.pedDoc.on_drag_data_get" href="#peddoc.pedDoc.on_drag_data_get">on_drag_data_get</a></code></li>
<li><code><a title="peddoc.pedDoc.on_drag_data_received" href="#peddoc.pedDoc.on_drag_data_received">on_drag_data_received</a></code></li>
<li><code><a title="peddoc.pedDoc.on_drag_drop" href="#peddoc.pedDoc.on_drag_drop">on_drag_drop</a></code></li>
<li><code><a title="peddoc.pedDoc.on_drag_motion" href="#peddoc.pedDoc.on_drag_motion">on_drag_motion</a></code></li>
<li><code><a title="peddoc.pedDoc.overwrite_done" href="#peddoc.pedDoc.overwrite_done">overwrite_done</a></code></li>
<li><code><a title="peddoc.pedDoc.pix2pos" href="#peddoc.pedDoc.pix2pos">pix2pos</a></code></li>
<li><code><a title="peddoc.pedDoc.pix2xpos" href="#peddoc.pedDoc.pix2xpos">pix2xpos</a></code></li>
<li><code><a title="peddoc.pedDoc.pix2ypos" href="#peddoc.pedDoc.pix2ypos">pix2ypos</a></code></li>
<li><code><a title="peddoc.pedDoc.poprclick" href="#peddoc.pedDoc.poprclick">poprclick</a></code></li>
<li><code><a title="peddoc.pedDoc.poprclick2" href="#peddoc.pedDoc.poprclick2">poprclick2</a></code></li>
<li><code><a title="peddoc.pedDoc.poprclick3" href="#peddoc.pedDoc.poprclick3">poprclick3</a></code></li>
<li><code><a title="peddoc.pedDoc.popspell" href="#peddoc.pedDoc.popspell">popspell</a></code></li>
<li><code><a title="peddoc.pedDoc.prompt_save" href="#peddoc.pedDoc.prompt_save">prompt_save</a></code></li>
<li><code><a title="peddoc.pedDoc.rclick_action_doc" href="#peddoc.pedDoc.rclick_action_doc">rclick_action_doc</a></code></li>
<li><code><a title="peddoc.pedDoc.re_diff" href="#peddoc.pedDoc.re_diff">re_diff</a></code></li>
<li><code><a title="peddoc.pedDoc.rescan" href="#peddoc.pedDoc.rescan">rescan</a></code></li>
<li><code><a title="peddoc.pedDoc.run_keytime" href="#peddoc.pedDoc.run_keytime">run_keytime</a></code></li>
<li><code><a title="peddoc.pedDoc.save" href="#peddoc.pedDoc.save">save</a></code></li>
<li><code><a title="peddoc.pedDoc.saveas" href="#peddoc.pedDoc.saveas">saveas</a></code></li>
<li><code><a title="peddoc.pedDoc.savebackup" href="#peddoc.pedDoc.savebackup">savebackup</a></code></li>
<li><code><a title="peddoc.pedDoc.savemacro" href="#peddoc.pedDoc.savemacro">savemacro</a></code></li>
<li><code><a title="peddoc.pedDoc.saveorg" href="#peddoc.pedDoc.saveorg">saveorg</a></code></li>
<li><code><a title="peddoc.pedDoc.saveparms" href="#peddoc.pedDoc.saveparms">saveparms</a></code></li>
<li><code><a title="peddoc.pedDoc.saveundo" href="#peddoc.pedDoc.saveundo">saveundo</a></code></li>
<li><code><a title="peddoc.pedDoc.scroll_event" href="#peddoc.pedDoc.scroll_event">scroll_event</a></code></li>
<li><code><a title="peddoc.pedDoc.search" href="#peddoc.pedDoc.search">search</a></code></li>
<li><code><a title="peddoc.pedDoc.search_again" href="#peddoc.pedDoc.search_again">search_again</a></code></li>
<li><code><a title="peddoc.pedDoc.set_caret" href="#peddoc.pedDoc.set_caret">set_caret</a></code></li>
<li><code><a title="peddoc.pedDoc.set_caret_middle" href="#peddoc.pedDoc.set_caret_middle">set_caret_middle</a></code></li>
<li><code><a title="peddoc.pedDoc.set_changed" href="#peddoc.pedDoc.set_changed">set_changed</a></code></li>
<li><code><a title="peddoc.pedDoc.set_diffs" href="#peddoc.pedDoc.set_diffs">set_diffs</a></code></li>
<li><code><a title="peddoc.pedDoc.set_maxlinelen" href="#peddoc.pedDoc.set_maxlinelen">set_maxlinelen</a></code></li>
<li><code><a title="peddoc.pedDoc.set_maxlines" href="#peddoc.pedDoc.set_maxlines">set_maxlines</a></code></li>
<li><code><a title="peddoc.pedDoc.set_nocol" href="#peddoc.pedDoc.set_nocol">set_nocol</a></code></li>
<li><code><a title="peddoc.pedDoc.set_ro" href="#peddoc.pedDoc.set_ro">set_ro</a></code></li>
<li><code><a title="peddoc.pedDoc.set_sidetab" href="#peddoc.pedDoc.set_sidetab">set_sidetab</a></code></li>
<li><code><a title="peddoc.pedDoc.set_tablabel" href="#peddoc.pedDoc.set_tablabel">set_tablabel</a></code></li>
<li><code><a title="peddoc.pedDoc.setcol" href="#peddoc.pedDoc.setcol">setcol</a></code></li>
<li><code><a title="peddoc.pedDoc.setfont" href="#peddoc.pedDoc.setfont">setfont</a></code></li>
<li><code><a title="peddoc.pedDoc.showcol" href="#peddoc.pedDoc.showcol">showcol</a></code></li>
<li><code><a title="peddoc.pedDoc.showtab" href="#peddoc.pedDoc.showtab">showtab</a></code></li>
<li><code><a title="peddoc.pedDoc.size_alloc" href="#peddoc.pedDoc.size_alloc">size_alloc</a></code></li>
<li><code><a title="peddoc.pedDoc.size_request" href="#peddoc.pedDoc.size_request">size_request</a></code></li>
<li><code><a title="peddoc.pedDoc.toggle_ro" href="#peddoc.pedDoc.toggle_ro">toggle_ro</a></code></li>
<li><code><a title="peddoc.pedDoc.update_bar2" href="#peddoc.pedDoc.update_bar2">update_bar2</a></code></li>
<li><code><a title="peddoc.pedDoc.vscroll_cb" href="#peddoc.pedDoc.vscroll_cb">vscroll_cb</a></code></li>
<li><code><a title="peddoc.pedDoc.walk_func" href="#peddoc.pedDoc.walk_func">walk_func</a></code></li>
<li><code><a title="peddoc.pedDoc.writeout" href="#peddoc.pedDoc.writeout">writeout</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>