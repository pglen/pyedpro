<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>acthand API documentation</title>
<meta name="description" content="Action Handler for the editor. Extracted to a separate module for
easy update. These are the actions for pyedpro. You may define more
and attach a key â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>acthand</code></h1>
</header>
<section id="section-intro">
<p>Action Handler for the editor. Extracted to a separate module for
easy update. These are the actions for pyedpro. You may define more
and attach a key handler to it in the tables of keyhand.py</p>
<p>The function names hint to the key handled. (Half) of the documentation
can be deduced from the function names.</p>
<p>Notes:</p>
<p>a.) Navigation may be blind, the doc class will contain the cursor
within the document.</p>
<p>b.) Many functions are sensitive to shift ctrl alt etc &hellip;
See the arrow key code [left()] how it is implemented to extend
selection.</p>
<p>c.) Anatomy of key handler function:
shift pre - ctrl/alt handler - regular handler - shift post
This way the nav keys can select in their original function</p>
<p>d.) Token completion. Tokens are kept in a stack 10 deep. If half of the
token is typed, the token complete will fill in the other half.
This is a very desirable behavior when writing code, as it feeds the
variable name to the text, essentially preventing var name mistype.
Because token completion has a short stack, it has a large
probability to fill in the var names from local scope.
If token completion filled in an unwanted string, backpedal to the
half point in the string and type as usual.
If the completion behavior is not desired, disable the code marked
'Token Completion'</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

&#39;&#39;&#39;
 Action Handler for the editor. Extracted to a separate module for
 easy update. These are the actions for pyedpro. You may define more
 and attach a key handler to it in the tables of keyhand.py

 The function names hint to the key handled. (Half) of the documentation
 can be deduced from the function names.

 Notes:

 a.) Navigation may be blind, the doc class will contain the cursor
       within the document.

 b.) Many functions are sensitive to shift ctrl alt etc ...
       See the arrow key code [left()] how it is implemented to extend
       selection.

 c.) Anatomy of key handler function:
       shift pre - ctrl/alt handler - regular handler - shift post
       This way the nav keys can select in their original function

 d.) Token completion. Tokens are kept in a stack 10 deep. If half of the
       token is typed, the token complete will fill in the other half.
       This is a very desirable behavior when writing code, as it feeds the
       variable name to the text, essentially preventing var name mistype.
       Because token completion has a short stack, it has a large
       probability to fill in the var names from local scope.
       If token completion filled in an unwanted string, backpedal to the
       half point in the string and type as usual.
       If the completion behavior is not desired, disable the code marked
       &#39;Token Completion&#39;
&#39;&#39;&#39;

from __future__ import absolute_import
from __future__ import print_function

import string, subprocess, os, platform, datetime, sys, codecs

try:
    import cups
except:
    print (&#34;Printing subsys might not be available&#34;)

import gi
gi.require_version(&#34;Gtk&#34;, &#34;3.0&#34;)
from gi.repository import Gtk
from gi.repository import Gdk
from gi.repository import GObject

from pedlib import  pedconfig
from pedlib import  pedofd
from pedlib import  pedync
from pedlib import  pedspell
from pedlib import  pedcolor
from pedlib import  pedlog
from pedlib import  pedfont
from pedlib import  pedundo
from pedlib import  pedtts
from pedlib import  pedmisc
from pedlib import  pedbuffs

#import  pyperclip # dead end

from pedlib.keywords import *
from pedlib.pedutil import *
from pedlib.pedgoto import *
from pedlib.pedcanv import *

lastcmd = &#34;&#34;
rostr = &#34;This buffer is read only.&#34;

import acthand2

# ------------------------------------------------------------------------
# Action handler. Called from key handler.
# There is a function for most every key. Have at it.
# Function name hints to key / . like up() is key up, and the action

class ActHand(acthand2.ActHand2):

    def __init__(self):
        self.was_home = 0
        self.was_end = 0

        self.clips = []
        for aa in range(10):
            self.clips.append(&#34;&#34;);
        self.currclip = 0;

    def _getsel(self, self2):

        # Normalize
        xssel = min(self2.xsel, self2.xsel2)
        xesel = max(self2.xsel, self2.xsel2)
        yssel = min(self2.ysel, self2.ysel2)
        yesel = max(self2.ysel, self2.ysel2)

        cnt = yssel; cnt2 = 0; cumm = &#34;&#34;
        while True:
            if cnt &gt; yesel: break
            self.pad_list(self2, cnt)
            line = self2.text[cnt]
            if self2.colsel:
                frag = line[xssel:xesel]
            else :                                  # startsel - endsel
                if cnt == yssel and cnt == yesel:   # sel on the same line
                    frag = line[xssel:xesel]
                elif cnt == yssel:                  # start line
                    frag = line[xssel:]
                elif cnt == yesel:                  # end line
                    frag = line[:xesel]
                else:
                    frag = line[:]

            if cnt2: frag = &#34;\n&#34; + frag
            cumm += frag
            cnt += 1; cnt2 += 1

        return cumm

    # -----------------------------------------------------------------------

    def ctrl_tab(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;ctrl_tab&#34;)

        if self2.shift:
            self2.mained.prevwin()
        else:
            self2.mained.nextwin()

    def up(self, self2):
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        incr = 1
        if self2.alt:
            self.pgup(self2)
        elif self2.ctrl:
            incr = 10
        elif self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.xsel2 = xidx + 1
            if self2.ysel == -1:
                self2.ysel = yidx

        self2.set_caret(xidx, yidx - incr)

        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            self2.invalidate()
        else:
            self2.clearsel()

    # --------------------------------------------------------------------

    def down(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        incr = 1
        if self2.ctrl:
            incr = 10
        elif self2.alt:
            self.pgdn(self2)
        elif self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.xsel2 = xidx
                self2.colsel = False
            if self2.ysel == -1:
                self2.ysel = yidx

        self2.set_caret(xidx, yidx + incr)

        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            self2.invalidate()
        else:
            self2.clearsel()

    # --------------------------------------------------------------------

    def left(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                #self2.colsel = True
            if self2.ysel == -1:
                self2.ysel = yidx

        if self2.ctrl:
            line = self2.text[yidx]
            idx  = xprevchar(line, &#34; &#34;, self2.caret[0] - 1)
            idx2 = prevchar(line, &#34; &#34;, idx)
            idx3 = xprevchar(line, &#34; &#34;, idx2)
            if idx == -1:
                #print (&#34;ctrl - L prev line&#34;)
                if yidx:
                    yidx -= 1
                    line = self2.text[yidx]
                    xidx = len(line)
                    idx = xprevchar(line, &#34; &#34;, xidx)
                    self2.set_caret(idx+1 , yidx)
            else:
                self2.set_caret(idx3+1, yidx)
            self2.invalidate()
        elif self2.alt:
            line = self2.text[yidx]
            # Only move ONE word
            try:
                if line[xidx-1] != &#34; &#34;:
                    begs, ends = selword(line, xidx-1)
                    self2.set_caret(begs, yidx)
            except:
                pass
        else:
            self2.set_caret(xidx - 1, yidx)

        # Extend selection
        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            if self2.ysel &gt; self2.ysel2:
                self2.xsel = self2.caret[0] + self2.xpos
            else:
                self2.xsel2 = self2.caret[0] + self2.xpos
        else:
            self2.clearsel()

    # ---------------------------------------------------------------------

    def right(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.colsel = False
            if self2.ysel == -1:
                self2.ysel = yidx

        if self2.ctrl:
            line = self2.text[yidx]
            idx = nextchar(line, &#34; &#34;, xidx)
            idx2 = xnextchar(line, &#34; &#34;, idx)
            #print (idx, idx2, len(line))
            # Jump to next line
            if idx2 == idx or idx2 == len(line):
                yidx += 1
                if yidx &lt; len(self2.text):
                    self2.caret[0] = 0
                    line = self2.text[yidx]
                    idx2 = xnextchar(line, &#34; &#34;, 0)
                    self2.set_caret(idx2, yidx)
                    self2.invalidate()
            else:
                #print (&#34;ctrl_right&#34;, idx2, yidx)
                self2.set_caret(idx2, yidx)
        elif self2.alt:
            line = self2.text[yidx]
            begs, ends = selword(line, xidx)
            self2.set_caret(ends, yidx)
        else:
            self2.set_caret(xidx + 1, yidx)

        # Extend selection
        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            if self2.ysel &gt; self2.ysel2:
                self2.xsel = self2.caret[0] + self2.xpos
            else:
                self2.xsel2 = self2.caret[0] + self2.xpos
            self2.invalidate()
        else:
            self2.clearsel()

    # ---------------------------------------------------------------------
    # This handler is also used for:
    #
    #       o  addig new lines
    #       o  signaling for rescan
    #       o  signaling for rescan

    def ret(self, self2):

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        self.pad_list(self2, yidx)
        line = self2.text[yidx][:]
        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
        spaces = cntleadchar(line, &#34; &#34;)
        self2.text[yidx] = line[:xidx];
        # Insert new after current
        yidx += 1
        self2.undoarr.append((xidx, yidx, pedundo.ADDED + pedundo.CONTFLAG, \
                spaces + line[xidx:]))
        text = self2.text[:yidx]
        text.append(spaces + line[xidx:])
        text += self2.text[yidx:]
        self2.text = text
        self2.set_caret(len(spaces), yidx)

        # Signal the rest for ...
        for aa in sumkeywords:
            if line.find(aa) &gt;= 0:
                self2.needscan = True

        # Contain undo
        pedundo.limit_undo(self2)

        # Update maxlines
        mlines = len(self2.text)
        if mlines &gt; self2.maxlines + 10:
            self2.set_maxlines(mlines)

        self2.set_changed(True)
        self2.src_changed = True
        self2.invalidate()

    def delete(self, self2):

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        # Delete selection
        if self2.xsel != -1:
            #print (&#34;sel del&#34;)
            self.cut(self2, True)
        else:
            xlen = len(self2.text[yidx])
            if xlen:
                line = self2.text[yidx][:]
                if xidx &gt;= xlen:     # bring in line from below
                    self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, \
                        self2.text[yidx]))
                    self2.text[yidx] += genstr(&#34; &#34;, xidx-xlen)
                    self2.text[yidx] += self2.text[yidx+1][:]
                    self2.undoarr.append((xidx, yidx+1, \
                        pedundo.DELETED + pedundo.CONTFLAG, self2.text[yidx+1]))
                    del (self2.text[yidx+1])
                    self2.invalidate()
                else:               # remove char
                    self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, \
                            self2.text[yidx]))
                    self2.text[yidx] = line[:xidx] + line[xidx+1:]
                    self2.set_caret(xidx, yidx)
                    self2.inval_line()
            else:
                del (self2.text[yidx])

        self2.xsel = -1
        self2.set_changed(True)
        self2.src_changed = True
        self2.invalidate()

    # --------------------------------------------------------------------

    def bs(self, self2):

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        # Delete selection
        if self2.xsel != -1:
            #print (&#34;sel del&#34;)
            self.cut(self2, True)
            self2.xsel = -1
        else:
            if xidx &gt; 0:
                line = self2.text[yidx][:]
                self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
                self2.text[yidx] = line[:xidx - 1] + line[xidx:]
                self2.set_caret(xidx - 1, yidx)
                self2.inval_line()
            else:                                   # Move line up
                if yidx &gt; 0:
                    if yidx &lt; len(self2.text):      # Any text?
                        self2.undoarr.append((xidx, yidx-1, \
                                pedundo.MODIFIED, self2.text[yidx-1]))
                        line = self2.text[yidx][:]
                        lenx = len(self2.text[yidx-1])
                        self2.text[yidx-1] += line
                        self2.set_caret(lenx, yidx-1)
                        self2.undoarr.append(\
                                (xidx, yidx, pedundo.DELETED + pedundo.CONTFLAG, \
                                        self2.text[yidx]))
                        del (self2.text[yidx])
                        self2.invalidate()
                    else:                           # Just update cursor
                        self2.set_caret(xidx, yidx-1)

        self2.set_changed(True)
        self2.src_changed = True

    # --------------------------------------------------------------------

    def pgup(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.colsel = False
            if self2.ysel == -1:
                self2.ysel = yidx

        if self2.alt:
            #print (&#34;alt-pgup&#34;)
            self2.mained.nextwin()
        elif self2.ctrl:
            self2.set_caret(self2.caret[0], yidx - 2 * self2.pgup)
        else:
            self2.set_caret(self2.caret[0], yidx - self2.pgup)

        # Extend selection
        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            if self2.ysel &gt; self2.ysel2:
                self2.xsel = self2.caret[0] + self2.xpos
            else:
                self2.xsel2 = self2.caret[0] + self2.xpos
            self2.invalidate()
        else:
            self2.clearsel()

    # --------------------------------------------------------------------

    def pgdn(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.colsel = False
            if self2.ysel == -1:
                self2.ysel = yidx

        if self2.alt:
            #print (&#34;alt-pgdn&#34;)
            self2.mained.prevwin()
        elif self2.ctrl:
            self2.set_caret(self2.caret[0], yidx + 2 * self2.pgup)
        else:
            self2.set_caret(self2.caret[0], yidx + self2.pgup)

        # Extend selection
        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            if self2.ysel &gt; self2.ysel2:
                self2.xsel = self2.caret[0] + self2.xpos
            else:
                self2.xsel2 = self2.caret[0] + self2.xpos
            self2.invalidate()
        else:
            self2.clearsel()

    # --------------------------------------------------------------------

    def top(self, self2):

        self.was_home = 0
        self2.set_caret(0, 0)
        self2.invalidate()

    def home(self, self2):

        #print(&#34;Home&#34;)

        xidx = self2.caret[0] + self2.xpos
        yidx = self2.caret[1] + self2.ypos
        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
            if self2.ysel == -1:
                self2.ysel = yidx
        if self2.alt:
            #print (&#34;alt-home&#34;)
            self2.mained.firstwin()
            pass
        elif self2.ctrl:
            self2.set_caret(0, 0)
            self2.invalidate()
        else:
            self.was_home += 1
            if self.was_home == 1:
                self2.set_caret(0, yidx)
                self2.invalidate()
            if self.was_home == 2:
                self2.set_caret(0, yidx - self2.pgup)
                self2.invalidate()
            elif self.was_home == 3:
                #print (&#34;bof&#34;)
                self.top(self2)
                self.was_home = 0

        if self2.shift:
            # End select
            self2.xsel2 = self2.caret[0] + self2.xpos
            self2.ysel2 = self2.caret[1] + self2.ypos
            self2.invalidate()
        else:
            self2.clearsel()
            self2.invalidate()

    def bottom(self, self2):

        self.was_end = 0
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        self2.xsel2 = self2.caret[0] + self2.xpos
        self2.ysel2 = self2.caret[1] + self2.ypos
        last = len(self2.text) - 1
        xlen = len(self2.text[last])
        self2.set_caret(xlen, last)

    # --------------------------------------------------------------------

    def end(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        #//if self2.shift:
        #//    # Begin select
        #//    if self2.xsel == -1:
        #//        self2.xsel = xidx
        #//    if self2.ysel == -1:
        #//        self2.ysel = yidx

        if self2.alt:
            #print (&#34;alt-end&#34;)
            self2.mained.lastwin()
            pass
        elif self2.ctrl:
            self.bottom(self2)
            self2.invalidate()
        elif self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = self2.caret[0]  + self2.xpos
            if self2.ysel == -1:
                self2.ysel = self2.caret[1]  + self2.ypos
            try:
                xlen = len(self2.text[yidx])
                self2.set_caret(xlen, yidx)
            except:
                pass

        else:
            self2.clearsel()
            self.was_end += 1
            if self.was_end == 2:
                #print (&#34;eop&#34;)
                yidx += 20
                try:
                    xlen = len(self2.text[yidx])
                    self2.set_caret(xlen, yidx)
                    self2.invalidate()
                except:
                    pass

            elif self.was_end == 3:
                #print (&#34;eof&#34;)
                last = len(self2.text) - 1
                xlen = len(self2.text[last])
                self2.set_caret(xlen, last)
                self2.invalidate()
                self.was_end = 0
            else:
                xlen = len(self2.text[yidx])
                self2.set_caret(xlen, yidx)

        if self2.shift:
            # End select
            #print(&#34;end sel&#34;, self2.caret[0], self2.caret[1])
            self2.xsel2 = self2.caret[0] + self2.xpos
            self2.ysel2 = self2.caret[1] + self2.ypos
            self2.invalidate()
        else:
            self2.clearsel()
            self2.invalidate()

    # --------------------------------------------------------------------

    def esc(self, self2):

        self2.mained.update_statusbar(&#34;Esc&#34;)
        self2.clearsel()
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;ESC&#34;)

        #print (pedync.yes_no_cancel(&#34;Escape&#34;, &#34;This is a question&#34; ))

    def ins(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;INS&#34;)

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        self2.insert = not self2.insert
        self2.set_caret(xidx, yidx)

    def ctrl_num_clip(self, self2, num):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL -- &#34;, num)

        self2.mained.update_statusbar(&#34;Switched to clipboard %d.&#34; % num)
        self.currclip = num
        #print (&#34;current&#34;, self.clips[self.currclip])
        #for aa in range(len(self.clips)):
        #    print (aa, self.clips[aa])
        self2.invalidate()
        self2.update_bar2()

    def ctrl_num(self, self2):
        kkk = self2.curr_event.keyval - Gdk.KEY_0
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL -- num, key=&#34;, kkk)

        # Process clip 9 -- sum it all
        if kkk == 9:
            self.clips[kkk] = &#34;&#34;
            # This sums all clipboards, puts it into 9
            for aa in range(8):
                self.clips[kkk] += self.clips[aa]

        self.ctrl_num_clip(self2, kkk)

    # --------------------------------------------------------------------
    # Not many ctrl - alt handlers yet (may conflict with Gnome/OS shortcuts)

    # --------------------------------------------------------------------
    # CTRL

    def ctrl_a(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL -- A&#34;)

        if self2.shift:
            xidx = self2.caret[0] + self2.xpos;
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            self2.gotoxy(0, yidx)
            self2.mained.update_statusbar(&#34;Goto beginning of line.&#34;)
        else:
            self2.xsel = 0; self2.ysel = 0
            self2.ysel2 = len(self2.text)
            self2.xsel2 = self2.maxlinelen
            self2.set_caret(self2.maxlinelen,  len(self2.text))
            self2.invalidate()

    def ctrl_b(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL -- B&#34;)

        if self2.shift:
            sss = self._getsel(self2)
            #print(&#34;sel&#34;, sss)
            self.add_str(self2, &#34;&lt;b&gt;&#34; + sss + &#34;&lt;/b&gt;&#34;)

        else:
            xidx = self2.caret[0] + self2.xpos;
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            bb, ee = selword(line, xidx)
            if bb != ee:
                self2.xsel = bb; self2.xsel2 =  ee
                self2.ysel = self2.ysel2 = yidx
                self2.gotoxy(self2.xsel2, self2.ysel)
            else:
                self2.mained.update_statusbar(&#34;Please navigate to word.&#34;)

        self2.invalidate()
        #self2.set_changed(True)

    def ctrl_c(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - C&#34;)

        if self2.xsel == -1 or  self2.ysel == -1:
            #self2.mained.update_statusbar(&#34;Nothing selected, copying line.&#34;)
            self2.mained.update_statusbar(&#34;Nothing selected, refuse to copy.&#34;)
            return

        cumm = self._getsel(self2)
        if self.currclip == 0:
            if self2.shift:
                self2.mained.update_statusbar(&#34;Clipboard appended.&#34;)
                ttt = self2.clipboard.wait_for_text() + cumm
                self2.clipboard.set_text(ttt, len(ttt))
            else:
                self2.mained.update_statusbar(&#34;Clipboard copied.&#34;)
                self2.clipboard.set_text(cumm, len(cumm))
        else:
            if self2.shift:
                self2.mained.update_statusbar(&#34;Clipboard %d appended.&#34; % self.currclip)
                self.clips[self.currclip] += cumm
            else:
                self2.mained.update_statusbar(&#34;Clipboard %d copied.&#34; % self.currclip)
                self.clips[self.currclip] = cumm

    def ctrl_d(self, self2):
        if self2.shift:
            dt = datetime.datetime(1990, 1, 1);
            dt2 = dt.now()
            strx2 =  dt2.strftime(&#34;%a %d.%b.%Y&#34;)
            self.add_str(self2, strx2)
        else:
            #print (&#34;CTRL - D&#34;)
            xidx = self2.caret[0] + self2.xpos;
            cnt = 0; cnt2 = 0; zlen = len(self2.text)
            while True:
                if cnt &gt;= zlen: break
                line = self2.text[cnt];  xlen = len(line)
                if xlen and line[xlen-1] == &#34; &#34;:
                    self2.undoarr.append((xidx, cnt, pedundo.MODIFIED, self2.text[cnt]))
                    self2.text[cnt] = line.rstrip()
                    cnt2 += 1
                cnt += 1

            self2.mained.update_statusbar(&#34;Trimmed %d lines.&#34; % cnt2)

            if cnt2 &gt; 0:
                self2.set_changed(True)

        self2.invalidate()

     # --------------------------------------------------------------------

    def ctrl_e(self, self2):

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - E&#34;)

        if self2.shift:
            xidx = self2.caret[0] + self2.xpos;
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            self2.gotoxy(len(line), yidx)
            self2.mained.update_statusbar(&#34;Goto end of line.&#34;)
        else:
            xidx = self2.caret[0] + self2.xpos;
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))

            cntb, cnte = selword(line, xidx)
            wlow = line[cntb:cnte].capitalize()
            #print (&#34;word   &#39;&#34; + line[cntb:cnte] + &#34;&#39;&#34;, wlow)
            self2.text[yidx] = line[:cntb] + wlow + line[cnte:]
            self2.set_changed(True)
            self2.inval_line()

    def ctrl_f(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - F&#34;)

        if self2.shift:
            self.add_str(self2, &#34;&lt;tr&gt;&lt;td&gt;&#34;)
        else:
            self2.find(self);

    def ctrl_h(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - H&#34;)

        self2.ctrl = False
        self2.alt = False
        self.left(self2)

    def ctrl_g(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - G&#34;)

        #self2.closedoc()
        if self2.shift:
            self.f5(self2)
        else:
            self.f6(self2)
        pass

    def ctrl_i(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - I&#34;)


        if self2.shift and self2.countup:
            self2.countup = 0
        else:
            strx = &#34;%d&#34; % self2.countup
            for aa in strx:
                #event = Gdk.Event(Gdk.EventType.KEY_PRESS);
                event = Gdk.EventKey()
                event.string  = aa
                event.keyval = ord(aa)
                self.add_key(self2, event)
            self2.countup += 1

    def ctrl_j(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - J&#34;)

        self2.ctrl = False
        self2.alt = False
        self.down(self2)

    def ctrl_k(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - K&#34;)

        self2.ctrl = False

        self2.alt = False
        self.up(self2)

    def ctrl_l(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - L&#34;)

        self2.ctrl = False
        self2.alt = False
        self.right(self2)

    def ctrl_m(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - M&#34;)

        if self2.shift:
            self2.mained.update_statusbar(&#34;Popped right click menu.&#34;)
            self2.poprclick(self2, None)
        else:
            self2.acorr = not self2.acorr
            if self2.acorr:
                self2.mained.update_statusbar(\
                    &#34;Autocorrect is on with %d enties.&#34; % len(auto_corr_table))
            else:
                self2.mained.update_statusbar(&#34;Autocorrect is off.&#34;)

    def ctrl_n(self, self2):
        if 1: #pedconfig.conf.pgdebug &gt; 4:
            print (&#34;Warning: got CTRL - N Main menu did not interpret it.&#34;, self2.shift)
            self2.mained.newfile()

    def ctrl_o(self, self2):
        if 1: #pedconfig.conf.pgdebug &gt; 4:
            print (&#34;Warning: got CTRL - O Main menu did not interpret it.&#34;, &#34;shift=&#34;, self2.shift)
        pass
        if self2.shift:
            load_sess()
        else:
            self2.mained.open()

    def ctrl_p(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - P&#34;)
        pass

        self2.save()
        conn = cups.Connection()
        printers = conn.getPrinters()
        if not printers:
            pedync.message(&#34;\n   No printer detected  \n\n&#34;)
            return

        #for printer in printers:
        #    print (printer, printers[printer][&#34;device-uri&#34;])

        #print(&#34;printers&#34;, printers, &#34;key&#34;, printers.keys())
        if  printers.keys():
            printer_names = list(printers.keys())
            #print(&#34;printer_name&#34;, printer_names[0])
            shortname = os.path.basename(self2.fname)
            try:
                conn.printFile(printer_names[0], self2.fname, &#34;pyedpro&#34;,  {}, )
                #print(&#34;printing&#34;, self2.fname)
                self2.mained.update_statusbar(&#34;File &#39;%s&#39; sent to printer.&#34;
                                                                % shortname )
            except:
                pedync.message(&#34;\n   Cannot print  &#39;%s&#39;\n\n&#34; % shortname)

    def ctrl_q(self, self2):
        if 1: #pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - Q&#34;)
        pass

    def ctrl_r(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - R&#34;)

        if self2.shift:
            if pedconfig.conf.pgdebug &gt; 4:
                print (&#34;CTRL-SHIFT - R&#34;)
            self2.start_m4filter()
            return

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        line = self2.text[yidx]
        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))

        cntb, cnte = selword(line, xidx)
        if cntb == cnte:
              self2.mained.update_statusbar(&#34;Please nav to a word first.&#34;)
              return
        w1 = line[cntb:cnte]
        #print (&#34;word1&#34;, w1)

        idx = xnextchar(line, &#34; &#34;, cnte)
        cntb2, cnte2 = selword(line, idx)
        if cntb2 == cnte2:
              self2.mained.update_statusbar(&#34;No second word on line.&#34;)
              return
        w2 = line[cntb2:cnte2]
        #print (&#34;word2&#34;, w2)

        idx2 = xnextchar(line, &#34; &#34;, cnte2)
        cntb3, cnte3 = selword(line, idx2)
        if cntb3 == cnte3:
              self2.mained.update_statusbar(&#34;No third word on line.&#34;)
              return
        w3 = line[cntb3:cnte3]
        #print (&#34;word3&#34;, w3)

        self2.text[yidx] = line[:cntb] + \
                w3 + &#34; &#34; + w2 + &#34; &#34; + w1 + line[cnte3:]
        self2.inval_line()

    # ---------------------------------------------------------------------

    def ctrl_s(self, self2):

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - S&#34;)
        self2.save()

    def ctrl_t(self, self2):

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - T&#34;)

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        line = self2.text[yidx]

        if self2.shift:
            dt = datetime.datetime(1990, 1, 1);
            dt2 = dt.now()
            strx2 =  dt2.strftime(&#34;%d/%m/%y %H:%M:%S &#34;)
            self.add_str(self2, strx2)
        else:
            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))

            cntb, cnte = selword(line, xidx)
            if cntb == cnte:
                  self2.mained.update_statusbar(&#34;Please nav to a word first.&#34;)
                  return
            w1 = line[cntb:cnte]
            #print (&#34;word1&#34;, w1)

            idx = xnextchar(line, &#34; &#34;, cnte)
            cntb2, cnte2 = selword(line, idx)
            if cntb2 == cnte2:
                  self2.mained.update_statusbar(&#34;No second word on line.&#34;)
                  return
            w2 = line[cntb2:cnte2]
            #print (&#34;word2&#34;, w2)

            self2.text[yidx] = line[:cntb] + w2 + &#34; &#34; + w1 + line[cnte2:]
            self2.inval_line()

    # Uppercase stuff
    def ctrl_u(self, self2, lowit = False):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - U&#34;)

        #line = &#34;&#34;; xidx = 0; yidx = 0
        # No selection, assume word
        if self2.xsel == -1 or self2.ysel == -1:
            xidx = self2.caret[0] + self2.xpos
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            #cntb, cnte = selword(line, xidx)
            cntb, cnte = selasci2(line, xidx, &#34;_-&#34;)
        else:
            # Normalize
            xssel = min(self2.xsel, self2.xsel2)
            xesel = max(self2.xsel, self2.xsel2)
            yssel = min(self2.ysel, self2.ysel2)
            yesel = max(self2.ysel, self2.ysel2)

            xidx = xssel; yidx = yssel;
            line = self2.text[yidx]
            cntb = xssel; cnte = xesel

        if cnte == cntb:
            self2.mained.update_statusbar(&#34;Please nav to a word first.&#34;)
            return

        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, line))
        #print (&#34;word / selection&#34;, line[cntb:cnte])

        if self2.shift or lowit:
            wlow = line[cntb:cnte].lower()
        else:
            wlow = line[cntb:cnte].upper()

        self2.text[yidx] = line[:cntb] + wlow + line[cnte:]
        self2.set_changed(True)
        self2.inval_line()

    def ctrl_w(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - W&#34;)

        if self2.shift:
            self2.mained.closeall()
        else:
            self2.mained.close_document()

    def ctrl_v(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - V&#34;)

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        #clip = Gtk.Clipboard()
        #disp2 = Gdk.Display()
        #disp = disp2.get_default()
        #clip = Gtk.Clipboard.get_default(disp)

        if self.currclip == 0:
            # Blew up on the Mac
            #self2.clipboard.request_text(self.clip_cb, self2)
            ttt = self2.clipboard.wait_for_text()
            #print(&#34;got paste&#34;, ttt)
            self.clip_cb(None, ttt,  self2)
        else:
            #self.clip_cb(clip, self.clips[self.currclip], self2)
            self.clip_cb(None, self.clips[self.currclip], self2)

    # Pad line list to accomodate insert
    # We group this operation into change (no undo needed)
    def pad_list(self, self2, yidx):
         # Extend list to accomodate insert
        ylen = len(self2.text) - 1 # dealing with index vs len
        if yidx &gt;= ylen:
            cnt = 0
            for aa in range(yidx - ylen):
                #self2.undoarr.append((0,  yidx + cnt, pedundo.ADDED + pedundo.CONTFLAG, &#34;&#34;))
                self2.text.append(&#34;&#34;)
                cnt += 1
            #self2.undoarr.append((0, yidx, pedundo.NOOP, &#34;&#34;))

    # Pad line to accomodate insert
    def pad_line(self, self2, xidx, yidx):
        xlen = len(self2.text[yidx])
        if xidx &gt;= xlen:
            #self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
            for aa in range(xidx - xlen):
                self2.text[yidx] += &#34; &#34;

    # Paste clipboard
    def clip_cb(self, clip, text, self2, boundary = True ):

        if pedconfig.conf.verbose:
            print (&#34;Clipboard: &#39;&#34; + text + &#34;&#39;&#34;, self2.caret[1], self2.ypos)

        try:
            if type(text) != str:
                text = codecs.decode(text)
                #print (&#34;string is UTF-8, length %d bytes&#34; % len(text2))
            else:
                pass
                #print (&#34;string is text, length %d bytes&#34; % len(text2))

        except UnicodeError:
            print (&#34;string is not UTF-8&#34;)
            #return xx, yy

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        # Replace selection
        if self2.xsel != -1:
            #print (&#34;sel replace&#34;)
            #self2.set_caret(self., yidx)
            self.cut(self2, True)

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        cnt = yidx; cc = &#34;&#34;; ttt = str.split(text, &#34;\n&#34;)

        if self2.colsel:
            if boundary:
                self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
            for aa in ttt:
                self.pad_list(self2, yidx)
                line = self2.text[yidx]
                self2.undoarr.append((xidx, yidx, pedundo.MODIFIED  + pedundo.CONTFLAG, \
                                 self2.text[yidx]))
                if xidx &gt; len(line):        # pad line
                    line +=  genstr(&#34; &#34;, xidx - len(line))
                self2.text[yidx] = line[:xidx] + aa + line[xidx:]
                self2.gotoxy(xidx, yidx)
                yidx += 1
        else:
            if len(ttt) == 1:               # single line
                if boundary:
                   self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
                self.pad_list(self2, yidx)
                line = self2.text[int(yidx)]
                self2.undoarr.append((xidx, yidx, pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[yidx]))
                if xidx &gt; len(line):        # pad line
                    line +=  genstr(&#34; &#34;, xidx - len(line))
                self2.text[yidx] = line[:xidx] + ttt[0] + line[xidx:]
                self2.gotoxy(xidx+len(ttt[0]), yidx)
            else:
                if boundary:
                    self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
                for aa in ttt:
                    self.pad_list(self2, cnt)
                    if cnt == yidx :            # first line
                        line = self2.text[yidx]
                        if xidx &gt; len(line):    # pad line
                            line += genstr(&#34; &#34;, xidx - len(line))
                        self2.undoarr.append((xidx, yidx, \
                            pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[yidx]))
                        bb  =  line[:xidx] + aa
                        cc = line[xidx:]
                        self2.text[yidx] = bb
                    else:
                        self2.undoarr.append((xidx, cnt, pedundo.ADDED + pedundo.CONTFLAG,\
                                        self2.text[cnt]))
                        text2 = self2.text[:cnt]
                        text2.append(aa)
                        text2 += self2.text[cnt:]
                        self2.text = text2
                    cnt += 1
                #last line:
                self2.undoarr.append((xidx, cnt-1, pedundo.MODIFIED + pedundo.CONTFLAG,\
                     self2.text[cnt-1]))
                text2 = self2.text[cnt-1]
                self2.text[cnt-1] = text2 + cc
                self2.gotoxy(len(text2), yidx + len(ttt)-1)

        mlen = self2.calc_maxline()
        self2.set_maxlinelen(mlen, False)

        #self2.set_maxlines(len(self2.text), False)

        self2.set_changed(True)
        self2.src_changed = True
        self2.invalidate()

    # --------------------------------------------------------------------
    # Cut to clipboard

    def ctrl_x(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - X&#34;)

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        self.cut(self2)

    def cut(self, self2, fake = False, boundary = True):
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.xsel == -1 or  self2.ysel == -1:
            self2.mained.update_statusbar(&#34;Nothing selected&#34;)
            return

        if self2.colsel:
            # Normalize
            xssel = min(self2.xsel, self2.xsel2)
            xesel = max(self2.xsel, self2.xsel2)
            yssel = min(self2.ysel, self2.ysel2)
            yesel = max(self2.ysel, self2.ysel2)
        else:
            if self2.ysel &lt; self2.ysel2:
                yssel = self2.ysel
                yesel = self2.ysel2
                xssel = self2.xsel
                xesel = self2.xsel2
            elif self2.ysel == self2.ysel2:
                yssel = self2.ysel
                yesel = self2.ysel2
                xssel = min(self2.xsel, self2.xsel2)
                xesel = max(self2.xsel, self2.xsel2)
            else:
                yssel = self2.ysel2
                yesel = self2.ysel
                xssel = self2.xsel2
                xesel = self2.xsel

        #print (xssel, xesel, yssel, yesel)

        #  undo (grouping stops)
        if boundary:
            self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))

        cnt = yssel; cnt2 = 0; cumm = &#34;&#34;; darr = []
        while True:
            if cnt &gt; yesel: break
            xidx = self2.caret[0] + self2.xpos
            #yidx = self2.caret[1] + self2.ypos
            self.pad_list(self2, cnt)
            line = self2.text[int(cnt)]
            if self2.colsel:
                self2.undoarr.append((xidx, cnt, \
                    pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[int(cnt)]))
                frag = line[xssel:xesel]
                self2.text[int(cnt)] = line[:int(xssel)] + line[int(xesel):]
            else:
                self2.undoarr.append((xssel, cnt, \
                    pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[int(cnt)]))
                if cnt == yssel and cnt == yesel:   # Selection on one line
                    frag = line[int(xssel):int(xesel)]
                    self2.text[int(cnt)] = line[:int(xssel)] + line[int(xesel):]
                    #if xssel == 0:
                    #    darr.append(cnt)
                elif cnt == yssel:                  # On start line
                    sline = cnt
                    frag = line[int(xssel):]
                    self2.text[int(cnt)] = line[:int(xssel)]
                    #if xssel == 0:
                    #    darr.append(int(cnt))
                elif cnt == yesel:                  # On end line
                    frag = line[:int(xesel)]
                    self2.text[int(sline)] = self2.text[int(sline)] + line[int(xesel):]
                    darr.append(cnt)
                else:                               # On selected line
                    frag = line[:]
                    #self2.text[cnt] = &#34;&#34;
                    darr.append(cnt)

            if cnt2: frag = &#34;\n&#34; + frag
            cumm += frag
            cnt += 1; cnt2 += 1

        #print (&#34;clip x: &#39;&#34;, cumm, &#34;&#39;&#34;)

        # Delete from the end to the beginning
        darr.reverse()
        for aa in darr:
            self2.undoarr.append((xidx, aa, \
                pedundo.DELETED + pedundo.CONTFLAG, self2.text[aa]))
            #print (&#34;del&#34;, aa)
            del(self2.text[aa])

        self2.mained.update_statusbar(&#34;Cut %d lines&#34; % (yesel - yssel))

        self2.clearsel()
        self2.gotoxy(xssel, yssel)

        # We use this for deleting as well, so fake clip op
        if not fake:
            #clip = Gtk.Clipboard()
            #disp2 = Gdk.Display()
            #disp = disp2.get_default()
            #clip = Gtk.Clipboard.get_default(disp)

            if self.currclip == 0:
                self2.clipboard.set_text(cumm, len(cumm))
            self.clips[self.currclip] = cumm

        self2.invalidate()
        self2.set_changed(True)
        self2.src_changed = True

    def ctrl_y(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - Y&#34;)

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        pedundo.redo(self2, self)

    def ctrl_z(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - Z&#34;)

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return
        pedundo.undo(self2, self)

    def ctrl_space(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - SP&#34;)

        if self2.shift:
            self.add_str(self2, &#34;&amp;nbsp; &#34;)
        else:
            self2.nokey = True
            self2.mained.update_statusbar(&#34;Keyboard disabled.&#34;)


    def f1(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F1&#34;)
        if self2.shift:
            sss = self._getsel(self2)
            self2.mained.update_statusbar(&#34;Opening DEVDOCS help file ...&#34;)
            try:
                #print(&#34;sss&#34;, sss)
                ret = subprocess.Popen([&#34;devdocs&#34;, &#34;-s&#34;, sss,])
            except:
                pedync.message(&#34;\n   Cannot launch devdocs   \n\n&#34;
                               &#34;              (Please install)&#34;)
        else:
            self2.mained.update_statusbar(&#34;Opening KEYS help file ...&#34;)
            kk = get_exec_path(&#34;KEYS&#34;)
            if pedconfig.conf.verbose:
                print(&#34;Pang open&#34;, kk)
            launch_pangview(kk)

    def f2(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F2&#34;)

        if self2.shift:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                pedync.message(&#34;\n   This feature is Linux only   \n\n&#34;
                                   &#34;              ()&#34;)
            else:
                sss = self._getsel(self2)
                self2.mained.update_statusbar(&#34;Opening devhelp file ...&#34;)
                try:
                    ret = subprocess.Popen([&#34;devhelp&#34;, &#34;-s&#34;, sss,])
                    #ret = subprocess.Popen([&#34;gnome-help&#34;,])
                except:
                    pedync.message(&#34;\n   Cannot launch devhelp   \n\n&#34;
                                   &#34;              (Please install)&#34;)
        elif self2.ctrl:
            # System uses it
            pass
        else:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                pedync.message(&#34;\n   This feature is Linux only   \n\n&#34;
                                   &#34;              ()&#34;)
            else:
                sss = &#34;python:&#34; + self._getsel(self2)
                self2.mained.update_statusbar(&#34;Opening Zeal with &#39;%s&#39;&#34; % sss)
                try:
                    #print(&#34;sss&#34;, sss)
                    ret = subprocess.Popen([&#34;zeal&#34;, sss,])
                    #ret = subprocess.Popen([&#34;devdocs&#34;, &#34;-s&#34;, sss,])

                except:
                    pedync.message(&#34;\n   Cannot launch zeal \n\n&#34;
                                   &#34;              (Please install)&#34;)

    def f3(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F3&#34;)

        if self2.shift:
            self.f5(self2)
        else:
            self.f6(self2)

    def f4(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F4&#34;)
        #self.play(self2, True)
        try:
            sss = self._getsel(self2)
            ret = subprocess.Popen([&#34;firefox&#34;,
                        &#34;/home/peterglen/pydoc/python-3.8.6rc1-docs-html/index.html&#34; ])
        except:
            pedync.message(&#34;\n   Cannot launch python help  \n\n&#34;
                       &#34;              (Please install)&#34;)

    def f5(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F5&#34;)

        if len(self2.accum) == 0:
            self2.mained.update_statusbar(
                &#34;Please specify a search string (Ctrl-F) or (Alt-S)&#34;)
            return

        self2.mained.update_statusbar(&#34;Locating previous match.&#34;)
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        self2.search_again()
        cnt = len (self2.accum) - 1; match = False
        while True:
            if cnt &lt; 0 : break
            xstr = self2.accum[cnt]

            try:
                bb = xstr.split(&#34; &#34;)[0].split(&#34;:&#34;)
            except: pass
            #print (&#34;TREE sel&#34;, bb)
            # See if match on the same line
            try:
                if int(bb[1]) == yidx:
                    if int(bb[0]) &lt; xidx:
                        self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                        match = True
                        break
                elif int(bb[1]) &lt; yidx:
                    self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                    match = True
                    break
            except:
                pass

            cnt -= 1

        if not match:
            self2.mained.update_statusbar(&#34;At or before first match.&#34;)

    def f6(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F6&#34;)

        if len(self2.accum) == 0:
            self2.mained.update_statusbar(\
                &#34;Please specify a search string (Ctrl-F) or (Alt-S)&#34;)
            return

        self2.mained.update_statusbar(&#34;Locating Next match.&#34;)
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        match = False

        self2.search_again()

        for xstr in self2.accum:
            # Get back numbers the python way
            try:
                bb = xstr.split(&#34; &#34;)[0].split(&#34;:&#34;)
            except: pass
            #-print (&#34;TREE sel&#34;, bb)
            # See if match on the same line
            if int(bb[1]) == yidx:
                if int(bb[0]) &gt; xidx:
                    self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                    match = True
                    break
            elif int(bb[1]) &gt; yidx:
                self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                match = True
                break

        if not match:
            self2.mained.update_statusbar(&#34;At or after last match.&#34;)

    def f7(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F7&#34;)

        pedconfig.conf.keyh.reset()
        if self2.record:
            self2.record = False
            # Nothing recorded, restore old
            if self2.recarr == []:
                self2.mained.update_statusbar(&#34;Nothing recorded, resored old macro.&#34;)
                self2.recarr = self2.recarr2
                pedconfig.conf.recarr = self2.recarr[:]
            else:
                pedconfig.conf.recarr = self2.recarr[:]
                self2.mained.update_statusbar(&#34;Ended recording.&#34;)

        else:
            self2.mained.update_statusbar(&#34;Started recording ...&#34;)
            self2.recarr2 = self2.recarr
            self2.recarr = []
            self2.record = True
        pedconfig.conf.keyh.reset()

    # ---------------------------------------------------------------------

    def play(self, self2, anim = False):

        if self2.record:
            self2.mained.update_statusbar(&#34;Still recording, press F7 to stop&#34;)
            return True

        xlen = len(self2.recarr)
        if xlen == 0:
            # pull in global
            self2.recarr = pedconfig.conf.recarr[:]

        xlen = len(self2.recarr)
        if xlen == 0:
            self2.mained.update_statusbar(&#34;Nothing recorded, cannot play.&#34;)
            return True

        pedconfig.conf.keyh.reset()
        self2.mained.update_statusbar(&#34;Started Play ...&#34;)
        idx = 0
        while True:
            if idx &gt;= xlen: break
            #www,
            tt, kk, ss, sss, \
              pedconfig.conf.keyh.shift, pedconfig.conf.keyh.ctrl, \
                                pedconfig.conf.keyh.alt = self2.recarr[idx]
            idx += 1

            # Synthesize keystroke. We do not replicate state as
            # pyedpro maintains its own internally. (see keyhand.reset())

            ttt = Gdk.EventType.KEY_PRESS
            if tt == 9:
                ttt = Gdk.EventType.KEY_RELEASE

            #print (&#34;playing macro&#34;, tt, kk, ss)
            event = Gdk.EventKey()
            event.type = ttt
            #event.time = time.clock() * 1000
            event.keyval = kk
            #event.window = www
            event.string  = sss
            #print (&#34;play event&#34;, event, event.type, event.keyval)

            pedconfig.conf.keyh.state2 = ss
            pedconfig.conf.keyh.handle_key2(self2, None, event)
            if anim:
                usleep(30)
            #print()
        # If the state gets out or sync ...
        pedconfig.conf.keyh.reset()
        self2.mained.update_statusbar(&#34;Ended Play.&#34;)

    def f8(self, self2, anim = False):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F8&#34;)

        self.play(self2, anim)

    def f9(self, self2, flag = False):
        self2.spell = not self2.spell

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F9 spell&#34;, self2.spell)

        if self2.spell:
            ooo = &#34;on.&#34;
            if self2.shift or flag:
                self2.spellmode = True; ppp = &#34;Mode: text&#34;
            else:
                self2.spellmode = False; ppp = &#34;Mode: code&#34;
        else:
            ooo = &#34;off.&#34;; ppp = &#34;&#34;

        self2.mained.update_statusbar(&#34;Spell checking is %s %s&#34; % (ooo, ppp))
        pedspell.spell(self2, self2.spellmode)

    # This will not be called, as it activates menu
    def f10(self, self2):
        if self2.shift:
            #print (&#34;shift F10&#34;)
            pass
        if self2.ctrl:
            #print (&#34;ctrl F10&#34;)
            pass

    def f11(self, self2):
        if self2.mained.full:
            self2.mained.mywin.unfullscreen()
            self2.mained.full = False
        else:
            self2.mained.mywin.fullscreen()
            self2.mained.full = True
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F11&#34;)


    def f12(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F12&#34;)

        pass

    # ---------------------------------------------------------------------
    # Add synthesized str

    def add_str(self, self2, strx):

        for aa in strx:
            if aa == &#39;\n&#39;:
                self.ret(self2)
            else:
                #event = Gdk.Event(Gdk.EventType.KEY_PRESS);
                event = Gdk.EventKey()
                event.string  = aa
                event.keyval = ord(aa)
                self.add_key(self2, event)

    #-------------------------------------------------------------------
    # Add regular key

    def add_key(self, self2, event):

        if pedconfig.conf.pgdebug &gt; 4:
            print(&#34;add_key: &#39;%s&#39;&#34; % event.string)

        # CR / LF still haunts us, ignore CR
        if event.keyval == Gdk.KEY_Return:
            #print (&#34;Ignoring Ctrl-Return&#34;)
            return

        if self2.readonly:
            self2.mained.update_statusbar(&#34;This buffer is read only.&#34;)
            return

        if self2.hex:
            self2.mained.update_statusbar(&#34;Cannot edit in hex mode.&#34;)
            return

        # Replace selection
        if self2.xsel != -1:
            #print (&#34;sel replace&#34;)
            #self2.set_caret(self., yidx)
            self.cut(self2, True)

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        # Extend list to accomodate insert
        self.pad_list(self2, yidx)
        # Pad string to accomodate insert
        self.pad_line(self2, xidx, yidx)

        line2 = self2.text[yidx][:]
        #xidx2 = decalc_tabs(line2, self2.caret[0] + self2.xpos, self2.tabstop);
        #print (&#34;before/after&#34;, xidx, xidx2, event.string)

        ccc = &#34;&#34;
        try:
            if event.string != &#34;&#34;:
                ccc = event.string
            else:
                ccc = chr(event.keyval)

            if ord(ccc) &gt; 255:
                #print(&#34;NOT Inserting: &#39;%s&#39; len=%d ord=%d&#34; % (ccc, len(ccc), ord(ccc)) );
                self2.mained.update_statusbar(&#34;Cannot insert char %d&#34; % ord(ccc))
                return


            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
            # Replace selection
            if self2.xsel != -1:
                #print (&#34;sel replace&#34;)
                self.ctrl_x(self2, True)
                line2 = self2.text[yidx][:]

            if self2.insert:
                self2.text[yidx] = line2[:xidx] + ccc + line2[xidx:]
            else:
                self2.text[yidx] = line2[:xidx] + ccc + line2[xidx+1:]

            mlen = len(self2.text[yidx])
            if  mlen &gt; self2.maxlinelen:
                self2.set_maxlinelen(mlen)

            #self2.set_caret(calc_tabs(self2.text[yidx], xidx + 1), yidx)
            self2.set_caret(xidx + 1, yidx)

            if self2.acorr:
                # See if autocorrect is needed
                for acs, acs2 in auto_corr_table:
                    lendiff = len(acs2) - len(acs)
                    ss = self2.text[yidx][xidx-(len(acs)-1):xidx+1]
                    if ss == acs:
                        xstr =  &#34;Autocorrected to &#34;&#39;&#34;%s&#34;&#39;&#34;&#34; % acs2
                        self2.mained.update_statusbar(xstr)
                        line = self2.text[yidx]
                        self2.text[yidx] = line[:xidx-(len(acs)-1)] + \
                                            acs2 + line[xidx+1:]
                        #self2.set_caret(calc_tabs(self2.text[yidx], \
                        #    xidx + lendiff, sel2.tabstop), yidx)
                        self2.set_caret(xidx + lendiff + 1, yidx)

            # See if token is complete (disabled by default)
            &#39;&#39;&#39;
            if ccc == &#34; &#34;:
                line = self2.text[yidx]
                begs, ends = selword(line, xidx - 1)
                if ends - begs &gt;= 4:
                    #print (&#34;token complete&#34;, line[begs:ends])
                    # Limit size of token stack
                    if len(self2.tokens) &gt; 10:
                        del(self2.tokens[0])
                    self2.tokens.append(line[begs:ends])
                    #print (self2.tokens)

            # See if token completion is needed
            line = self2.text[yidx]
            idx = prevchar(line, &#34; &#34;, xidx - 1)
            word = line[idx+1:xidx+1]
            #print (&#34;word&#34;, word)
            for aa in self2.tokens:
                lendiff = len(aa) - len(word)
                #print (&#34;src&#34;,  aa[:len(aa) / 2])
                if aa[:len(aa) / 2] == word:
                    #print (&#34;completion&#34;, aa)
                    self2.text[yidx] = line[:idx+1] + aa + line[xidx+1:]
                    tmp = calc_tabs(self2.text[yidx], xidx + lendiff, self2.tabstop)
                    self2.set_caret(tmp, yidx)
                    xstr =  &#34;Autocompleted to &#34;&#39;&#34;%s&#34;&#39;&#34;&#34; % aa
                    self2.mained.update_statusbar(xstr)&#39;&#39;&#39;

            &#39;&#39;&#39;

            # See if spell checking needed
            if ccc == &#34; &#34;:
                #err = pedspell.spell_line(line, 0, len(line))
                #self2.ularr = []
                #for ss, ee in err:
                #    self2.ularr.append((ss, yidx, ee))
                self2.invalidate()    &#39;&#39;&#39;

            self2.inval_line()
            self2.set_changed(True)
            self2.src_changed = True

        except:
            # Could not convert it to character, alert user
            # Usualy unhandled control, so helps developmet
            print  (&#34;Other key&#34;, sys.exc_info(), event.keyval)
            if(pedconfig.conf.verbose):
                print(&#34;Other key&#34;, event.keyval, \
                    hex(event.keyval), hex(event.state))
            pass
        return True

    def super_a(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;SUPER - A&#34;)
        self.alt_a(self2)

    def super_b(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;SUPER - B&#34;)
        self.alt_b(self2)

    # --------------------------------------------------------------
    # Tab handle is awkward. The regular key tab will insert
    # spaces to the next multiple of four.
    # To insert a real tab, use shift tab  (like for Makefiles)

    def tab(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;TAB&#34;, self2.shift)

        #tabstop = 4
        tabstop = self2.tabstop
        self.pad_list(self2, yidx)

        # No Selection, do tab
        if self2.ysel == -1:
            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
            if self2.shift:
                line2 = self2.text[yidx][:]
                self2.text[yidx] = line2[:xidx] + &#34;\t&#34; + line2[xidx:]
                spaces = self2.tabstop - (xidx % self2.tabstop)
                self2.set_caret(xidx+1, yidx)

                #print (&#34;shif tab&#34;, spaces)
                #self2.set_caret(xidx + tabstop, yidx)
            else:
                spaces = tabstop - (xidx % tabstop)
                while spaces:
                    #event = Gdk.Event(Gdk.EventType.KEY_PRESS);
                    event = Gdk.EventKey()
                    event.string  = &#34; &#34;
                    event.keyval = ord(&#34; &#34;)
                    self.add_key(self2, event)
                    spaces -= 1
            self2.invalidate()
            self2.set_changed(True)
        else:
            # Indent, normalize
            yssel = min(self2.ysel, self2.ysel2)
            yesel = max(self2.ysel, self2.ysel2)
            #print (&#34;TAB in sel&#34;)
            cnt = yssel
            self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
            if self2.shift:
                while True:
                    if cnt &gt; yesel: break
                    self2.undoarr.append((xidx, cnt, \
                            pedundo.MODIFIED | pedundo.CONTFLAG, self2.text[cnt]))
                    self2.text[cnt] =  rmlspace(self2.text[cnt], 4)
                    cnt += 1
            else:
                while True:
                    if cnt &gt; yesel: break
                    self2.undoarr.append((xidx, cnt, \
                        pedundo.MODIFIED | pedundo.CONTFLAG, self2.text[cnt]))
                    self2.text[cnt] = &#34;    &#34; + self2.text[cnt]
                    cnt += 1
            self2.invalidate()
            self2.set_changed(True)

    def xclip_cb(self, self2, ctext, cummx):
        cummx = ctext + cummx
        self2.clipboard.set_text(cummx, len(cummx))
        #self2.clipboard.request_text(self.xclip_cb, cumm)
        ttt = self2.clipboard.wait_for_text()
        self.clip_cb(none, ttt, self2)

    # EOF</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="acthand.ActHand"><code class="flex name class">
<span>class <span class="ident">ActHand</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActHand(acthand2.ActHand2):

    def __init__(self):
        self.was_home = 0
        self.was_end = 0

        self.clips = []
        for aa in range(10):
            self.clips.append(&#34;&#34;);
        self.currclip = 0;

    def _getsel(self, self2):

        # Normalize
        xssel = min(self2.xsel, self2.xsel2)
        xesel = max(self2.xsel, self2.xsel2)
        yssel = min(self2.ysel, self2.ysel2)
        yesel = max(self2.ysel, self2.ysel2)

        cnt = yssel; cnt2 = 0; cumm = &#34;&#34;
        while True:
            if cnt &gt; yesel: break
            self.pad_list(self2, cnt)
            line = self2.text[cnt]
            if self2.colsel:
                frag = line[xssel:xesel]
            else :                                  # startsel - endsel
                if cnt == yssel and cnt == yesel:   # sel on the same line
                    frag = line[xssel:xesel]
                elif cnt == yssel:                  # start line
                    frag = line[xssel:]
                elif cnt == yesel:                  # end line
                    frag = line[:xesel]
                else:
                    frag = line[:]

            if cnt2: frag = &#34;\n&#34; + frag
            cumm += frag
            cnt += 1; cnt2 += 1

        return cumm

    # -----------------------------------------------------------------------

    def ctrl_tab(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;ctrl_tab&#34;)

        if self2.shift:
            self2.mained.prevwin()
        else:
            self2.mained.nextwin()

    def up(self, self2):
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        incr = 1
        if self2.alt:
            self.pgup(self2)
        elif self2.ctrl:
            incr = 10
        elif self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.xsel2 = xidx + 1
            if self2.ysel == -1:
                self2.ysel = yidx

        self2.set_caret(xidx, yidx - incr)

        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            self2.invalidate()
        else:
            self2.clearsel()

    # --------------------------------------------------------------------

    def down(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        incr = 1
        if self2.ctrl:
            incr = 10
        elif self2.alt:
            self.pgdn(self2)
        elif self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.xsel2 = xidx
                self2.colsel = False
            if self2.ysel == -1:
                self2.ysel = yidx

        self2.set_caret(xidx, yidx + incr)

        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            self2.invalidate()
        else:
            self2.clearsel()

    # --------------------------------------------------------------------

    def left(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                #self2.colsel = True
            if self2.ysel == -1:
                self2.ysel = yidx

        if self2.ctrl:
            line = self2.text[yidx]
            idx  = xprevchar(line, &#34; &#34;, self2.caret[0] - 1)
            idx2 = prevchar(line, &#34; &#34;, idx)
            idx3 = xprevchar(line, &#34; &#34;, idx2)
            if idx == -1:
                #print (&#34;ctrl - L prev line&#34;)
                if yidx:
                    yidx -= 1
                    line = self2.text[yidx]
                    xidx = len(line)
                    idx = xprevchar(line, &#34; &#34;, xidx)
                    self2.set_caret(idx+1 , yidx)
            else:
                self2.set_caret(idx3+1, yidx)
            self2.invalidate()
        elif self2.alt:
            line = self2.text[yidx]
            # Only move ONE word
            try:
                if line[xidx-1] != &#34; &#34;:
                    begs, ends = selword(line, xidx-1)
                    self2.set_caret(begs, yidx)
            except:
                pass
        else:
            self2.set_caret(xidx - 1, yidx)

        # Extend selection
        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            if self2.ysel &gt; self2.ysel2:
                self2.xsel = self2.caret[0] + self2.xpos
            else:
                self2.xsel2 = self2.caret[0] + self2.xpos
        else:
            self2.clearsel()

    # ---------------------------------------------------------------------

    def right(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.colsel = False
            if self2.ysel == -1:
                self2.ysel = yidx

        if self2.ctrl:
            line = self2.text[yidx]
            idx = nextchar(line, &#34; &#34;, xidx)
            idx2 = xnextchar(line, &#34; &#34;, idx)
            #print (idx, idx2, len(line))
            # Jump to next line
            if idx2 == idx or idx2 == len(line):
                yidx += 1
                if yidx &lt; len(self2.text):
                    self2.caret[0] = 0
                    line = self2.text[yidx]
                    idx2 = xnextchar(line, &#34; &#34;, 0)
                    self2.set_caret(idx2, yidx)
                    self2.invalidate()
            else:
                #print (&#34;ctrl_right&#34;, idx2, yidx)
                self2.set_caret(idx2, yidx)
        elif self2.alt:
            line = self2.text[yidx]
            begs, ends = selword(line, xidx)
            self2.set_caret(ends, yidx)
        else:
            self2.set_caret(xidx + 1, yidx)

        # Extend selection
        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            if self2.ysel &gt; self2.ysel2:
                self2.xsel = self2.caret[0] + self2.xpos
            else:
                self2.xsel2 = self2.caret[0] + self2.xpos
            self2.invalidate()
        else:
            self2.clearsel()

    # ---------------------------------------------------------------------
    # This handler is also used for:
    #
    #       o  addig new lines
    #       o  signaling for rescan
    #       o  signaling for rescan

    def ret(self, self2):

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        self.pad_list(self2, yidx)
        line = self2.text[yidx][:]
        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
        spaces = cntleadchar(line, &#34; &#34;)
        self2.text[yidx] = line[:xidx];
        # Insert new after current
        yidx += 1
        self2.undoarr.append((xidx, yidx, pedundo.ADDED + pedundo.CONTFLAG, \
                spaces + line[xidx:]))
        text = self2.text[:yidx]
        text.append(spaces + line[xidx:])
        text += self2.text[yidx:]
        self2.text = text
        self2.set_caret(len(spaces), yidx)

        # Signal the rest for ...
        for aa in sumkeywords:
            if line.find(aa) &gt;= 0:
                self2.needscan = True

        # Contain undo
        pedundo.limit_undo(self2)

        # Update maxlines
        mlines = len(self2.text)
        if mlines &gt; self2.maxlines + 10:
            self2.set_maxlines(mlines)

        self2.set_changed(True)
        self2.src_changed = True
        self2.invalidate()

    def delete(self, self2):

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        # Delete selection
        if self2.xsel != -1:
            #print (&#34;sel del&#34;)
            self.cut(self2, True)
        else:
            xlen = len(self2.text[yidx])
            if xlen:
                line = self2.text[yidx][:]
                if xidx &gt;= xlen:     # bring in line from below
                    self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, \
                        self2.text[yidx]))
                    self2.text[yidx] += genstr(&#34; &#34;, xidx-xlen)
                    self2.text[yidx] += self2.text[yidx+1][:]
                    self2.undoarr.append((xidx, yidx+1, \
                        pedundo.DELETED + pedundo.CONTFLAG, self2.text[yidx+1]))
                    del (self2.text[yidx+1])
                    self2.invalidate()
                else:               # remove char
                    self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, \
                            self2.text[yidx]))
                    self2.text[yidx] = line[:xidx] + line[xidx+1:]
                    self2.set_caret(xidx, yidx)
                    self2.inval_line()
            else:
                del (self2.text[yidx])

        self2.xsel = -1
        self2.set_changed(True)
        self2.src_changed = True
        self2.invalidate()

    # --------------------------------------------------------------------

    def bs(self, self2):

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        # Delete selection
        if self2.xsel != -1:
            #print (&#34;sel del&#34;)
            self.cut(self2, True)
            self2.xsel = -1
        else:
            if xidx &gt; 0:
                line = self2.text[yidx][:]
                self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
                self2.text[yidx] = line[:xidx - 1] + line[xidx:]
                self2.set_caret(xidx - 1, yidx)
                self2.inval_line()
            else:                                   # Move line up
                if yidx &gt; 0:
                    if yidx &lt; len(self2.text):      # Any text?
                        self2.undoarr.append((xidx, yidx-1, \
                                pedundo.MODIFIED, self2.text[yidx-1]))
                        line = self2.text[yidx][:]
                        lenx = len(self2.text[yidx-1])
                        self2.text[yidx-1] += line
                        self2.set_caret(lenx, yidx-1)
                        self2.undoarr.append(\
                                (xidx, yidx, pedundo.DELETED + pedundo.CONTFLAG, \
                                        self2.text[yidx]))
                        del (self2.text[yidx])
                        self2.invalidate()
                    else:                           # Just update cursor
                        self2.set_caret(xidx, yidx-1)

        self2.set_changed(True)
        self2.src_changed = True

    # --------------------------------------------------------------------

    def pgup(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.colsel = False
            if self2.ysel == -1:
                self2.ysel = yidx

        if self2.alt:
            #print (&#34;alt-pgup&#34;)
            self2.mained.nextwin()
        elif self2.ctrl:
            self2.set_caret(self2.caret[0], yidx - 2 * self2.pgup)
        else:
            self2.set_caret(self2.caret[0], yidx - self2.pgup)

        # Extend selection
        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            if self2.ysel &gt; self2.ysel2:
                self2.xsel = self2.caret[0] + self2.xpos
            else:
                self2.xsel2 = self2.caret[0] + self2.xpos
            self2.invalidate()
        else:
            self2.clearsel()

    # --------------------------------------------------------------------

    def pgdn(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
                self2.colsel = False
            if self2.ysel == -1:
                self2.ysel = yidx

        if self2.alt:
            #print (&#34;alt-pgdn&#34;)
            self2.mained.prevwin()
        elif self2.ctrl:
            self2.set_caret(self2.caret[0], yidx + 2 * self2.pgup)
        else:
            self2.set_caret(self2.caret[0], yidx + self2.pgup)

        # Extend selection
        if self2.shift:
            self2.ysel2 = self2.caret[1] + self2.ypos
            if self2.ysel &gt; self2.ysel2:
                self2.xsel = self2.caret[0] + self2.xpos
            else:
                self2.xsel2 = self2.caret[0] + self2.xpos
            self2.invalidate()
        else:
            self2.clearsel()

    # --------------------------------------------------------------------

    def top(self, self2):

        self.was_home = 0
        self2.set_caret(0, 0)
        self2.invalidate()

    def home(self, self2):

        #print(&#34;Home&#34;)

        xidx = self2.caret[0] + self2.xpos
        yidx = self2.caret[1] + self2.ypos
        if self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = xidx
            if self2.ysel == -1:
                self2.ysel = yidx
        if self2.alt:
            #print (&#34;alt-home&#34;)
            self2.mained.firstwin()
            pass
        elif self2.ctrl:
            self2.set_caret(0, 0)
            self2.invalidate()
        else:
            self.was_home += 1
            if self.was_home == 1:
                self2.set_caret(0, yidx)
                self2.invalidate()
            if self.was_home == 2:
                self2.set_caret(0, yidx - self2.pgup)
                self2.invalidate()
            elif self.was_home == 3:
                #print (&#34;bof&#34;)
                self.top(self2)
                self.was_home = 0

        if self2.shift:
            # End select
            self2.xsel2 = self2.caret[0] + self2.xpos
            self2.ysel2 = self2.caret[1] + self2.ypos
            self2.invalidate()
        else:
            self2.clearsel()
            self2.invalidate()

    def bottom(self, self2):

        self.was_end = 0
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        self2.xsel2 = self2.caret[0] + self2.xpos
        self2.ysel2 = self2.caret[1] + self2.ypos
        last = len(self2.text) - 1
        xlen = len(self2.text[last])
        self2.set_caret(xlen, last)

    # --------------------------------------------------------------------

    def end(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        #//if self2.shift:
        #//    # Begin select
        #//    if self2.xsel == -1:
        #//        self2.xsel = xidx
        #//    if self2.ysel == -1:
        #//        self2.ysel = yidx

        if self2.alt:
            #print (&#34;alt-end&#34;)
            self2.mained.lastwin()
            pass
        elif self2.ctrl:
            self.bottom(self2)
            self2.invalidate()
        elif self2.shift:
            # Begin select
            if self2.xsel == -1:
                self2.xsel = self2.caret[0]  + self2.xpos
            if self2.ysel == -1:
                self2.ysel = self2.caret[1]  + self2.ypos
            try:
                xlen = len(self2.text[yidx])
                self2.set_caret(xlen, yidx)
            except:
                pass

        else:
            self2.clearsel()
            self.was_end += 1
            if self.was_end == 2:
                #print (&#34;eop&#34;)
                yidx += 20
                try:
                    xlen = len(self2.text[yidx])
                    self2.set_caret(xlen, yidx)
                    self2.invalidate()
                except:
                    pass

            elif self.was_end == 3:
                #print (&#34;eof&#34;)
                last = len(self2.text) - 1
                xlen = len(self2.text[last])
                self2.set_caret(xlen, last)
                self2.invalidate()
                self.was_end = 0
            else:
                xlen = len(self2.text[yidx])
                self2.set_caret(xlen, yidx)

        if self2.shift:
            # End select
            #print(&#34;end sel&#34;, self2.caret[0], self2.caret[1])
            self2.xsel2 = self2.caret[0] + self2.xpos
            self2.ysel2 = self2.caret[1] + self2.ypos
            self2.invalidate()
        else:
            self2.clearsel()
            self2.invalidate()

    # --------------------------------------------------------------------

    def esc(self, self2):

        self2.mained.update_statusbar(&#34;Esc&#34;)
        self2.clearsel()
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;ESC&#34;)

        #print (pedync.yes_no_cancel(&#34;Escape&#34;, &#34;This is a question&#34; ))

    def ins(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;INS&#34;)

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        self2.insert = not self2.insert
        self2.set_caret(xidx, yidx)

    def ctrl_num_clip(self, self2, num):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL -- &#34;, num)

        self2.mained.update_statusbar(&#34;Switched to clipboard %d.&#34; % num)
        self.currclip = num
        #print (&#34;current&#34;, self.clips[self.currclip])
        #for aa in range(len(self.clips)):
        #    print (aa, self.clips[aa])
        self2.invalidate()
        self2.update_bar2()

    def ctrl_num(self, self2):
        kkk = self2.curr_event.keyval - Gdk.KEY_0
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL -- num, key=&#34;, kkk)

        # Process clip 9 -- sum it all
        if kkk == 9:
            self.clips[kkk] = &#34;&#34;
            # This sums all clipboards, puts it into 9
            for aa in range(8):
                self.clips[kkk] += self.clips[aa]

        self.ctrl_num_clip(self2, kkk)

    # --------------------------------------------------------------------
    # Not many ctrl - alt handlers yet (may conflict with Gnome/OS shortcuts)

    # --------------------------------------------------------------------
    # CTRL

    def ctrl_a(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL -- A&#34;)

        if self2.shift:
            xidx = self2.caret[0] + self2.xpos;
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            self2.gotoxy(0, yidx)
            self2.mained.update_statusbar(&#34;Goto beginning of line.&#34;)
        else:
            self2.xsel = 0; self2.ysel = 0
            self2.ysel2 = len(self2.text)
            self2.xsel2 = self2.maxlinelen
            self2.set_caret(self2.maxlinelen,  len(self2.text))
            self2.invalidate()

    def ctrl_b(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL -- B&#34;)

        if self2.shift:
            sss = self._getsel(self2)
            #print(&#34;sel&#34;, sss)
            self.add_str(self2, &#34;&lt;b&gt;&#34; + sss + &#34;&lt;/b&gt;&#34;)

        else:
            xidx = self2.caret[0] + self2.xpos;
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            bb, ee = selword(line, xidx)
            if bb != ee:
                self2.xsel = bb; self2.xsel2 =  ee
                self2.ysel = self2.ysel2 = yidx
                self2.gotoxy(self2.xsel2, self2.ysel)
            else:
                self2.mained.update_statusbar(&#34;Please navigate to word.&#34;)

        self2.invalidate()
        #self2.set_changed(True)

    def ctrl_c(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - C&#34;)

        if self2.xsel == -1 or  self2.ysel == -1:
            #self2.mained.update_statusbar(&#34;Nothing selected, copying line.&#34;)
            self2.mained.update_statusbar(&#34;Nothing selected, refuse to copy.&#34;)
            return

        cumm = self._getsel(self2)
        if self.currclip == 0:
            if self2.shift:
                self2.mained.update_statusbar(&#34;Clipboard appended.&#34;)
                ttt = self2.clipboard.wait_for_text() + cumm
                self2.clipboard.set_text(ttt, len(ttt))
            else:
                self2.mained.update_statusbar(&#34;Clipboard copied.&#34;)
                self2.clipboard.set_text(cumm, len(cumm))
        else:
            if self2.shift:
                self2.mained.update_statusbar(&#34;Clipboard %d appended.&#34; % self.currclip)
                self.clips[self.currclip] += cumm
            else:
                self2.mained.update_statusbar(&#34;Clipboard %d copied.&#34; % self.currclip)
                self.clips[self.currclip] = cumm

    def ctrl_d(self, self2):
        if self2.shift:
            dt = datetime.datetime(1990, 1, 1);
            dt2 = dt.now()
            strx2 =  dt2.strftime(&#34;%a %d.%b.%Y&#34;)
            self.add_str(self2, strx2)
        else:
            #print (&#34;CTRL - D&#34;)
            xidx = self2.caret[0] + self2.xpos;
            cnt = 0; cnt2 = 0; zlen = len(self2.text)
            while True:
                if cnt &gt;= zlen: break
                line = self2.text[cnt];  xlen = len(line)
                if xlen and line[xlen-1] == &#34; &#34;:
                    self2.undoarr.append((xidx, cnt, pedundo.MODIFIED, self2.text[cnt]))
                    self2.text[cnt] = line.rstrip()
                    cnt2 += 1
                cnt += 1

            self2.mained.update_statusbar(&#34;Trimmed %d lines.&#34; % cnt2)

            if cnt2 &gt; 0:
                self2.set_changed(True)

        self2.invalidate()

     # --------------------------------------------------------------------

    def ctrl_e(self, self2):

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - E&#34;)

        if self2.shift:
            xidx = self2.caret[0] + self2.xpos;
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            self2.gotoxy(len(line), yidx)
            self2.mained.update_statusbar(&#34;Goto end of line.&#34;)
        else:
            xidx = self2.caret[0] + self2.xpos;
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))

            cntb, cnte = selword(line, xidx)
            wlow = line[cntb:cnte].capitalize()
            #print (&#34;word   &#39;&#34; + line[cntb:cnte] + &#34;&#39;&#34;, wlow)
            self2.text[yidx] = line[:cntb] + wlow + line[cnte:]
            self2.set_changed(True)
            self2.inval_line()

    def ctrl_f(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - F&#34;)

        if self2.shift:
            self.add_str(self2, &#34;&lt;tr&gt;&lt;td&gt;&#34;)
        else:
            self2.find(self);

    def ctrl_h(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - H&#34;)

        self2.ctrl = False
        self2.alt = False
        self.left(self2)

    def ctrl_g(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - G&#34;)

        #self2.closedoc()
        if self2.shift:
            self.f5(self2)
        else:
            self.f6(self2)
        pass

    def ctrl_i(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - I&#34;)


        if self2.shift and self2.countup:
            self2.countup = 0
        else:
            strx = &#34;%d&#34; % self2.countup
            for aa in strx:
                #event = Gdk.Event(Gdk.EventType.KEY_PRESS);
                event = Gdk.EventKey()
                event.string  = aa
                event.keyval = ord(aa)
                self.add_key(self2, event)
            self2.countup += 1

    def ctrl_j(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - J&#34;)

        self2.ctrl = False
        self2.alt = False
        self.down(self2)

    def ctrl_k(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - K&#34;)

        self2.ctrl = False

        self2.alt = False
        self.up(self2)

    def ctrl_l(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - L&#34;)

        self2.ctrl = False
        self2.alt = False
        self.right(self2)

    def ctrl_m(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - M&#34;)

        if self2.shift:
            self2.mained.update_statusbar(&#34;Popped right click menu.&#34;)
            self2.poprclick(self2, None)
        else:
            self2.acorr = not self2.acorr
            if self2.acorr:
                self2.mained.update_statusbar(\
                    &#34;Autocorrect is on with %d enties.&#34; % len(auto_corr_table))
            else:
                self2.mained.update_statusbar(&#34;Autocorrect is off.&#34;)

    def ctrl_n(self, self2):
        if 1: #pedconfig.conf.pgdebug &gt; 4:
            print (&#34;Warning: got CTRL - N Main menu did not interpret it.&#34;, self2.shift)
            self2.mained.newfile()

    def ctrl_o(self, self2):
        if 1: #pedconfig.conf.pgdebug &gt; 4:
            print (&#34;Warning: got CTRL - O Main menu did not interpret it.&#34;, &#34;shift=&#34;, self2.shift)
        pass
        if self2.shift:
            load_sess()
        else:
            self2.mained.open()

    def ctrl_p(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - P&#34;)
        pass

        self2.save()
        conn = cups.Connection()
        printers = conn.getPrinters()
        if not printers:
            pedync.message(&#34;\n   No printer detected  \n\n&#34;)
            return

        #for printer in printers:
        #    print (printer, printers[printer][&#34;device-uri&#34;])

        #print(&#34;printers&#34;, printers, &#34;key&#34;, printers.keys())
        if  printers.keys():
            printer_names = list(printers.keys())
            #print(&#34;printer_name&#34;, printer_names[0])
            shortname = os.path.basename(self2.fname)
            try:
                conn.printFile(printer_names[0], self2.fname, &#34;pyedpro&#34;,  {}, )
                #print(&#34;printing&#34;, self2.fname)
                self2.mained.update_statusbar(&#34;File &#39;%s&#39; sent to printer.&#34;
                                                                % shortname )
            except:
                pedync.message(&#34;\n   Cannot print  &#39;%s&#39;\n\n&#34; % shortname)

    def ctrl_q(self, self2):
        if 1: #pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - Q&#34;)
        pass

    def ctrl_r(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - R&#34;)

        if self2.shift:
            if pedconfig.conf.pgdebug &gt; 4:
                print (&#34;CTRL-SHIFT - R&#34;)
            self2.start_m4filter()
            return

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        line = self2.text[yidx]
        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))

        cntb, cnte = selword(line, xidx)
        if cntb == cnte:
              self2.mained.update_statusbar(&#34;Please nav to a word first.&#34;)
              return
        w1 = line[cntb:cnte]
        #print (&#34;word1&#34;, w1)

        idx = xnextchar(line, &#34; &#34;, cnte)
        cntb2, cnte2 = selword(line, idx)
        if cntb2 == cnte2:
              self2.mained.update_statusbar(&#34;No second word on line.&#34;)
              return
        w2 = line[cntb2:cnte2]
        #print (&#34;word2&#34;, w2)

        idx2 = xnextchar(line, &#34; &#34;, cnte2)
        cntb3, cnte3 = selword(line, idx2)
        if cntb3 == cnte3:
              self2.mained.update_statusbar(&#34;No third word on line.&#34;)
              return
        w3 = line[cntb3:cnte3]
        #print (&#34;word3&#34;, w3)

        self2.text[yidx] = line[:cntb] + \
                w3 + &#34; &#34; + w2 + &#34; &#34; + w1 + line[cnte3:]
        self2.inval_line()

    # ---------------------------------------------------------------------

    def ctrl_s(self, self2):

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - S&#34;)
        self2.save()

    def ctrl_t(self, self2):

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - T&#34;)

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        line = self2.text[yidx]

        if self2.shift:
            dt = datetime.datetime(1990, 1, 1);
            dt2 = dt.now()
            strx2 =  dt2.strftime(&#34;%d/%m/%y %H:%M:%S &#34;)
            self.add_str(self2, strx2)
        else:
            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))

            cntb, cnte = selword(line, xidx)
            if cntb == cnte:
                  self2.mained.update_statusbar(&#34;Please nav to a word first.&#34;)
                  return
            w1 = line[cntb:cnte]
            #print (&#34;word1&#34;, w1)

            idx = xnextchar(line, &#34; &#34;, cnte)
            cntb2, cnte2 = selword(line, idx)
            if cntb2 == cnte2:
                  self2.mained.update_statusbar(&#34;No second word on line.&#34;)
                  return
            w2 = line[cntb2:cnte2]
            #print (&#34;word2&#34;, w2)

            self2.text[yidx] = line[:cntb] + w2 + &#34; &#34; + w1 + line[cnte2:]
            self2.inval_line()

    # Uppercase stuff
    def ctrl_u(self, self2, lowit = False):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - U&#34;)

        #line = &#34;&#34;; xidx = 0; yidx = 0
        # No selection, assume word
        if self2.xsel == -1 or self2.ysel == -1:
            xidx = self2.caret[0] + self2.xpos
            yidx = self2.caret[1] + self2.ypos
            line = self2.text[yidx]
            #cntb, cnte = selword(line, xidx)
            cntb, cnte = selasci2(line, xidx, &#34;_-&#34;)
        else:
            # Normalize
            xssel = min(self2.xsel, self2.xsel2)
            xesel = max(self2.xsel, self2.xsel2)
            yssel = min(self2.ysel, self2.ysel2)
            yesel = max(self2.ysel, self2.ysel2)

            xidx = xssel; yidx = yssel;
            line = self2.text[yidx]
            cntb = xssel; cnte = xesel

        if cnte == cntb:
            self2.mained.update_statusbar(&#34;Please nav to a word first.&#34;)
            return

        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, line))
        #print (&#34;word / selection&#34;, line[cntb:cnte])

        if self2.shift or lowit:
            wlow = line[cntb:cnte].lower()
        else:
            wlow = line[cntb:cnte].upper()

        self2.text[yidx] = line[:cntb] + wlow + line[cnte:]
        self2.set_changed(True)
        self2.inval_line()

    def ctrl_w(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - W&#34;)

        if self2.shift:
            self2.mained.closeall()
        else:
            self2.mained.close_document()

    def ctrl_v(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - V&#34;)

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        #clip = Gtk.Clipboard()
        #disp2 = Gdk.Display()
        #disp = disp2.get_default()
        #clip = Gtk.Clipboard.get_default(disp)

        if self.currclip == 0:
            # Blew up on the Mac
            #self2.clipboard.request_text(self.clip_cb, self2)
            ttt = self2.clipboard.wait_for_text()
            #print(&#34;got paste&#34;, ttt)
            self.clip_cb(None, ttt,  self2)
        else:
            #self.clip_cb(clip, self.clips[self.currclip], self2)
            self.clip_cb(None, self.clips[self.currclip], self2)

    # Pad line list to accomodate insert
    # We group this operation into change (no undo needed)
    def pad_list(self, self2, yidx):
         # Extend list to accomodate insert
        ylen = len(self2.text) - 1 # dealing with index vs len
        if yidx &gt;= ylen:
            cnt = 0
            for aa in range(yidx - ylen):
                #self2.undoarr.append((0,  yidx + cnt, pedundo.ADDED + pedundo.CONTFLAG, &#34;&#34;))
                self2.text.append(&#34;&#34;)
                cnt += 1
            #self2.undoarr.append((0, yidx, pedundo.NOOP, &#34;&#34;))

    # Pad line to accomodate insert
    def pad_line(self, self2, xidx, yidx):
        xlen = len(self2.text[yidx])
        if xidx &gt;= xlen:
            #self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
            for aa in range(xidx - xlen):
                self2.text[yidx] += &#34; &#34;

    # Paste clipboard
    def clip_cb(self, clip, text, self2, boundary = True ):

        if pedconfig.conf.verbose:
            print (&#34;Clipboard: &#39;&#34; + text + &#34;&#39;&#34;, self2.caret[1], self2.ypos)

        try:
            if type(text) != str:
                text = codecs.decode(text)
                #print (&#34;string is UTF-8, length %d bytes&#34; % len(text2))
            else:
                pass
                #print (&#34;string is text, length %d bytes&#34; % len(text2))

        except UnicodeError:
            print (&#34;string is not UTF-8&#34;)
            #return xx, yy

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        # Replace selection
        if self2.xsel != -1:
            #print (&#34;sel replace&#34;)
            #self2.set_caret(self., yidx)
            self.cut(self2, True)

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        cnt = yidx; cc = &#34;&#34;; ttt = str.split(text, &#34;\n&#34;)

        if self2.colsel:
            if boundary:
                self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
            for aa in ttt:
                self.pad_list(self2, yidx)
                line = self2.text[yidx]
                self2.undoarr.append((xidx, yidx, pedundo.MODIFIED  + pedundo.CONTFLAG, \
                                 self2.text[yidx]))
                if xidx &gt; len(line):        # pad line
                    line +=  genstr(&#34; &#34;, xidx - len(line))
                self2.text[yidx] = line[:xidx] + aa + line[xidx:]
                self2.gotoxy(xidx, yidx)
                yidx += 1
        else:
            if len(ttt) == 1:               # single line
                if boundary:
                   self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
                self.pad_list(self2, yidx)
                line = self2.text[int(yidx)]
                self2.undoarr.append((xidx, yidx, pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[yidx]))
                if xidx &gt; len(line):        # pad line
                    line +=  genstr(&#34; &#34;, xidx - len(line))
                self2.text[yidx] = line[:xidx] + ttt[0] + line[xidx:]
                self2.gotoxy(xidx+len(ttt[0]), yidx)
            else:
                if boundary:
                    self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
                for aa in ttt:
                    self.pad_list(self2, cnt)
                    if cnt == yidx :            # first line
                        line = self2.text[yidx]
                        if xidx &gt; len(line):    # pad line
                            line += genstr(&#34; &#34;, xidx - len(line))
                        self2.undoarr.append((xidx, yidx, \
                            pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[yidx]))
                        bb  =  line[:xidx] + aa
                        cc = line[xidx:]
                        self2.text[yidx] = bb
                    else:
                        self2.undoarr.append((xidx, cnt, pedundo.ADDED + pedundo.CONTFLAG,\
                                        self2.text[cnt]))
                        text2 = self2.text[:cnt]
                        text2.append(aa)
                        text2 += self2.text[cnt:]
                        self2.text = text2
                    cnt += 1
                #last line:
                self2.undoarr.append((xidx, cnt-1, pedundo.MODIFIED + pedundo.CONTFLAG,\
                     self2.text[cnt-1]))
                text2 = self2.text[cnt-1]
                self2.text[cnt-1] = text2 + cc
                self2.gotoxy(len(text2), yidx + len(ttt)-1)

        mlen = self2.calc_maxline()
        self2.set_maxlinelen(mlen, False)

        #self2.set_maxlines(len(self2.text), False)

        self2.set_changed(True)
        self2.src_changed = True
        self2.invalidate()

    # --------------------------------------------------------------------
    # Cut to clipboard

    def ctrl_x(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - X&#34;)

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        self.cut(self2)

    def cut(self, self2, fake = False, boundary = True):
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if self2.xsel == -1 or  self2.ysel == -1:
            self2.mained.update_statusbar(&#34;Nothing selected&#34;)
            return

        if self2.colsel:
            # Normalize
            xssel = min(self2.xsel, self2.xsel2)
            xesel = max(self2.xsel, self2.xsel2)
            yssel = min(self2.ysel, self2.ysel2)
            yesel = max(self2.ysel, self2.ysel2)
        else:
            if self2.ysel &lt; self2.ysel2:
                yssel = self2.ysel
                yesel = self2.ysel2
                xssel = self2.xsel
                xesel = self2.xsel2
            elif self2.ysel == self2.ysel2:
                yssel = self2.ysel
                yesel = self2.ysel2
                xssel = min(self2.xsel, self2.xsel2)
                xesel = max(self2.xsel, self2.xsel2)
            else:
                yssel = self2.ysel2
                yesel = self2.ysel
                xssel = self2.xsel2
                xesel = self2.xsel

        #print (xssel, xesel, yssel, yesel)

        #  undo (grouping stops)
        if boundary:
            self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))

        cnt = yssel; cnt2 = 0; cumm = &#34;&#34;; darr = []
        while True:
            if cnt &gt; yesel: break
            xidx = self2.caret[0] + self2.xpos
            #yidx = self2.caret[1] + self2.ypos
            self.pad_list(self2, cnt)
            line = self2.text[int(cnt)]
            if self2.colsel:
                self2.undoarr.append((xidx, cnt, \
                    pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[int(cnt)]))
                frag = line[xssel:xesel]
                self2.text[int(cnt)] = line[:int(xssel)] + line[int(xesel):]
            else:
                self2.undoarr.append((xssel, cnt, \
                    pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[int(cnt)]))
                if cnt == yssel and cnt == yesel:   # Selection on one line
                    frag = line[int(xssel):int(xesel)]
                    self2.text[int(cnt)] = line[:int(xssel)] + line[int(xesel):]
                    #if xssel == 0:
                    #    darr.append(cnt)
                elif cnt == yssel:                  # On start line
                    sline = cnt
                    frag = line[int(xssel):]
                    self2.text[int(cnt)] = line[:int(xssel)]
                    #if xssel == 0:
                    #    darr.append(int(cnt))
                elif cnt == yesel:                  # On end line
                    frag = line[:int(xesel)]
                    self2.text[int(sline)] = self2.text[int(sline)] + line[int(xesel):]
                    darr.append(cnt)
                else:                               # On selected line
                    frag = line[:]
                    #self2.text[cnt] = &#34;&#34;
                    darr.append(cnt)

            if cnt2: frag = &#34;\n&#34; + frag
            cumm += frag
            cnt += 1; cnt2 += 1

        #print (&#34;clip x: &#39;&#34;, cumm, &#34;&#39;&#34;)

        # Delete from the end to the beginning
        darr.reverse()
        for aa in darr:
            self2.undoarr.append((xidx, aa, \
                pedundo.DELETED + pedundo.CONTFLAG, self2.text[aa]))
            #print (&#34;del&#34;, aa)
            del(self2.text[aa])

        self2.mained.update_statusbar(&#34;Cut %d lines&#34; % (yesel - yssel))

        self2.clearsel()
        self2.gotoxy(xssel, yssel)

        # We use this for deleting as well, so fake clip op
        if not fake:
            #clip = Gtk.Clipboard()
            #disp2 = Gdk.Display()
            #disp = disp2.get_default()
            #clip = Gtk.Clipboard.get_default(disp)

            if self.currclip == 0:
                self2.clipboard.set_text(cumm, len(cumm))
            self.clips[self.currclip] = cumm

        self2.invalidate()
        self2.set_changed(True)
        self2.src_changed = True

    def ctrl_y(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - Y&#34;)

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return

        pedundo.redo(self2, self)

    def ctrl_z(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - Z&#34;)

        if self2.readonly:
            self2.mained.update_statusbar(rostr)
            return
        pedundo.undo(self2, self)

    def ctrl_space(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL - SP&#34;)

        if self2.shift:
            self.add_str(self2, &#34;&amp;nbsp; &#34;)
        else:
            self2.nokey = True
            self2.mained.update_statusbar(&#34;Keyboard disabled.&#34;)


    def f1(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F1&#34;)
        if self2.shift:
            sss = self._getsel(self2)
            self2.mained.update_statusbar(&#34;Opening DEVDOCS help file ...&#34;)
            try:
                #print(&#34;sss&#34;, sss)
                ret = subprocess.Popen([&#34;devdocs&#34;, &#34;-s&#34;, sss,])
            except:
                pedync.message(&#34;\n   Cannot launch devdocs   \n\n&#34;
                               &#34;              (Please install)&#34;)
        else:
            self2.mained.update_statusbar(&#34;Opening KEYS help file ...&#34;)
            kk = get_exec_path(&#34;KEYS&#34;)
            if pedconfig.conf.verbose:
                print(&#34;Pang open&#34;, kk)
            launch_pangview(kk)

    def f2(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F2&#34;)

        if self2.shift:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                pedync.message(&#34;\n   This feature is Linux only   \n\n&#34;
                                   &#34;              ()&#34;)
            else:
                sss = self._getsel(self2)
                self2.mained.update_statusbar(&#34;Opening devhelp file ...&#34;)
                try:
                    ret = subprocess.Popen([&#34;devhelp&#34;, &#34;-s&#34;, sss,])
                    #ret = subprocess.Popen([&#34;gnome-help&#34;,])
                except:
                    pedync.message(&#34;\n   Cannot launch devhelp   \n\n&#34;
                                   &#34;              (Please install)&#34;)
        elif self2.ctrl:
            # System uses it
            pass
        else:
            if platform.system().find(&#34;Win&#34;) &gt;= 0:
                pedync.message(&#34;\n   This feature is Linux only   \n\n&#34;
                                   &#34;              ()&#34;)
            else:
                sss = &#34;python:&#34; + self._getsel(self2)
                self2.mained.update_statusbar(&#34;Opening Zeal with &#39;%s&#39;&#34; % sss)
                try:
                    #print(&#34;sss&#34;, sss)
                    ret = subprocess.Popen([&#34;zeal&#34;, sss,])
                    #ret = subprocess.Popen([&#34;devdocs&#34;, &#34;-s&#34;, sss,])

                except:
                    pedync.message(&#34;\n   Cannot launch zeal \n\n&#34;
                                   &#34;              (Please install)&#34;)

    def f3(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F3&#34;)

        if self2.shift:
            self.f5(self2)
        else:
            self.f6(self2)

    def f4(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F4&#34;)
        #self.play(self2, True)
        try:
            sss = self._getsel(self2)
            ret = subprocess.Popen([&#34;firefox&#34;,
                        &#34;/home/peterglen/pydoc/python-3.8.6rc1-docs-html/index.html&#34; ])
        except:
            pedync.message(&#34;\n   Cannot launch python help  \n\n&#34;
                       &#34;              (Please install)&#34;)

    def f5(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F5&#34;)

        if len(self2.accum) == 0:
            self2.mained.update_statusbar(
                &#34;Please specify a search string (Ctrl-F) or (Alt-S)&#34;)
            return

        self2.mained.update_statusbar(&#34;Locating previous match.&#34;)
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        self2.search_again()
        cnt = len (self2.accum) - 1; match = False
        while True:
            if cnt &lt; 0 : break
            xstr = self2.accum[cnt]

            try:
                bb = xstr.split(&#34; &#34;)[0].split(&#34;:&#34;)
            except: pass
            #print (&#34;TREE sel&#34;, bb)
            # See if match on the same line
            try:
                if int(bb[1]) == yidx:
                    if int(bb[0]) &lt; xidx:
                        self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                        match = True
                        break
                elif int(bb[1]) &lt; yidx:
                    self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                    match = True
                    break
            except:
                pass

            cnt -= 1

        if not match:
            self2.mained.update_statusbar(&#34;At or before first match.&#34;)

    def f6(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F6&#34;)

        if len(self2.accum) == 0:
            self2.mained.update_statusbar(\
                &#34;Please specify a search string (Ctrl-F) or (Alt-S)&#34;)
            return

        self2.mained.update_statusbar(&#34;Locating Next match.&#34;)
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        match = False

        self2.search_again()

        for xstr in self2.accum:
            # Get back numbers the python way
            try:
                bb = xstr.split(&#34; &#34;)[0].split(&#34;:&#34;)
            except: pass
            #-print (&#34;TREE sel&#34;, bb)
            # See if match on the same line
            if int(bb[1]) == yidx:
                if int(bb[0]) &gt; xidx:
                    self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                    match = True
                    break
            elif int(bb[1]) &gt; yidx:
                self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                match = True
                break

        if not match:
            self2.mained.update_statusbar(&#34;At or after last match.&#34;)

    def f7(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F7&#34;)

        pedconfig.conf.keyh.reset()
        if self2.record:
            self2.record = False
            # Nothing recorded, restore old
            if self2.recarr == []:
                self2.mained.update_statusbar(&#34;Nothing recorded, resored old macro.&#34;)
                self2.recarr = self2.recarr2
                pedconfig.conf.recarr = self2.recarr[:]
            else:
                pedconfig.conf.recarr = self2.recarr[:]
                self2.mained.update_statusbar(&#34;Ended recording.&#34;)

        else:
            self2.mained.update_statusbar(&#34;Started recording ...&#34;)
            self2.recarr2 = self2.recarr
            self2.recarr = []
            self2.record = True
        pedconfig.conf.keyh.reset()

    # ---------------------------------------------------------------------

    def play(self, self2, anim = False):

        if self2.record:
            self2.mained.update_statusbar(&#34;Still recording, press F7 to stop&#34;)
            return True

        xlen = len(self2.recarr)
        if xlen == 0:
            # pull in global
            self2.recarr = pedconfig.conf.recarr[:]

        xlen = len(self2.recarr)
        if xlen == 0:
            self2.mained.update_statusbar(&#34;Nothing recorded, cannot play.&#34;)
            return True

        pedconfig.conf.keyh.reset()
        self2.mained.update_statusbar(&#34;Started Play ...&#34;)
        idx = 0
        while True:
            if idx &gt;= xlen: break
            #www,
            tt, kk, ss, sss, \
              pedconfig.conf.keyh.shift, pedconfig.conf.keyh.ctrl, \
                                pedconfig.conf.keyh.alt = self2.recarr[idx]
            idx += 1

            # Synthesize keystroke. We do not replicate state as
            # pyedpro maintains its own internally. (see keyhand.reset())

            ttt = Gdk.EventType.KEY_PRESS
            if tt == 9:
                ttt = Gdk.EventType.KEY_RELEASE

            #print (&#34;playing macro&#34;, tt, kk, ss)
            event = Gdk.EventKey()
            event.type = ttt
            #event.time = time.clock() * 1000
            event.keyval = kk
            #event.window = www
            event.string  = sss
            #print (&#34;play event&#34;, event, event.type, event.keyval)

            pedconfig.conf.keyh.state2 = ss
            pedconfig.conf.keyh.handle_key2(self2, None, event)
            if anim:
                usleep(30)
            #print()
        # If the state gets out or sync ...
        pedconfig.conf.keyh.reset()
        self2.mained.update_statusbar(&#34;Ended Play.&#34;)

    def f8(self, self2, anim = False):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F8&#34;)

        self.play(self2, anim)

    def f9(self, self2, flag = False):
        self2.spell = not self2.spell

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F9 spell&#34;, self2.spell)

        if self2.spell:
            ooo = &#34;on.&#34;
            if self2.shift or flag:
                self2.spellmode = True; ppp = &#34;Mode: text&#34;
            else:
                self2.spellmode = False; ppp = &#34;Mode: code&#34;
        else:
            ooo = &#34;off.&#34;; ppp = &#34;&#34;

        self2.mained.update_statusbar(&#34;Spell checking is %s %s&#34; % (ooo, ppp))
        pedspell.spell(self2, self2.spellmode)

    # This will not be called, as it activates menu
    def f10(self, self2):
        if self2.shift:
            #print (&#34;shift F10&#34;)
            pass
        if self2.ctrl:
            #print (&#34;ctrl F10&#34;)
            pass

    def f11(self, self2):
        if self2.mained.full:
            self2.mained.mywin.unfullscreen()
            self2.mained.full = False
        else:
            self2.mained.mywin.fullscreen()
            self2.mained.full = True
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F11&#34;)


    def f12(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;F12&#34;)

        pass

    # ---------------------------------------------------------------------
    # Add synthesized str

    def add_str(self, self2, strx):

        for aa in strx:
            if aa == &#39;\n&#39;:
                self.ret(self2)
            else:
                #event = Gdk.Event(Gdk.EventType.KEY_PRESS);
                event = Gdk.EventKey()
                event.string  = aa
                event.keyval = ord(aa)
                self.add_key(self2, event)

    #-------------------------------------------------------------------
    # Add regular key

    def add_key(self, self2, event):

        if pedconfig.conf.pgdebug &gt; 4:
            print(&#34;add_key: &#39;%s&#39;&#34; % event.string)

        # CR / LF still haunts us, ignore CR
        if event.keyval == Gdk.KEY_Return:
            #print (&#34;Ignoring Ctrl-Return&#34;)
            return

        if self2.readonly:
            self2.mained.update_statusbar(&#34;This buffer is read only.&#34;)
            return

        if self2.hex:
            self2.mained.update_statusbar(&#34;Cannot edit in hex mode.&#34;)
            return

        # Replace selection
        if self2.xsel != -1:
            #print (&#34;sel replace&#34;)
            #self2.set_caret(self., yidx)
            self.cut(self2, True)

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        # Extend list to accomodate insert
        self.pad_list(self2, yidx)
        # Pad string to accomodate insert
        self.pad_line(self2, xidx, yidx)

        line2 = self2.text[yidx][:]
        #xidx2 = decalc_tabs(line2, self2.caret[0] + self2.xpos, self2.tabstop);
        #print (&#34;before/after&#34;, xidx, xidx2, event.string)

        ccc = &#34;&#34;
        try:
            if event.string != &#34;&#34;:
                ccc = event.string
            else:
                ccc = chr(event.keyval)

            if ord(ccc) &gt; 255:
                #print(&#34;NOT Inserting: &#39;%s&#39; len=%d ord=%d&#34; % (ccc, len(ccc), ord(ccc)) );
                self2.mained.update_statusbar(&#34;Cannot insert char %d&#34; % ord(ccc))
                return


            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
            # Replace selection
            if self2.xsel != -1:
                #print (&#34;sel replace&#34;)
                self.ctrl_x(self2, True)
                line2 = self2.text[yidx][:]

            if self2.insert:
                self2.text[yidx] = line2[:xidx] + ccc + line2[xidx:]
            else:
                self2.text[yidx] = line2[:xidx] + ccc + line2[xidx+1:]

            mlen = len(self2.text[yidx])
            if  mlen &gt; self2.maxlinelen:
                self2.set_maxlinelen(mlen)

            #self2.set_caret(calc_tabs(self2.text[yidx], xidx + 1), yidx)
            self2.set_caret(xidx + 1, yidx)

            if self2.acorr:
                # See if autocorrect is needed
                for acs, acs2 in auto_corr_table:
                    lendiff = len(acs2) - len(acs)
                    ss = self2.text[yidx][xidx-(len(acs)-1):xidx+1]
                    if ss == acs:
                        xstr =  &#34;Autocorrected to &#34;&#39;&#34;%s&#34;&#39;&#34;&#34; % acs2
                        self2.mained.update_statusbar(xstr)
                        line = self2.text[yidx]
                        self2.text[yidx] = line[:xidx-(len(acs)-1)] + \
                                            acs2 + line[xidx+1:]
                        #self2.set_caret(calc_tabs(self2.text[yidx], \
                        #    xidx + lendiff, sel2.tabstop), yidx)
                        self2.set_caret(xidx + lendiff + 1, yidx)

            # See if token is complete (disabled by default)
            &#39;&#39;&#39;
            if ccc == &#34; &#34;:
                line = self2.text[yidx]
                begs, ends = selword(line, xidx - 1)
                if ends - begs &gt;= 4:
                    #print (&#34;token complete&#34;, line[begs:ends])
                    # Limit size of token stack
                    if len(self2.tokens) &gt; 10:
                        del(self2.tokens[0])
                    self2.tokens.append(line[begs:ends])
                    #print (self2.tokens)

            # See if token completion is needed
            line = self2.text[yidx]
            idx = prevchar(line, &#34; &#34;, xidx - 1)
            word = line[idx+1:xidx+1]
            #print (&#34;word&#34;, word)
            for aa in self2.tokens:
                lendiff = len(aa) - len(word)
                #print (&#34;src&#34;,  aa[:len(aa) / 2])
                if aa[:len(aa) / 2] == word:
                    #print (&#34;completion&#34;, aa)
                    self2.text[yidx] = line[:idx+1] + aa + line[xidx+1:]
                    tmp = calc_tabs(self2.text[yidx], xidx + lendiff, self2.tabstop)
                    self2.set_caret(tmp, yidx)
                    xstr =  &#34;Autocompleted to &#34;&#39;&#34;%s&#34;&#39;&#34;&#34; % aa
                    self2.mained.update_statusbar(xstr)&#39;&#39;&#39;

            &#39;&#39;&#39;

            # See if spell checking needed
            if ccc == &#34; &#34;:
                #err = pedspell.spell_line(line, 0, len(line))
                #self2.ularr = []
                #for ss, ee in err:
                #    self2.ularr.append((ss, yidx, ee))
                self2.invalidate()    &#39;&#39;&#39;

            self2.inval_line()
            self2.set_changed(True)
            self2.src_changed = True

        except:
            # Could not convert it to character, alert user
            # Usualy unhandled control, so helps developmet
            print  (&#34;Other key&#34;, sys.exc_info(), event.keyval)
            if(pedconfig.conf.verbose):
                print(&#34;Other key&#34;, event.keyval, \
                    hex(event.keyval), hex(event.state))
            pass
        return True

    def super_a(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;SUPER - A&#34;)
        self.alt_a(self2)

    def super_b(self, self2):
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;SUPER - B&#34;)
        self.alt_b(self2)

    # --------------------------------------------------------------
    # Tab handle is awkward. The regular key tab will insert
    # spaces to the next multiple of four.
    # To insert a real tab, use shift tab  (like for Makefiles)

    def tab(self, self2):

        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos

        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;TAB&#34;, self2.shift)

        #tabstop = 4
        tabstop = self2.tabstop
        self.pad_list(self2, yidx)

        # No Selection, do tab
        if self2.ysel == -1:
            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
            if self2.shift:
                line2 = self2.text[yidx][:]
                self2.text[yidx] = line2[:xidx] + &#34;\t&#34; + line2[xidx:]
                spaces = self2.tabstop - (xidx % self2.tabstop)
                self2.set_caret(xidx+1, yidx)

                #print (&#34;shif tab&#34;, spaces)
                #self2.set_caret(xidx + tabstop, yidx)
            else:
                spaces = tabstop - (xidx % tabstop)
                while spaces:
                    #event = Gdk.Event(Gdk.EventType.KEY_PRESS);
                    event = Gdk.EventKey()
                    event.string  = &#34; &#34;
                    event.keyval = ord(&#34; &#34;)
                    self.add_key(self2, event)
                    spaces -= 1
            self2.invalidate()
            self2.set_changed(True)
        else:
            # Indent, normalize
            yssel = min(self2.ysel, self2.ysel2)
            yesel = max(self2.ysel, self2.ysel2)
            #print (&#34;TAB in sel&#34;)
            cnt = yssel
            self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
            if self2.shift:
                while True:
                    if cnt &gt; yesel: break
                    self2.undoarr.append((xidx, cnt, \
                            pedundo.MODIFIED | pedundo.CONTFLAG, self2.text[cnt]))
                    self2.text[cnt] =  rmlspace(self2.text[cnt], 4)
                    cnt += 1
            else:
                while True:
                    if cnt &gt; yesel: break
                    self2.undoarr.append((xidx, cnt, \
                        pedundo.MODIFIED | pedundo.CONTFLAG, self2.text[cnt]))
                    self2.text[cnt] = &#34;    &#34; + self2.text[cnt]
                    cnt += 1
            self2.invalidate()
            self2.set_changed(True)

    def xclip_cb(self, self2, ctext, cummx):
        cummx = ctext + cummx
        self2.clipboard.set_text(cummx, len(cummx))
        #self2.clipboard.request_text(self.xclip_cb, cumm)
        ttt = self2.clipboard.wait_for_text()
        self.clip_cb(none, ttt, self2)

    # EOF</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>acthand2.ActHand2</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="acthand.ActHand.add_key"><code class="name flex">
<span>def <span class="ident">add_key</span></span>(<span>self, self2, event)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_key(self, self2, event):

    if pedconfig.conf.pgdebug &gt; 4:
        print(&#34;add_key: &#39;%s&#39;&#34; % event.string)

    # CR / LF still haunts us, ignore CR
    if event.keyval == Gdk.KEY_Return:
        #print (&#34;Ignoring Ctrl-Return&#34;)
        return

    if self2.readonly:
        self2.mained.update_statusbar(&#34;This buffer is read only.&#34;)
        return

    if self2.hex:
        self2.mained.update_statusbar(&#34;Cannot edit in hex mode.&#34;)
        return

    # Replace selection
    if self2.xsel != -1:
        #print (&#34;sel replace&#34;)
        #self2.set_caret(self., yidx)
        self.cut(self2, True)

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    # Extend list to accomodate insert
    self.pad_list(self2, yidx)
    # Pad string to accomodate insert
    self.pad_line(self2, xidx, yidx)

    line2 = self2.text[yidx][:]
    #xidx2 = decalc_tabs(line2, self2.caret[0] + self2.xpos, self2.tabstop);
    #print (&#34;before/after&#34;, xidx, xidx2, event.string)

    ccc = &#34;&#34;
    try:
        if event.string != &#34;&#34;:
            ccc = event.string
        else:
            ccc = chr(event.keyval)

        if ord(ccc) &gt; 255:
            #print(&#34;NOT Inserting: &#39;%s&#39; len=%d ord=%d&#34; % (ccc, len(ccc), ord(ccc)) );
            self2.mained.update_statusbar(&#34;Cannot insert char %d&#34; % ord(ccc))
            return


        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
        # Replace selection
        if self2.xsel != -1:
            #print (&#34;sel replace&#34;)
            self.ctrl_x(self2, True)
            line2 = self2.text[yidx][:]

        if self2.insert:
            self2.text[yidx] = line2[:xidx] + ccc + line2[xidx:]
        else:
            self2.text[yidx] = line2[:xidx] + ccc + line2[xidx+1:]

        mlen = len(self2.text[yidx])
        if  mlen &gt; self2.maxlinelen:
            self2.set_maxlinelen(mlen)

        #self2.set_caret(calc_tabs(self2.text[yidx], xidx + 1), yidx)
        self2.set_caret(xidx + 1, yidx)

        if self2.acorr:
            # See if autocorrect is needed
            for acs, acs2 in auto_corr_table:
                lendiff = len(acs2) - len(acs)
                ss = self2.text[yidx][xidx-(len(acs)-1):xidx+1]
                if ss == acs:
                    xstr =  &#34;Autocorrected to &#34;&#39;&#34;%s&#34;&#39;&#34;&#34; % acs2
                    self2.mained.update_statusbar(xstr)
                    line = self2.text[yidx]
                    self2.text[yidx] = line[:xidx-(len(acs)-1)] + \
                                        acs2 + line[xidx+1:]
                    #self2.set_caret(calc_tabs(self2.text[yidx], \
                    #    xidx + lendiff, sel2.tabstop), yidx)
                    self2.set_caret(xidx + lendiff + 1, yidx)

        # See if token is complete (disabled by default)
        &#39;&#39;&#39;
        if ccc == &#34; &#34;:
            line = self2.text[yidx]
            begs, ends = selword(line, xidx - 1)
            if ends - begs &gt;= 4:
                #print (&#34;token complete&#34;, line[begs:ends])
                # Limit size of token stack
                if len(self2.tokens) &gt; 10:
                    del(self2.tokens[0])
                self2.tokens.append(line[begs:ends])
                #print (self2.tokens)

        # See if token completion is needed
        line = self2.text[yidx]
        idx = prevchar(line, &#34; &#34;, xidx - 1)
        word = line[idx+1:xidx+1]
        #print (&#34;word&#34;, word)
        for aa in self2.tokens:
            lendiff = len(aa) - len(word)
            #print (&#34;src&#34;,  aa[:len(aa) / 2])
            if aa[:len(aa) / 2] == word:
                #print (&#34;completion&#34;, aa)
                self2.text[yidx] = line[:idx+1] + aa + line[xidx+1:]
                tmp = calc_tabs(self2.text[yidx], xidx + lendiff, self2.tabstop)
                self2.set_caret(tmp, yidx)
                xstr =  &#34;Autocompleted to &#34;&#39;&#34;%s&#34;&#39;&#34;&#34; % aa
                self2.mained.update_statusbar(xstr)&#39;&#39;&#39;

        &#39;&#39;&#39;

        # See if spell checking needed
        if ccc == &#34; &#34;:
            #err = pedspell.spell_line(line, 0, len(line))
            #self2.ularr = []
            #for ss, ee in err:
            #    self2.ularr.append((ss, yidx, ee))
            self2.invalidate()    &#39;&#39;&#39;

        self2.inval_line()
        self2.set_changed(True)
        self2.src_changed = True

    except:
        # Could not convert it to character, alert user
        # Usualy unhandled control, so helps developmet
        print  (&#34;Other key&#34;, sys.exc_info(), event.keyval)
        if(pedconfig.conf.verbose):
            print(&#34;Other key&#34;, event.keyval, \
                hex(event.keyval), hex(event.state))
        pass
    return True</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.add_str"><code class="name flex">
<span>def <span class="ident">add_str</span></span>(<span>self, self2, strx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_str(self, self2, strx):

    for aa in strx:
        if aa == &#39;\n&#39;:
            self.ret(self2)
        else:
            #event = Gdk.Event(Gdk.EventType.KEY_PRESS);
            event = Gdk.EventKey()
            event.string  = aa
            event.keyval = ord(aa)
            self.add_key(self2, event)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.bottom"><code class="name flex">
<span>def <span class="ident">bottom</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bottom(self, self2):

    self.was_end = 0
    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    self2.xsel2 = self2.caret[0] + self2.xpos
    self2.ysel2 = self2.caret[1] + self2.ypos
    last = len(self2.text) - 1
    xlen = len(self2.text[last])
    self2.set_caret(xlen, last)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.bs"><code class="name flex">
<span>def <span class="ident">bs</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bs(self, self2):

    if self2.readonly:
        self2.mained.update_statusbar(rostr)
        return

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    # Delete selection
    if self2.xsel != -1:
        #print (&#34;sel del&#34;)
        self.cut(self2, True)
        self2.xsel = -1
    else:
        if xidx &gt; 0:
            line = self2.text[yidx][:]
            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
            self2.text[yidx] = line[:xidx - 1] + line[xidx:]
            self2.set_caret(xidx - 1, yidx)
            self2.inval_line()
        else:                                   # Move line up
            if yidx &gt; 0:
                if yidx &lt; len(self2.text):      # Any text?
                    self2.undoarr.append((xidx, yidx-1, \
                            pedundo.MODIFIED, self2.text[yidx-1]))
                    line = self2.text[yidx][:]
                    lenx = len(self2.text[yidx-1])
                    self2.text[yidx-1] += line
                    self2.set_caret(lenx, yidx-1)
                    self2.undoarr.append(\
                            (xidx, yidx, pedundo.DELETED + pedundo.CONTFLAG, \
                                    self2.text[yidx]))
                    del (self2.text[yidx])
                    self2.invalidate()
                else:                           # Just update cursor
                    self2.set_caret(xidx, yidx-1)

    self2.set_changed(True)
    self2.src_changed = True</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.clip_cb"><code class="name flex">
<span>def <span class="ident">clip_cb</span></span>(<span>self, clip, text, self2, boundary=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clip_cb(self, clip, text, self2, boundary = True ):

    if pedconfig.conf.verbose:
        print (&#34;Clipboard: &#39;&#34; + text + &#34;&#39;&#34;, self2.caret[1], self2.ypos)

    try:
        if type(text) != str:
            text = codecs.decode(text)
            #print (&#34;string is UTF-8, length %d bytes&#34; % len(text2))
        else:
            pass
            #print (&#34;string is text, length %d bytes&#34; % len(text2))

    except UnicodeError:
        print (&#34;string is not UTF-8&#34;)
        #return xx, yy

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    # Replace selection
    if self2.xsel != -1:
        #print (&#34;sel replace&#34;)
        #self2.set_caret(self., yidx)
        self.cut(self2, True)

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    cnt = yidx; cc = &#34;&#34;; ttt = str.split(text, &#34;\n&#34;)

    if self2.colsel:
        if boundary:
            self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
        for aa in ttt:
            self.pad_list(self2, yidx)
            line = self2.text[yidx]
            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED  + pedundo.CONTFLAG, \
                             self2.text[yidx]))
            if xidx &gt; len(line):        # pad line
                line +=  genstr(&#34; &#34;, xidx - len(line))
            self2.text[yidx] = line[:xidx] + aa + line[xidx:]
            self2.gotoxy(xidx, yidx)
            yidx += 1
    else:
        if len(ttt) == 1:               # single line
            if boundary:
               self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
            self.pad_list(self2, yidx)
            line = self2.text[int(yidx)]
            self2.undoarr.append((xidx, yidx, pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[yidx]))
            if xidx &gt; len(line):        # pad line
                line +=  genstr(&#34; &#34;, xidx - len(line))
            self2.text[yidx] = line[:xidx] + ttt[0] + line[xidx:]
            self2.gotoxy(xidx+len(ttt[0]), yidx)
        else:
            if boundary:
                self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
            for aa in ttt:
                self.pad_list(self2, cnt)
                if cnt == yidx :            # first line
                    line = self2.text[yidx]
                    if xidx &gt; len(line):    # pad line
                        line += genstr(&#34; &#34;, xidx - len(line))
                    self2.undoarr.append((xidx, yidx, \
                        pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[yidx]))
                    bb  =  line[:xidx] + aa
                    cc = line[xidx:]
                    self2.text[yidx] = bb
                else:
                    self2.undoarr.append((xidx, cnt, pedundo.ADDED + pedundo.CONTFLAG,\
                                    self2.text[cnt]))
                    text2 = self2.text[:cnt]
                    text2.append(aa)
                    text2 += self2.text[cnt:]
                    self2.text = text2
                cnt += 1
            #last line:
            self2.undoarr.append((xidx, cnt-1, pedundo.MODIFIED + pedundo.CONTFLAG,\
                 self2.text[cnt-1]))
            text2 = self2.text[cnt-1]
            self2.text[cnt-1] = text2 + cc
            self2.gotoxy(len(text2), yidx + len(ttt)-1)

    mlen = self2.calc_maxline()
    self2.set_maxlinelen(mlen, False)

    #self2.set_maxlines(len(self2.text), False)

    self2.set_changed(True)
    self2.src_changed = True
    self2.invalidate()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_a"><code class="name flex">
<span>def <span class="ident">ctrl_a</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_a(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL -- A&#34;)

    if self2.shift:
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        line = self2.text[yidx]
        self2.gotoxy(0, yidx)
        self2.mained.update_statusbar(&#34;Goto beginning of line.&#34;)
    else:
        self2.xsel = 0; self2.ysel = 0
        self2.ysel2 = len(self2.text)
        self2.xsel2 = self2.maxlinelen
        self2.set_caret(self2.maxlinelen,  len(self2.text))
        self2.invalidate()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_b"><code class="name flex">
<span>def <span class="ident">ctrl_b</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_b(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL -- B&#34;)

    if self2.shift:
        sss = self._getsel(self2)
        #print(&#34;sel&#34;, sss)
        self.add_str(self2, &#34;&lt;b&gt;&#34; + sss + &#34;&lt;/b&gt;&#34;)

    else:
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        line = self2.text[yidx]
        bb, ee = selword(line, xidx)
        if bb != ee:
            self2.xsel = bb; self2.xsel2 =  ee
            self2.ysel = self2.ysel2 = yidx
            self2.gotoxy(self2.xsel2, self2.ysel)
        else:
            self2.mained.update_statusbar(&#34;Please navigate to word.&#34;)

    self2.invalidate()
    #self2.set_changed(True)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_c"><code class="name flex">
<span>def <span class="ident">ctrl_c</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_c(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - C&#34;)

    if self2.xsel == -1 or  self2.ysel == -1:
        #self2.mained.update_statusbar(&#34;Nothing selected, copying line.&#34;)
        self2.mained.update_statusbar(&#34;Nothing selected, refuse to copy.&#34;)
        return

    cumm = self._getsel(self2)
    if self.currclip == 0:
        if self2.shift:
            self2.mained.update_statusbar(&#34;Clipboard appended.&#34;)
            ttt = self2.clipboard.wait_for_text() + cumm
            self2.clipboard.set_text(ttt, len(ttt))
        else:
            self2.mained.update_statusbar(&#34;Clipboard copied.&#34;)
            self2.clipboard.set_text(cumm, len(cumm))
    else:
        if self2.shift:
            self2.mained.update_statusbar(&#34;Clipboard %d appended.&#34; % self.currclip)
            self.clips[self.currclip] += cumm
        else:
            self2.mained.update_statusbar(&#34;Clipboard %d copied.&#34; % self.currclip)
            self.clips[self.currclip] = cumm</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_d"><code class="name flex">
<span>def <span class="ident">ctrl_d</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_d(self, self2):
    if self2.shift:
        dt = datetime.datetime(1990, 1, 1);
        dt2 = dt.now()
        strx2 =  dt2.strftime(&#34;%a %d.%b.%Y&#34;)
        self.add_str(self2, strx2)
    else:
        #print (&#34;CTRL - D&#34;)
        xidx = self2.caret[0] + self2.xpos;
        cnt = 0; cnt2 = 0; zlen = len(self2.text)
        while True:
            if cnt &gt;= zlen: break
            line = self2.text[cnt];  xlen = len(line)
            if xlen and line[xlen-1] == &#34; &#34;:
                self2.undoarr.append((xidx, cnt, pedundo.MODIFIED, self2.text[cnt]))
                self2.text[cnt] = line.rstrip()
                cnt2 += 1
            cnt += 1

        self2.mained.update_statusbar(&#34;Trimmed %d lines.&#34; % cnt2)

        if cnt2 &gt; 0:
            self2.set_changed(True)

    self2.invalidate()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_e"><code class="name flex">
<span>def <span class="ident">ctrl_e</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_e(self, self2):

    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - E&#34;)

    if self2.shift:
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        line = self2.text[yidx]
        self2.gotoxy(len(line), yidx)
        self2.mained.update_statusbar(&#34;Goto end of line.&#34;)
    else:
        xidx = self2.caret[0] + self2.xpos;
        yidx = self2.caret[1] + self2.ypos
        line = self2.text[yidx]
        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))

        cntb, cnte = selword(line, xidx)
        wlow = line[cntb:cnte].capitalize()
        #print (&#34;word   &#39;&#34; + line[cntb:cnte] + &#34;&#39;&#34;, wlow)
        self2.text[yidx] = line[:cntb] + wlow + line[cnte:]
        self2.set_changed(True)
        self2.inval_line()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_f"><code class="name flex">
<span>def <span class="ident">ctrl_f</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_f(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - F&#34;)

    if self2.shift:
        self.add_str(self2, &#34;&lt;tr&gt;&lt;td&gt;&#34;)
    else:
        self2.find(self);</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_g"><code class="name flex">
<span>def <span class="ident">ctrl_g</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_g(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - G&#34;)

    #self2.closedoc()
    if self2.shift:
        self.f5(self2)
    else:
        self.f6(self2)
    pass</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_h"><code class="name flex">
<span>def <span class="ident">ctrl_h</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_h(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - H&#34;)

    self2.ctrl = False
    self2.alt = False
    self.left(self2)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_i"><code class="name flex">
<span>def <span class="ident">ctrl_i</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_i(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - I&#34;)


    if self2.shift and self2.countup:
        self2.countup = 0
    else:
        strx = &#34;%d&#34; % self2.countup
        for aa in strx:
            #event = Gdk.Event(Gdk.EventType.KEY_PRESS);
            event = Gdk.EventKey()
            event.string  = aa
            event.keyval = ord(aa)
            self.add_key(self2, event)
        self2.countup += 1</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_j"><code class="name flex">
<span>def <span class="ident">ctrl_j</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_j(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - J&#34;)

    self2.ctrl = False
    self2.alt = False
    self.down(self2)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_k"><code class="name flex">
<span>def <span class="ident">ctrl_k</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_k(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - K&#34;)

    self2.ctrl = False

    self2.alt = False
    self.up(self2)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_l"><code class="name flex">
<span>def <span class="ident">ctrl_l</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_l(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - L&#34;)

    self2.ctrl = False
    self2.alt = False
    self.right(self2)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_m"><code class="name flex">
<span>def <span class="ident">ctrl_m</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_m(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - M&#34;)

    if self2.shift:
        self2.mained.update_statusbar(&#34;Popped right click menu.&#34;)
        self2.poprclick(self2, None)
    else:
        self2.acorr = not self2.acorr
        if self2.acorr:
            self2.mained.update_statusbar(\
                &#34;Autocorrect is on with %d enties.&#34; % len(auto_corr_table))
        else:
            self2.mained.update_statusbar(&#34;Autocorrect is off.&#34;)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_n"><code class="name flex">
<span>def <span class="ident">ctrl_n</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_n(self, self2):
    if 1: #pedconfig.conf.pgdebug &gt; 4:
        print (&#34;Warning: got CTRL - N Main menu did not interpret it.&#34;, self2.shift)
        self2.mained.newfile()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_num"><code class="name flex">
<span>def <span class="ident">ctrl_num</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_num(self, self2):
    kkk = self2.curr_event.keyval - Gdk.KEY_0
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL -- num, key=&#34;, kkk)

    # Process clip 9 -- sum it all
    if kkk == 9:
        self.clips[kkk] = &#34;&#34;
        # This sums all clipboards, puts it into 9
        for aa in range(8):
            self.clips[kkk] += self.clips[aa]

    self.ctrl_num_clip(self2, kkk)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_num_clip"><code class="name flex">
<span>def <span class="ident">ctrl_num_clip</span></span>(<span>self, self2, num)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_num_clip(self, self2, num):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL -- &#34;, num)

    self2.mained.update_statusbar(&#34;Switched to clipboard %d.&#34; % num)
    self.currclip = num
    #print (&#34;current&#34;, self.clips[self.currclip])
    #for aa in range(len(self.clips)):
    #    print (aa, self.clips[aa])
    self2.invalidate()
    self2.update_bar2()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_o"><code class="name flex">
<span>def <span class="ident">ctrl_o</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_o(self, self2):
    if 1: #pedconfig.conf.pgdebug &gt; 4:
        print (&#34;Warning: got CTRL - O Main menu did not interpret it.&#34;, &#34;shift=&#34;, self2.shift)
    pass
    if self2.shift:
        load_sess()
    else:
        self2.mained.open()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_p"><code class="name flex">
<span>def <span class="ident">ctrl_p</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_p(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - P&#34;)
    pass

    self2.save()
    conn = cups.Connection()
    printers = conn.getPrinters()
    if not printers:
        pedync.message(&#34;\n   No printer detected  \n\n&#34;)
        return

    #for printer in printers:
    #    print (printer, printers[printer][&#34;device-uri&#34;])

    #print(&#34;printers&#34;, printers, &#34;key&#34;, printers.keys())
    if  printers.keys():
        printer_names = list(printers.keys())
        #print(&#34;printer_name&#34;, printer_names[0])
        shortname = os.path.basename(self2.fname)
        try:
            conn.printFile(printer_names[0], self2.fname, &#34;pyedpro&#34;,  {}, )
            #print(&#34;printing&#34;, self2.fname)
            self2.mained.update_statusbar(&#34;File &#39;%s&#39; sent to printer.&#34;
                                                            % shortname )
        except:
            pedync.message(&#34;\n   Cannot print  &#39;%s&#39;\n\n&#34; % shortname)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_q"><code class="name flex">
<span>def <span class="ident">ctrl_q</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_q(self, self2):
    if 1: #pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - Q&#34;)
    pass</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_r"><code class="name flex">
<span>def <span class="ident">ctrl_r</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_r(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - R&#34;)

    if self2.shift:
        if pedconfig.conf.pgdebug &gt; 4:
            print (&#34;CTRL-SHIFT - R&#34;)
        self2.start_m4filter()
        return

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos
    line = self2.text[yidx]
    self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))

    cntb, cnte = selword(line, xidx)
    if cntb == cnte:
          self2.mained.update_statusbar(&#34;Please nav to a word first.&#34;)
          return
    w1 = line[cntb:cnte]
    #print (&#34;word1&#34;, w1)

    idx = xnextchar(line, &#34; &#34;, cnte)
    cntb2, cnte2 = selword(line, idx)
    if cntb2 == cnte2:
          self2.mained.update_statusbar(&#34;No second word on line.&#34;)
          return
    w2 = line[cntb2:cnte2]
    #print (&#34;word2&#34;, w2)

    idx2 = xnextchar(line, &#34; &#34;, cnte2)
    cntb3, cnte3 = selword(line, idx2)
    if cntb3 == cnte3:
          self2.mained.update_statusbar(&#34;No third word on line.&#34;)
          return
    w3 = line[cntb3:cnte3]
    #print (&#34;word3&#34;, w3)

    self2.text[yidx] = line[:cntb] + \
            w3 + &#34; &#34; + w2 + &#34; &#34; + w1 + line[cnte3:]
    self2.inval_line()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_s"><code class="name flex">
<span>def <span class="ident">ctrl_s</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_s(self, self2):

    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - S&#34;)
    self2.save()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_space"><code class="name flex">
<span>def <span class="ident">ctrl_space</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_space(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - SP&#34;)

    if self2.shift:
        self.add_str(self2, &#34;&amp;nbsp; &#34;)
    else:
        self2.nokey = True
        self2.mained.update_statusbar(&#34;Keyboard disabled.&#34;)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_t"><code class="name flex">
<span>def <span class="ident">ctrl_t</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_t(self, self2):

    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - T&#34;)

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos
    line = self2.text[yidx]

    if self2.shift:
        dt = datetime.datetime(1990, 1, 1);
        dt2 = dt.now()
        strx2 =  dt2.strftime(&#34;%d/%m/%y %H:%M:%S &#34;)
        self.add_str(self2, strx2)
    else:
        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))

        cntb, cnte = selword(line, xidx)
        if cntb == cnte:
              self2.mained.update_statusbar(&#34;Please nav to a word first.&#34;)
              return
        w1 = line[cntb:cnte]
        #print (&#34;word1&#34;, w1)

        idx = xnextchar(line, &#34; &#34;, cnte)
        cntb2, cnte2 = selword(line, idx)
        if cntb2 == cnte2:
              self2.mained.update_statusbar(&#34;No second word on line.&#34;)
              return
        w2 = line[cntb2:cnte2]
        #print (&#34;word2&#34;, w2)

        self2.text[yidx] = line[:cntb] + w2 + &#34; &#34; + w1 + line[cnte2:]
        self2.inval_line()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_tab"><code class="name flex">
<span>def <span class="ident">ctrl_tab</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_tab(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;ctrl_tab&#34;)

    if self2.shift:
        self2.mained.prevwin()
    else:
        self2.mained.nextwin()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_u"><code class="name flex">
<span>def <span class="ident">ctrl_u</span></span>(<span>self, self2, lowit=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_u(self, self2, lowit = False):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - U&#34;)

    #line = &#34;&#34;; xidx = 0; yidx = 0
    # No selection, assume word
    if self2.xsel == -1 or self2.ysel == -1:
        xidx = self2.caret[0] + self2.xpos
        yidx = self2.caret[1] + self2.ypos
        line = self2.text[yidx]
        #cntb, cnte = selword(line, xidx)
        cntb, cnte = selasci2(line, xidx, &#34;_-&#34;)
    else:
        # Normalize
        xssel = min(self2.xsel, self2.xsel2)
        xesel = max(self2.xsel, self2.xsel2)
        yssel = min(self2.ysel, self2.ysel2)
        yesel = max(self2.ysel, self2.ysel2)

        xidx = xssel; yidx = yssel;
        line = self2.text[yidx]
        cntb = xssel; cnte = xesel

    if cnte == cntb:
        self2.mained.update_statusbar(&#34;Please nav to a word first.&#34;)
        return

    self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, line))
    #print (&#34;word / selection&#34;, line[cntb:cnte])

    if self2.shift or lowit:
        wlow = line[cntb:cnte].lower()
    else:
        wlow = line[cntb:cnte].upper()

    self2.text[yidx] = line[:cntb] + wlow + line[cnte:]
    self2.set_changed(True)
    self2.inval_line()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_v"><code class="name flex">
<span>def <span class="ident">ctrl_v</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_v(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - V&#34;)

    if self2.readonly:
        self2.mained.update_statusbar(rostr)
        return

    #clip = Gtk.Clipboard()
    #disp2 = Gdk.Display()
    #disp = disp2.get_default()
    #clip = Gtk.Clipboard.get_default(disp)

    if self.currclip == 0:
        # Blew up on the Mac
        #self2.clipboard.request_text(self.clip_cb, self2)
        ttt = self2.clipboard.wait_for_text()
        #print(&#34;got paste&#34;, ttt)
        self.clip_cb(None, ttt,  self2)
    else:
        #self.clip_cb(clip, self.clips[self.currclip], self2)
        self.clip_cb(None, self.clips[self.currclip], self2)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_w"><code class="name flex">
<span>def <span class="ident">ctrl_w</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_w(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - W&#34;)

    if self2.shift:
        self2.mained.closeall()
    else:
        self2.mained.close_document()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_x"><code class="name flex">
<span>def <span class="ident">ctrl_x</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_x(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - X&#34;)

    if self2.readonly:
        self2.mained.update_statusbar(rostr)
        return

    self.cut(self2)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_y"><code class="name flex">
<span>def <span class="ident">ctrl_y</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_y(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - Y&#34;)

    if self2.readonly:
        self2.mained.update_statusbar(rostr)
        return

    pedundo.redo(self2, self)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ctrl_z"><code class="name flex">
<span>def <span class="ident">ctrl_z</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ctrl_z(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;CTRL - Z&#34;)

    if self2.readonly:
        self2.mained.update_statusbar(rostr)
        return
    pedundo.undo(self2, self)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.cut"><code class="name flex">
<span>def <span class="ident">cut</span></span>(<span>self, self2, fake=False, boundary=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cut(self, self2, fake = False, boundary = True):
    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    if self2.xsel == -1 or  self2.ysel == -1:
        self2.mained.update_statusbar(&#34;Nothing selected&#34;)
        return

    if self2.colsel:
        # Normalize
        xssel = min(self2.xsel, self2.xsel2)
        xesel = max(self2.xsel, self2.xsel2)
        yssel = min(self2.ysel, self2.ysel2)
        yesel = max(self2.ysel, self2.ysel2)
    else:
        if self2.ysel &lt; self2.ysel2:
            yssel = self2.ysel
            yesel = self2.ysel2
            xssel = self2.xsel
            xesel = self2.xsel2
        elif self2.ysel == self2.ysel2:
            yssel = self2.ysel
            yesel = self2.ysel2
            xssel = min(self2.xsel, self2.xsel2)
            xesel = max(self2.xsel, self2.xsel2)
        else:
            yssel = self2.ysel2
            yesel = self2.ysel
            xssel = self2.xsel2
            xesel = self2.xsel

    #print (xssel, xesel, yssel, yesel)

    #  undo (grouping stops)
    if boundary:
        self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))

    cnt = yssel; cnt2 = 0; cumm = &#34;&#34;; darr = []
    while True:
        if cnt &gt; yesel: break
        xidx = self2.caret[0] + self2.xpos
        #yidx = self2.caret[1] + self2.ypos
        self.pad_list(self2, cnt)
        line = self2.text[int(cnt)]
        if self2.colsel:
            self2.undoarr.append((xidx, cnt, \
                pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[int(cnt)]))
            frag = line[xssel:xesel]
            self2.text[int(cnt)] = line[:int(xssel)] + line[int(xesel):]
        else:
            self2.undoarr.append((xssel, cnt, \
                pedundo.MODIFIED + pedundo.CONTFLAG, self2.text[int(cnt)]))
            if cnt == yssel and cnt == yesel:   # Selection on one line
                frag = line[int(xssel):int(xesel)]
                self2.text[int(cnt)] = line[:int(xssel)] + line[int(xesel):]
                #if xssel == 0:
                #    darr.append(cnt)
            elif cnt == yssel:                  # On start line
                sline = cnt
                frag = line[int(xssel):]
                self2.text[int(cnt)] = line[:int(xssel)]
                #if xssel == 0:
                #    darr.append(int(cnt))
            elif cnt == yesel:                  # On end line
                frag = line[:int(xesel)]
                self2.text[int(sline)] = self2.text[int(sline)] + line[int(xesel):]
                darr.append(cnt)
            else:                               # On selected line
                frag = line[:]
                #self2.text[cnt] = &#34;&#34;
                darr.append(cnt)

        if cnt2: frag = &#34;\n&#34; + frag
        cumm += frag
        cnt += 1; cnt2 += 1

    #print (&#34;clip x: &#39;&#34;, cumm, &#34;&#39;&#34;)

    # Delete from the end to the beginning
    darr.reverse()
    for aa in darr:
        self2.undoarr.append((xidx, aa, \
            pedundo.DELETED + pedundo.CONTFLAG, self2.text[aa]))
        #print (&#34;del&#34;, aa)
        del(self2.text[aa])

    self2.mained.update_statusbar(&#34;Cut %d lines&#34; % (yesel - yssel))

    self2.clearsel()
    self2.gotoxy(xssel, yssel)

    # We use this for deleting as well, so fake clip op
    if not fake:
        #clip = Gtk.Clipboard()
        #disp2 = Gdk.Display()
        #disp = disp2.get_default()
        #clip = Gtk.Clipboard.get_default(disp)

        if self.currclip == 0:
            self2.clipboard.set_text(cumm, len(cumm))
        self.clips[self.currclip] = cumm

    self2.invalidate()
    self2.set_changed(True)
    self2.src_changed = True</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, self2):

    if self2.readonly:
        self2.mained.update_statusbar(rostr)
        return

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    # Delete selection
    if self2.xsel != -1:
        #print (&#34;sel del&#34;)
        self.cut(self2, True)
    else:
        xlen = len(self2.text[yidx])
        if xlen:
            line = self2.text[yidx][:]
            if xidx &gt;= xlen:     # bring in line from below
                self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, \
                    self2.text[yidx]))
                self2.text[yidx] += genstr(&#34; &#34;, xidx-xlen)
                self2.text[yidx] += self2.text[yidx+1][:]
                self2.undoarr.append((xidx, yidx+1, \
                    pedundo.DELETED + pedundo.CONTFLAG, self2.text[yidx+1]))
                del (self2.text[yidx+1])
                self2.invalidate()
            else:               # remove char
                self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, \
                        self2.text[yidx]))
                self2.text[yidx] = line[:xidx] + line[xidx+1:]
                self2.set_caret(xidx, yidx)
                self2.inval_line()
        else:
            del (self2.text[yidx])

    self2.xsel = -1
    self2.set_changed(True)
    self2.src_changed = True
    self2.invalidate()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.down"><code class="name flex">
<span>def <span class="ident">down</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def down(self, self2):

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos
    incr = 1
    if self2.ctrl:
        incr = 10
    elif self2.alt:
        self.pgdn(self2)
    elif self2.shift:
        # Begin select
        if self2.xsel == -1:
            self2.xsel = xidx
            self2.xsel2 = xidx
            self2.colsel = False
        if self2.ysel == -1:
            self2.ysel = yidx

    self2.set_caret(xidx, yidx + incr)

    if self2.shift:
        self2.ysel2 = self2.caret[1] + self2.ypos
        self2.invalidate()
    else:
        self2.clearsel()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self, self2):

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    #//if self2.shift:
    #//    # Begin select
    #//    if self2.xsel == -1:
    #//        self2.xsel = xidx
    #//    if self2.ysel == -1:
    #//        self2.ysel = yidx

    if self2.alt:
        #print (&#34;alt-end&#34;)
        self2.mained.lastwin()
        pass
    elif self2.ctrl:
        self.bottom(self2)
        self2.invalidate()
    elif self2.shift:
        # Begin select
        if self2.xsel == -1:
            self2.xsel = self2.caret[0]  + self2.xpos
        if self2.ysel == -1:
            self2.ysel = self2.caret[1]  + self2.ypos
        try:
            xlen = len(self2.text[yidx])
            self2.set_caret(xlen, yidx)
        except:
            pass

    else:
        self2.clearsel()
        self.was_end += 1
        if self.was_end == 2:
            #print (&#34;eop&#34;)
            yidx += 20
            try:
                xlen = len(self2.text[yidx])
                self2.set_caret(xlen, yidx)
                self2.invalidate()
            except:
                pass

        elif self.was_end == 3:
            #print (&#34;eof&#34;)
            last = len(self2.text) - 1
            xlen = len(self2.text[last])
            self2.set_caret(xlen, last)
            self2.invalidate()
            self.was_end = 0
        else:
            xlen = len(self2.text[yidx])
            self2.set_caret(xlen, yidx)

    if self2.shift:
        # End select
        #print(&#34;end sel&#34;, self2.caret[0], self2.caret[1])
        self2.xsel2 = self2.caret[0] + self2.xpos
        self2.ysel2 = self2.caret[1] + self2.ypos
        self2.invalidate()
    else:
        self2.clearsel()
        self2.invalidate()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.esc"><code class="name flex">
<span>def <span class="ident">esc</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def esc(self, self2):

    self2.mained.update_statusbar(&#34;Esc&#34;)
    self2.clearsel()
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;ESC&#34;)

    #print (pedync.yes_no_cancel(&#34;Escape&#34;, &#34;This is a question&#34; ))</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f1"><code class="name flex">
<span>def <span class="ident">f1</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f1(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F1&#34;)
    if self2.shift:
        sss = self._getsel(self2)
        self2.mained.update_statusbar(&#34;Opening DEVDOCS help file ...&#34;)
        try:
            #print(&#34;sss&#34;, sss)
            ret = subprocess.Popen([&#34;devdocs&#34;, &#34;-s&#34;, sss,])
        except:
            pedync.message(&#34;\n   Cannot launch devdocs   \n\n&#34;
                           &#34;              (Please install)&#34;)
    else:
        self2.mained.update_statusbar(&#34;Opening KEYS help file ...&#34;)
        kk = get_exec_path(&#34;KEYS&#34;)
        if pedconfig.conf.verbose:
            print(&#34;Pang open&#34;, kk)
        launch_pangview(kk)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f10"><code class="name flex">
<span>def <span class="ident">f10</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f10(self, self2):
    if self2.shift:
        #print (&#34;shift F10&#34;)
        pass
    if self2.ctrl:
        #print (&#34;ctrl F10&#34;)
        pass</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f11"><code class="name flex">
<span>def <span class="ident">f11</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f11(self, self2):
    if self2.mained.full:
        self2.mained.mywin.unfullscreen()
        self2.mained.full = False
    else:
        self2.mained.mywin.fullscreen()
        self2.mained.full = True
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F11&#34;)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f12"><code class="name flex">
<span>def <span class="ident">f12</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f12(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F12&#34;)

    pass</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f2"><code class="name flex">
<span>def <span class="ident">f2</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f2(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F2&#34;)

    if self2.shift:
        if platform.system().find(&#34;Win&#34;) &gt;= 0:
            pedync.message(&#34;\n   This feature is Linux only   \n\n&#34;
                               &#34;              ()&#34;)
        else:
            sss = self._getsel(self2)
            self2.mained.update_statusbar(&#34;Opening devhelp file ...&#34;)
            try:
                ret = subprocess.Popen([&#34;devhelp&#34;, &#34;-s&#34;, sss,])
                #ret = subprocess.Popen([&#34;gnome-help&#34;,])
            except:
                pedync.message(&#34;\n   Cannot launch devhelp   \n\n&#34;
                               &#34;              (Please install)&#34;)
    elif self2.ctrl:
        # System uses it
        pass
    else:
        if platform.system().find(&#34;Win&#34;) &gt;= 0:
            pedync.message(&#34;\n   This feature is Linux only   \n\n&#34;
                               &#34;              ()&#34;)
        else:
            sss = &#34;python:&#34; + self._getsel(self2)
            self2.mained.update_statusbar(&#34;Opening Zeal with &#39;%s&#39;&#34; % sss)
            try:
                #print(&#34;sss&#34;, sss)
                ret = subprocess.Popen([&#34;zeal&#34;, sss,])
                #ret = subprocess.Popen([&#34;devdocs&#34;, &#34;-s&#34;, sss,])

            except:
                pedync.message(&#34;\n   Cannot launch zeal \n\n&#34;
                               &#34;              (Please install)&#34;)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f3"><code class="name flex">
<span>def <span class="ident">f3</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f3(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F3&#34;)

    if self2.shift:
        self.f5(self2)
    else:
        self.f6(self2)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f4"><code class="name flex">
<span>def <span class="ident">f4</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f4(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F4&#34;)
    #self.play(self2, True)
    try:
        sss = self._getsel(self2)
        ret = subprocess.Popen([&#34;firefox&#34;,
                    &#34;/home/peterglen/pydoc/python-3.8.6rc1-docs-html/index.html&#34; ])
    except:
        pedync.message(&#34;\n   Cannot launch python help  \n\n&#34;
                   &#34;              (Please install)&#34;)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f5"><code class="name flex">
<span>def <span class="ident">f5</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f5(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F5&#34;)

    if len(self2.accum) == 0:
        self2.mained.update_statusbar(
            &#34;Please specify a search string (Ctrl-F) or (Alt-S)&#34;)
        return

    self2.mained.update_statusbar(&#34;Locating previous match.&#34;)
    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos
    self2.search_again()
    cnt = len (self2.accum) - 1; match = False
    while True:
        if cnt &lt; 0 : break
        xstr = self2.accum[cnt]

        try:
            bb = xstr.split(&#34; &#34;)[0].split(&#34;:&#34;)
        except: pass
        #print (&#34;TREE sel&#34;, bb)
        # See if match on the same line
        try:
            if int(bb[1]) == yidx:
                if int(bb[0]) &lt; xidx:
                    self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                    match = True
                    break
            elif int(bb[1]) &lt; yidx:
                self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                match = True
                break
        except:
            pass

        cnt -= 1

    if not match:
        self2.mained.update_statusbar(&#34;At or before first match.&#34;)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f6"><code class="name flex">
<span>def <span class="ident">f6</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f6(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F6&#34;)

    if len(self2.accum) == 0:
        self2.mained.update_statusbar(\
            &#34;Please specify a search string (Ctrl-F) or (Alt-S)&#34;)
        return

    self2.mained.update_statusbar(&#34;Locating Next match.&#34;)
    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos
    match = False

    self2.search_again()

    for xstr in self2.accum:
        # Get back numbers the python way
        try:
            bb = xstr.split(&#34; &#34;)[0].split(&#34;:&#34;)
        except: pass
        #-print (&#34;TREE sel&#34;, bb)
        # See if match on the same line
        if int(bb[1]) == yidx:
            if int(bb[0]) &gt; xidx:
                self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
                match = True
                break
        elif int(bb[1]) &gt; yidx:
            self2.gotoxy(int(bb[0]), int(bb[1]), int(bb[2]), True)
            match = True
            break

    if not match:
        self2.mained.update_statusbar(&#34;At or after last match.&#34;)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f7"><code class="name flex">
<span>def <span class="ident">f7</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f7(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F7&#34;)

    pedconfig.conf.keyh.reset()
    if self2.record:
        self2.record = False
        # Nothing recorded, restore old
        if self2.recarr == []:
            self2.mained.update_statusbar(&#34;Nothing recorded, resored old macro.&#34;)
            self2.recarr = self2.recarr2
            pedconfig.conf.recarr = self2.recarr[:]
        else:
            pedconfig.conf.recarr = self2.recarr[:]
            self2.mained.update_statusbar(&#34;Ended recording.&#34;)

    else:
        self2.mained.update_statusbar(&#34;Started recording ...&#34;)
        self2.recarr2 = self2.recarr
        self2.recarr = []
        self2.record = True
    pedconfig.conf.keyh.reset()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f8"><code class="name flex">
<span>def <span class="ident">f8</span></span>(<span>self, self2, anim=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f8(self, self2, anim = False):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F8&#34;)

    self.play(self2, anim)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.f9"><code class="name flex">
<span>def <span class="ident">f9</span></span>(<span>self, self2, flag=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f9(self, self2, flag = False):
    self2.spell = not self2.spell

    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;F9 spell&#34;, self2.spell)

    if self2.spell:
        ooo = &#34;on.&#34;
        if self2.shift or flag:
            self2.spellmode = True; ppp = &#34;Mode: text&#34;
        else:
            self2.spellmode = False; ppp = &#34;Mode: code&#34;
    else:
        ooo = &#34;off.&#34;; ppp = &#34;&#34;

    self2.mained.update_statusbar(&#34;Spell checking is %s %s&#34; % (ooo, ppp))
    pedspell.spell(self2, self2.spellmode)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.home"><code class="name flex">
<span>def <span class="ident">home</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def home(self, self2):

    #print(&#34;Home&#34;)

    xidx = self2.caret[0] + self2.xpos
    yidx = self2.caret[1] + self2.ypos
    if self2.shift:
        # Begin select
        if self2.xsel == -1:
            self2.xsel = xidx
        if self2.ysel == -1:
            self2.ysel = yidx
    if self2.alt:
        #print (&#34;alt-home&#34;)
        self2.mained.firstwin()
        pass
    elif self2.ctrl:
        self2.set_caret(0, 0)
        self2.invalidate()
    else:
        self.was_home += 1
        if self.was_home == 1:
            self2.set_caret(0, yidx)
            self2.invalidate()
        if self.was_home == 2:
            self2.set_caret(0, yidx - self2.pgup)
            self2.invalidate()
        elif self.was_home == 3:
            #print (&#34;bof&#34;)
            self.top(self2)
            self.was_home = 0

    if self2.shift:
        # End select
        self2.xsel2 = self2.caret[0] + self2.xpos
        self2.ysel2 = self2.caret[1] + self2.ypos
        self2.invalidate()
    else:
        self2.clearsel()
        self2.invalidate()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ins"><code class="name flex">
<span>def <span class="ident">ins</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ins(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;INS&#34;)

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos
    self2.insert = not self2.insert
    self2.set_caret(xidx, yidx)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.left"><code class="name flex">
<span>def <span class="ident">left</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def left(self, self2):

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    if self2.shift:
        # Begin select
        if self2.xsel == -1:
            self2.xsel = xidx
            #self2.colsel = True
        if self2.ysel == -1:
            self2.ysel = yidx

    if self2.ctrl:
        line = self2.text[yidx]
        idx  = xprevchar(line, &#34; &#34;, self2.caret[0] - 1)
        idx2 = prevchar(line, &#34; &#34;, idx)
        idx3 = xprevchar(line, &#34; &#34;, idx2)
        if idx == -1:
            #print (&#34;ctrl - L prev line&#34;)
            if yidx:
                yidx -= 1
                line = self2.text[yidx]
                xidx = len(line)
                idx = xprevchar(line, &#34; &#34;, xidx)
                self2.set_caret(idx+1 , yidx)
        else:
            self2.set_caret(idx3+1, yidx)
        self2.invalidate()
    elif self2.alt:
        line = self2.text[yidx]
        # Only move ONE word
        try:
            if line[xidx-1] != &#34; &#34;:
                begs, ends = selword(line, xidx-1)
                self2.set_caret(begs, yidx)
        except:
            pass
    else:
        self2.set_caret(xidx - 1, yidx)

    # Extend selection
    if self2.shift:
        self2.ysel2 = self2.caret[1] + self2.ypos
        if self2.ysel &gt; self2.ysel2:
            self2.xsel = self2.caret[0] + self2.xpos
        else:
            self2.xsel2 = self2.caret[0] + self2.xpos
    else:
        self2.clearsel()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.pad_line"><code class="name flex">
<span>def <span class="ident">pad_line</span></span>(<span>self, self2, xidx, yidx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad_line(self, self2, xidx, yidx):
    xlen = len(self2.text[yidx])
    if xidx &gt;= xlen:
        #self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
        for aa in range(xidx - xlen):
            self2.text[yidx] += &#34; &#34;</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.pad_list"><code class="name flex">
<span>def <span class="ident">pad_list</span></span>(<span>self, self2, yidx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pad_list(self, self2, yidx):
     # Extend list to accomodate insert
    ylen = len(self2.text) - 1 # dealing with index vs len
    if yidx &gt;= ylen:
        cnt = 0
        for aa in range(yidx - ylen):
            #self2.undoarr.append((0,  yidx + cnt, pedundo.ADDED + pedundo.CONTFLAG, &#34;&#34;))
            self2.text.append(&#34;&#34;)
            cnt += 1
        #self2.undoarr.append((0, yidx, pedundo.NOOP, &#34;&#34;))</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.pgdn"><code class="name flex">
<span>def <span class="ident">pgdn</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pgdn(self, self2):

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    if self2.shift:
        # Begin select
        if self2.xsel == -1:
            self2.xsel = xidx
            self2.colsel = False
        if self2.ysel == -1:
            self2.ysel = yidx

    if self2.alt:
        #print (&#34;alt-pgdn&#34;)
        self2.mained.prevwin()
    elif self2.ctrl:
        self2.set_caret(self2.caret[0], yidx + 2 * self2.pgup)
    else:
        self2.set_caret(self2.caret[0], yidx + self2.pgup)

    # Extend selection
    if self2.shift:
        self2.ysel2 = self2.caret[1] + self2.ypos
        if self2.ysel &gt; self2.ysel2:
            self2.xsel = self2.caret[0] + self2.xpos
        else:
            self2.xsel2 = self2.caret[0] + self2.xpos
        self2.invalidate()
    else:
        self2.clearsel()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.pgup"><code class="name flex">
<span>def <span class="ident">pgup</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pgup(self, self2):

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    if self2.shift:
        # Begin select
        if self2.xsel == -1:
            self2.xsel = xidx
            self2.colsel = False
        if self2.ysel == -1:
            self2.ysel = yidx

    if self2.alt:
        #print (&#34;alt-pgup&#34;)
        self2.mained.nextwin()
    elif self2.ctrl:
        self2.set_caret(self2.caret[0], yidx - 2 * self2.pgup)
    else:
        self2.set_caret(self2.caret[0], yidx - self2.pgup)

    # Extend selection
    if self2.shift:
        self2.ysel2 = self2.caret[1] + self2.ypos
        if self2.ysel &gt; self2.ysel2:
            self2.xsel = self2.caret[0] + self2.xpos
        else:
            self2.xsel2 = self2.caret[0] + self2.xpos
        self2.invalidate()
    else:
        self2.clearsel()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, self2, anim=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self, self2, anim = False):

    if self2.record:
        self2.mained.update_statusbar(&#34;Still recording, press F7 to stop&#34;)
        return True

    xlen = len(self2.recarr)
    if xlen == 0:
        # pull in global
        self2.recarr = pedconfig.conf.recarr[:]

    xlen = len(self2.recarr)
    if xlen == 0:
        self2.mained.update_statusbar(&#34;Nothing recorded, cannot play.&#34;)
        return True

    pedconfig.conf.keyh.reset()
    self2.mained.update_statusbar(&#34;Started Play ...&#34;)
    idx = 0
    while True:
        if idx &gt;= xlen: break
        #www,
        tt, kk, ss, sss, \
          pedconfig.conf.keyh.shift, pedconfig.conf.keyh.ctrl, \
                            pedconfig.conf.keyh.alt = self2.recarr[idx]
        idx += 1

        # Synthesize keystroke. We do not replicate state as
        # pyedpro maintains its own internally. (see keyhand.reset())

        ttt = Gdk.EventType.KEY_PRESS
        if tt == 9:
            ttt = Gdk.EventType.KEY_RELEASE

        #print (&#34;playing macro&#34;, tt, kk, ss)
        event = Gdk.EventKey()
        event.type = ttt
        #event.time = time.clock() * 1000
        event.keyval = kk
        #event.window = www
        event.string  = sss
        #print (&#34;play event&#34;, event, event.type, event.keyval)

        pedconfig.conf.keyh.state2 = ss
        pedconfig.conf.keyh.handle_key2(self2, None, event)
        if anim:
            usleep(30)
        #print()
    # If the state gets out or sync ...
    pedconfig.conf.keyh.reset()
    self2.mained.update_statusbar(&#34;Ended Play.&#34;)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.ret"><code class="name flex">
<span>def <span class="ident">ret</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ret(self, self2):

    if self2.readonly:
        self2.mained.update_statusbar(rostr)
        return

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos
    self.pad_list(self2, yidx)
    line = self2.text[yidx][:]
    self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
    spaces = cntleadchar(line, &#34; &#34;)
    self2.text[yidx] = line[:xidx];
    # Insert new after current
    yidx += 1
    self2.undoarr.append((xidx, yidx, pedundo.ADDED + pedundo.CONTFLAG, \
            spaces + line[xidx:]))
    text = self2.text[:yidx]
    text.append(spaces + line[xidx:])
    text += self2.text[yidx:]
    self2.text = text
    self2.set_caret(len(spaces), yidx)

    # Signal the rest for ...
    for aa in sumkeywords:
        if line.find(aa) &gt;= 0:
            self2.needscan = True

    # Contain undo
    pedundo.limit_undo(self2)

    # Update maxlines
    mlines = len(self2.text)
    if mlines &gt; self2.maxlines + 10:
        self2.set_maxlines(mlines)

    self2.set_changed(True)
    self2.src_changed = True
    self2.invalidate()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.right"><code class="name flex">
<span>def <span class="ident">right</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def right(self, self2):

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    if self2.shift:
        # Begin select
        if self2.xsel == -1:
            self2.xsel = xidx
            self2.colsel = False
        if self2.ysel == -1:
            self2.ysel = yidx

    if self2.ctrl:
        line = self2.text[yidx]
        idx = nextchar(line, &#34; &#34;, xidx)
        idx2 = xnextchar(line, &#34; &#34;, idx)
        #print (idx, idx2, len(line))
        # Jump to next line
        if idx2 == idx or idx2 == len(line):
            yidx += 1
            if yidx &lt; len(self2.text):
                self2.caret[0] = 0
                line = self2.text[yidx]
                idx2 = xnextchar(line, &#34; &#34;, 0)
                self2.set_caret(idx2, yidx)
                self2.invalidate()
        else:
            #print (&#34;ctrl_right&#34;, idx2, yidx)
            self2.set_caret(idx2, yidx)
    elif self2.alt:
        line = self2.text[yidx]
        begs, ends = selword(line, xidx)
        self2.set_caret(ends, yidx)
    else:
        self2.set_caret(xidx + 1, yidx)

    # Extend selection
    if self2.shift:
        self2.ysel2 = self2.caret[1] + self2.ypos
        if self2.ysel &gt; self2.ysel2:
            self2.xsel = self2.caret[0] + self2.xpos
        else:
            self2.xsel2 = self2.caret[0] + self2.xpos
        self2.invalidate()
    else:
        self2.clearsel()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.super_a"><code class="name flex">
<span>def <span class="ident">super_a</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def super_a(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;SUPER - A&#34;)
    self.alt_a(self2)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.super_b"><code class="name flex">
<span>def <span class="ident">super_b</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def super_b(self, self2):
    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;SUPER - B&#34;)
    self.alt_b(self2)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.tab"><code class="name flex">
<span>def <span class="ident">tab</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tab(self, self2):

    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    if pedconfig.conf.pgdebug &gt; 4:
        print (&#34;TAB&#34;, self2.shift)

    #tabstop = 4
    tabstop = self2.tabstop
    self.pad_list(self2, yidx)

    # No Selection, do tab
    if self2.ysel == -1:
        self2.undoarr.append((xidx, yidx, pedundo.MODIFIED, self2.text[yidx]))
        if self2.shift:
            line2 = self2.text[yidx][:]
            self2.text[yidx] = line2[:xidx] + &#34;\t&#34; + line2[xidx:]
            spaces = self2.tabstop - (xidx % self2.tabstop)
            self2.set_caret(xidx+1, yidx)

            #print (&#34;shif tab&#34;, spaces)
            #self2.set_caret(xidx + tabstop, yidx)
        else:
            spaces = tabstop - (xidx % tabstop)
            while spaces:
                #event = Gdk.Event(Gdk.EventType.KEY_PRESS);
                event = Gdk.EventKey()
                event.string  = &#34; &#34;
                event.keyval = ord(&#34; &#34;)
                self.add_key(self2, event)
                spaces -= 1
        self2.invalidate()
        self2.set_changed(True)
    else:
        # Indent, normalize
        yssel = min(self2.ysel, self2.ysel2)
        yesel = max(self2.ysel, self2.ysel2)
        #print (&#34;TAB in sel&#34;)
        cnt = yssel
        self2.undoarr.append((xidx, yidx, pedundo.NOOP, &#34;&#34;))
        if self2.shift:
            while True:
                if cnt &gt; yesel: break
                self2.undoarr.append((xidx, cnt, \
                        pedundo.MODIFIED | pedundo.CONTFLAG, self2.text[cnt]))
                self2.text[cnt] =  rmlspace(self2.text[cnt], 4)
                cnt += 1
        else:
            while True:
                if cnt &gt; yesel: break
                self2.undoarr.append((xidx, cnt, \
                    pedundo.MODIFIED | pedundo.CONTFLAG, self2.text[cnt]))
                self2.text[cnt] = &#34;    &#34; + self2.text[cnt]
                cnt += 1
        self2.invalidate()
        self2.set_changed(True)</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.top"><code class="name flex">
<span>def <span class="ident">top</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def top(self, self2):

    self.was_home = 0
    self2.set_caret(0, 0)
    self2.invalidate()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.up"><code class="name flex">
<span>def <span class="ident">up</span></span>(<span>self, self2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def up(self, self2):
    xidx = self2.caret[0] + self2.xpos;
    yidx = self2.caret[1] + self2.ypos

    incr = 1
    if self2.alt:
        self.pgup(self2)
    elif self2.ctrl:
        incr = 10
    elif self2.shift:
        # Begin select
        if self2.xsel == -1:
            self2.xsel = xidx
            self2.xsel2 = xidx + 1
        if self2.ysel == -1:
            self2.ysel = yidx

    self2.set_caret(xidx, yidx - incr)

    if self2.shift:
        self2.ysel2 = self2.caret[1] + self2.ypos
        self2.invalidate()
    else:
        self2.clearsel()</code></pre>
</details>
</dd>
<dt id="acthand.ActHand.xclip_cb"><code class="name flex">
<span>def <span class="ident">xclip_cb</span></span>(<span>self, self2, ctext, cummx)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xclip_cb(self, self2, ctext, cummx):
    cummx = ctext + cummx
    self2.clipboard.set_text(cummx, len(cummx))
    #self2.clipboard.request_text(self.xclip_cb, cumm)
    ttt = self2.clipboard.wait_for_text()
    self.clip_cb(none, ttt, self2)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="acthand.ActHand" href="#acthand.ActHand">ActHand</a></code></h4>
<ul class="two-column">
<li><code><a title="acthand.ActHand.add_key" href="#acthand.ActHand.add_key">add_key</a></code></li>
<li><code><a title="acthand.ActHand.add_str" href="#acthand.ActHand.add_str">add_str</a></code></li>
<li><code><a title="acthand.ActHand.bottom" href="#acthand.ActHand.bottom">bottom</a></code></li>
<li><code><a title="acthand.ActHand.bs" href="#acthand.ActHand.bs">bs</a></code></li>
<li><code><a title="acthand.ActHand.clip_cb" href="#acthand.ActHand.clip_cb">clip_cb</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_a" href="#acthand.ActHand.ctrl_a">ctrl_a</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_b" href="#acthand.ActHand.ctrl_b">ctrl_b</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_c" href="#acthand.ActHand.ctrl_c">ctrl_c</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_d" href="#acthand.ActHand.ctrl_d">ctrl_d</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_e" href="#acthand.ActHand.ctrl_e">ctrl_e</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_f" href="#acthand.ActHand.ctrl_f">ctrl_f</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_g" href="#acthand.ActHand.ctrl_g">ctrl_g</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_h" href="#acthand.ActHand.ctrl_h">ctrl_h</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_i" href="#acthand.ActHand.ctrl_i">ctrl_i</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_j" href="#acthand.ActHand.ctrl_j">ctrl_j</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_k" href="#acthand.ActHand.ctrl_k">ctrl_k</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_l" href="#acthand.ActHand.ctrl_l">ctrl_l</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_m" href="#acthand.ActHand.ctrl_m">ctrl_m</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_n" href="#acthand.ActHand.ctrl_n">ctrl_n</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_num" href="#acthand.ActHand.ctrl_num">ctrl_num</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_num_clip" href="#acthand.ActHand.ctrl_num_clip">ctrl_num_clip</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_o" href="#acthand.ActHand.ctrl_o">ctrl_o</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_p" href="#acthand.ActHand.ctrl_p">ctrl_p</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_q" href="#acthand.ActHand.ctrl_q">ctrl_q</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_r" href="#acthand.ActHand.ctrl_r">ctrl_r</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_s" href="#acthand.ActHand.ctrl_s">ctrl_s</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_space" href="#acthand.ActHand.ctrl_space">ctrl_space</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_t" href="#acthand.ActHand.ctrl_t">ctrl_t</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_tab" href="#acthand.ActHand.ctrl_tab">ctrl_tab</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_u" href="#acthand.ActHand.ctrl_u">ctrl_u</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_v" href="#acthand.ActHand.ctrl_v">ctrl_v</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_w" href="#acthand.ActHand.ctrl_w">ctrl_w</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_x" href="#acthand.ActHand.ctrl_x">ctrl_x</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_y" href="#acthand.ActHand.ctrl_y">ctrl_y</a></code></li>
<li><code><a title="acthand.ActHand.ctrl_z" href="#acthand.ActHand.ctrl_z">ctrl_z</a></code></li>
<li><code><a title="acthand.ActHand.cut" href="#acthand.ActHand.cut">cut</a></code></li>
<li><code><a title="acthand.ActHand.delete" href="#acthand.ActHand.delete">delete</a></code></li>
<li><code><a title="acthand.ActHand.down" href="#acthand.ActHand.down">down</a></code></li>
<li><code><a title="acthand.ActHand.end" href="#acthand.ActHand.end">end</a></code></li>
<li><code><a title="acthand.ActHand.esc" href="#acthand.ActHand.esc">esc</a></code></li>
<li><code><a title="acthand.ActHand.f1" href="#acthand.ActHand.f1">f1</a></code></li>
<li><code><a title="acthand.ActHand.f10" href="#acthand.ActHand.f10">f10</a></code></li>
<li><code><a title="acthand.ActHand.f11" href="#acthand.ActHand.f11">f11</a></code></li>
<li><code><a title="acthand.ActHand.f12" href="#acthand.ActHand.f12">f12</a></code></li>
<li><code><a title="acthand.ActHand.f2" href="#acthand.ActHand.f2">f2</a></code></li>
<li><code><a title="acthand.ActHand.f3" href="#acthand.ActHand.f3">f3</a></code></li>
<li><code><a title="acthand.ActHand.f4" href="#acthand.ActHand.f4">f4</a></code></li>
<li><code><a title="acthand.ActHand.f5" href="#acthand.ActHand.f5">f5</a></code></li>
<li><code><a title="acthand.ActHand.f6" href="#acthand.ActHand.f6">f6</a></code></li>
<li><code><a title="acthand.ActHand.f7" href="#acthand.ActHand.f7">f7</a></code></li>
<li><code><a title="acthand.ActHand.f8" href="#acthand.ActHand.f8">f8</a></code></li>
<li><code><a title="acthand.ActHand.f9" href="#acthand.ActHand.f9">f9</a></code></li>
<li><code><a title="acthand.ActHand.home" href="#acthand.ActHand.home">home</a></code></li>
<li><code><a title="acthand.ActHand.ins" href="#acthand.ActHand.ins">ins</a></code></li>
<li><code><a title="acthand.ActHand.left" href="#acthand.ActHand.left">left</a></code></li>
<li><code><a title="acthand.ActHand.pad_line" href="#acthand.ActHand.pad_line">pad_line</a></code></li>
<li><code><a title="acthand.ActHand.pad_list" href="#acthand.ActHand.pad_list">pad_list</a></code></li>
<li><code><a title="acthand.ActHand.pgdn" href="#acthand.ActHand.pgdn">pgdn</a></code></li>
<li><code><a title="acthand.ActHand.pgup" href="#acthand.ActHand.pgup">pgup</a></code></li>
<li><code><a title="acthand.ActHand.play" href="#acthand.ActHand.play">play</a></code></li>
<li><code><a title="acthand.ActHand.ret" href="#acthand.ActHand.ret">ret</a></code></li>
<li><code><a title="acthand.ActHand.right" href="#acthand.ActHand.right">right</a></code></li>
<li><code><a title="acthand.ActHand.super_a" href="#acthand.ActHand.super_a">super_a</a></code></li>
<li><code><a title="acthand.ActHand.super_b" href="#acthand.ActHand.super_b">super_b</a></code></li>
<li><code><a title="acthand.ActHand.tab" href="#acthand.ActHand.tab">tab</a></code></li>
<li><code><a title="acthand.ActHand.top" href="#acthand.ActHand.top">top</a></code></li>
<li><code><a title="acthand.ActHand.up" href="#acthand.ActHand.up">up</a></code></li>
<li><code><a title="acthand.ActHand.xclip_cb" href="#acthand.ActHand.xclip_cb">xclip_cb</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>